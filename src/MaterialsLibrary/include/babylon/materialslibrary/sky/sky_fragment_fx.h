#ifndef BABYLON_MATERIALS_LIBRARY_SKY_SKY_FRAGMENT_FX_H
#define BABYLON_MATERIALS_LIBRARY_SKY_SKY_FRAGMENT_FX_H

namespace BABYLON {

extern const char* skyPixelShader;

const char* skyPixelShader
  = "#ifdef GL_ES\n"
    "precision highp float;\n"
    "#endif\n"
    "\n"
    "// Input\n"
    "varying vec3 vPositionW;\n"
    "\n"
    "#ifdef VERTEXCOLOR\n"
    "varying vec4 vColor;\n"
    "#endif\n"
    "\n"
    "#include<clipPlaneFragmentDeclaration>\n"
    "\n"
    "// Sky\n"
    "uniform vec3 cameraPosition;\n"
    "uniform float luminance;\n"
    "uniform float turbidity;\n"
    "uniform float rayleigh;\n"
    "uniform float mieCoefficient;\n"
    "uniform float mieDirectionalG;\n"
    "uniform vec3 sunPosition;\n"
    "\n"
    "// Fog\n"
    "#include<fogFragmentDeclaration>\n"
    "\n"
    "// Constants\n"
    "const float e = 2.71828182845904523536028747135266249775724709369995957;\n"
    "const float pi = 3.141592653589793238462643383279502884197169;\n"
    "const float n = 1.0003;\n"
    "const float N = 2.545E25;\n"
    "const float pn = 0.035;\n"
    "\n"
    "const vec3 lambda = vec3(680E-9, 550E-9, 450E-9);\n"
    "\n"
    "const vec3 K = vec3(0.686, 0.678, 0.666);\n"
    "const float v = 4.0;\n"
    "\n"
    "const float rayleighZenithLength = 8.4E3;\n"
    "const float mieZenithLength = 1.25E3;\n"
    "const vec3 up = vec3(0.0, 1.0, 0.0);\n"
    "\n"
    "const float EE = 1000.0;\n"
    "const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n"
    "\n"
    "const float cutoffAngle = pi/1.95;\n"
    "const float steepness = 1.5;\n"
    "\n"
    "vec3 totalRayleigh(vec3 lambda)\n"
    "{\n"
    "  return (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn));\n"
    "}\n"
    "\n"
    "vec3 simplifiedRayleigh()\n"
    "{\n"
    "  return 0.0005 / vec3(94, 40, 18);\n"
    "}\n"
    "\n"
    "float rayleighPhase(float cosTheta)\n"
    "{   \n"
    "  return (3.0 / (16.0*pi)) * (1.0 + pow(cosTheta, 2.0));\n"
    "}\n"
    "\n"
    "vec3 totalMie(vec3 lambda, vec3 K, float T)\n"
    "{\n"
    "  float c = (0.2 * T ) * 10E-18;\n"
    "  return 0.434 * c * pi * pow((2.0 * pi) / lambda, vec3(v - 2.0)) * K;\n"
    "}\n"
    "\n"
    "float hgPhase(float cosTheta, float g)\n"
    "{\n"
    "  return (1.0 / (4.0*pi)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));\n"
    "}\n"
    "\n"
    "float sunIntensity(float zenithAngleCos)\n"
    "{\n"
    "  return EE * max(0.0, 1.0 - exp((-(cutoffAngle - acos(zenithAngleCos))/steepness)));\n"
    "}\n"
    "\n"
    "float A = 0.15;\n"
    "float B = 0.50;\n"
    "float C = 0.10;\n"
    "float D = 0.20;\n"
    "float EEE = 0.02;\n"
    "float F = 0.30;\n"
    "float W = 1000.0;\n"
    "\n"
    "vec3 Uncharted2Tonemap(vec3 x)\n"
    "{\n"
    "  return ((x*(A*x+C*B)+D*EEE)/(x*(A*x+B)+D*F))-EEE/F;\n"
    "}\n"
    "\n"
    "void main(void) {\n"
    "  // Clip plane\n"
    "#include<clipPlaneFragment>\n"
    "\n"
    "  /**\n"
    "  *--------------------------------------------------------------------------------------------------\n"
    "  * Sky Color\n"
    "  *--------------------------------------------------------------------------------------------------\n"
    "  */\n"
    "  float sunfade = 1.0 - clamp(1.0 - exp((sunPosition.y / 450000.0)), 0.0, 1.0);\n"
    "  float rayleighCoefficient = rayleigh - (1.0 * (1.0 - sunfade));\n"
    "  vec3 sunDirection = normalize(sunPosition);\n"
    "  float sunE = sunIntensity(dot(sunDirection, up));\n"
    "  vec3 betaR = simplifiedRayleigh() * rayleighCoefficient;\n"
    "  vec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;\n"
    "  float zenithAngle = acos(max(0.0, dot(up, normalize(vPositionW - cameraPosition))));\n"
    "  float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));\n"
    "  float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));\n"
    "  vec3 Fex = exp(-(betaR * sR + betaM * sM));\n"
    "  float cosTheta = dot(normalize(vPositionW - cameraPosition), sunDirection);\n"
    "  float rPhase = rayleighPhase(cosTheta*0.5+0.5);\n"
    "  vec3 betaRTheta = betaR * rPhase;\n"
    "  float mPhase = hgPhase(cosTheta, mieDirectionalG);\n"
    "  vec3 betaMTheta = betaM * mPhase;\n"
    "  \n"
    "  vec3 Lin = pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex),vec3(1.5));\n"
    "  Lin *= mix(vec3(1.0), pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex, vec3(1.0 / 2.0)), clamp(pow(1.0-dot(up, sunDirection), 5.0), 0.0, 1.0));\n"
    "\n"
    "  vec3 direction = normalize(vPositionW - cameraPosition);\n"
    "  float theta = acos(direction.y);\n"
    "  float phi = atan(direction.z, direction.x);\n"
    "  vec2 uv = vec2(phi, theta) / vec2(2.0 * pi, pi) + vec2(0.5, 0.0);\n"
    "  vec3 L0 = vec3(0.1) * Fex;\n"
    "  \n"
    "  float sundisk = smoothstep(sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta);\n"
    "  L0 += (sunE * 19000.0 * Fex) * sundisk;\n"
    "  \n"
    "  vec3 whiteScale = 1.0/Uncharted2Tonemap(vec3(W));\n"
    "  vec3 texColor = (Lin+L0);   \n"
    "  texColor *= 0.04 ;\n"
    "  texColor += vec3(0.0,0.001,0.0025)*0.3;\n"
    "\n"
    "  float g_fMaxLuminance = 1.0;\n"
    "  float fLumScaled = 0.1 / luminance;     \n"
    "  float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (g_fMaxLuminance * g_fMaxLuminance)))) / (1.0 + fLumScaled); \n"
    "\n"
    "  float ExposureBias = fLumCompressed;\n"
    "\n"
    "  vec3 curr = Uncharted2Tonemap((log2(2.0/pow(luminance,4.0)))*texColor);\n"
    "\n"
    "  // May generate a bug so just just keep retColor = skyColor;\n"
    "  // vec3 skyColor = curr * whiteScale;\n"
    "  //vec3 retColor = pow(skyColor,vec3(1.0/(1.2+(1.2*sunfade))));\n"
    "\n"
    "  vec3 retColor = curr * whiteScale;\n"
    "\n"
    "  /**\n"
    "  *--------------------------------------------------------------------------------------------------\n"
    "  * Sky Color\n"
    "  *--------------------------------------------------------------------------------------------------\n"
    "  */\n"
    "  \n"
    "  // Alpha\n"
    "  float alpha = 1.0;\n"
    "\n"
    "#ifdef VERTEXCOLOR\n"
    "  retColor.rgb *= vColor.rgb;\n"
    "#endif\n"
    "\n"
    "#ifdef VERTEXALPHA\n"
    "  alpha *= vColor.a;\n"
    "#endif\n"
    "\n"
    "  // Composition\n"
    "  vec4 color = clamp(vec4(retColor.rgb, alpha), 0.0, 1.0);\n"
    "\n"
    "  // Fog\n"
    "#include<fogFragment>\n"
    "\n"
    "  gl_FragColor = color;\n"
    "}\n";

} // end of namespace BABYLON

#endif // end of BABYLON_MATERIALS_LIBRARY_SKY_SKY_FRAGMENT_FX_H
