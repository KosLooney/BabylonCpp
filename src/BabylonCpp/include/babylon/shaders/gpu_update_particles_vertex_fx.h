#ifndef BABYLON_SHADERS_GPU_UPDATE_PARTICLES_VERTEX_FX_H
#define BABYLON_SHADERS_GPU_UPDATE_PARTICLES_VERTEX_FX_H

namespace BABYLON {

extern const char* gpuUpdateParticlesVertexShader;

const char* gpuUpdateParticlesVertexShader
  = "#version 300 es\n"
    "\n"
    "#define PI 3.14159\n"
    "\n"
    "uniform float currentCount;\n"
    "uniform float timeDelta;\n"
    "uniform float stopFactor;\n"
    "uniform mat4 emitterWM;\n"
    "uniform vec2 lifeTime;\n"
    "uniform vec2 emitPower;\n"
    "uniform vec2 sizeRange;\n"
    "uniform vec4 scaleRange;\n"
    "#ifndef COLORGRADIENTS\n"
    "uniform vec4 color1;\n"
    "uniform vec4 color2;\n"
    "#endif\n"
    "uniform vec3 gravity;\n"
    "uniform sampler2D randomSampler;\n"
    "uniform sampler2D randomSampler2;\n"
    "uniform vec4 angleRange;\n"
    "\n"
    "#ifdef BOXEMITTER\n"
    "uniform vec3 direction1;\n"
    "uniform vec3 direction2;\n"
    "uniform vec3 minEmitBox;\n"
    "uniform vec3 maxEmitBox;\n"
    "#endif\n"
    "\n"
    "#ifdef POINTEMITTER\n"
    "uniform vec3 direction1;\n"
    "uniform vec3 direction2;\n"
    "#endif\n"
    "\n"
    "#ifdef HEMISPHERICEMITTER\n"
    "uniform float radius;\n"
    "uniform float radiusRange;\n"
    "uniform float directionRandomizer;\n"
    "#endif\n"
    "\n"
    "#ifdef SPHEREEMITTER\n"
    "uniform float radius;\n"
    "uniform float radiusRange;\n"
    "#ifdef DIRECTEDSPHEREEMITTER\n"
    "  uniform vec3 direction1;\n"
    "  uniform vec3 direction2;\n"
    "#else\n"
    "  uniform float directionRandomizer;\n"
    "#endif\n"
    "#endif\n"
    "\n"
    "#ifdef CYLINDEREMITTER\n"
    "uniform float radius;\n"
    "uniform float height;\n"
    "uniform float radiusRange;\n"
    "uniform float directionRandomizer;\n"
    "#endif\n"
    "\n"
    "#ifdef CONEEMITTER\n"
    "uniform vec2 radius;\n"
    "uniform float coneAngle;\n"
    "uniform vec2 height;\n"
    "uniform float directionRandomizer;\n"
    "#endif\n"
    "\n"
    "// Particles state\n"
    "in vec3 position;\n"
    "in float age;\n"
    "in float life;\n"
    "in vec4 seed;\n"
    "in vec3 size;\n"
    "#ifndef COLORGRADIENTS\n"
    "in vec4 color;\n"
    "#endif\n"
    "in vec3 direction;\n"
    "#ifndef BILLBOARD\n"
    "in vec3 initialDirection;\n"
    "#endif\n"
    "#ifdef ANGULARSPEEDGRADIENTS\n"
    "in float angle;\n"
    "#else\n"
    "in vec2 angle;\n"
    "#endif\n"
    "#ifdef ANIMATESHEET\n"
    "in float cellIndex;\n"
    "#endif\n"
    "\n"
    "// Output\n"
    "out vec3 outPosition;\n"
    "out float outAge;\n"
    "out float outLife;\n"
    "out vec4 outSeed;\n"
    "out vec3 outSize;\n"
    "#ifndef COLORGRADIENTS\n"
    "out vec4 outColor;\n"
    "#endif\n"
    "out vec3 outDirection;\n"
    "#ifndef BILLBOARD\n"
    "out vec3 outInitialDirection;\n"
    "#endif\n"
    "#ifdef ANGULARSPEEDGRADIENTS\n"
    "out float outAngle;\n"
    "#else\n"
    "out vec2 outAngle;\n"
    "#endif\n"
    "#ifdef ANIMATESHEET\n"
    "out float outCellIndex;\n"
    "#endif\n"
    "\n"
    "#ifdef SIZEGRADIENTS\n"
    "uniform sampler2D sizeGradientSampler;\n"
    "#endif \n"
    "\n"
    "#ifdef ANGULARSPEEDGRADIENTS\n"
    "uniform sampler2D angularSpeedGradientSampler;\n"
    "#endif \n"
    "\n"
    "#ifdef VELOCITYGRADIENTS\n"
    "uniform sampler2D velocityGradientSampler;\n"
    "#endif\n"
    "\n"
    "#ifdef NOISE\n"
    "uniform vec3 noiseStrength;\n"
    "uniform sampler2D noiseSampler;\n"
    "#endif\n"
    "\n"
    "#ifdef ANIMATESHEET\n"
    "uniform vec3 cellInfos;\n"
    "#endif\n"
    "\n"
    "\n"
    "vec3 getRandomVec3(float offset) {\n"
    "  return texture(randomSampler2, vec2(float(gl_VertexID) * offset / currentCount, 0)).rgb;\n"
    "}\n"
    "\n"
    "vec4 getRandomVec4(float offset) {\n"
    "  return texture(randomSampler, vec2(float(gl_VertexID) * offset / currentCount, 0));\n"
    "}\n"
    "\n"
    "void main() {\n"
    "  float newAge = age + timeDelta;\n"
    "  if (newAge >= life) {\n"
    "  if (stopFactor == 0.) {\n"
    "  outPosition = position;\n"
    "  outAge = life;\n"
    "  outLife = life;\n"
    "  outSeed = seed;\n"
    "#ifndef COLORGRADIENTS      \n"
    "  outColor = vec4(0.,0.,0.,0.);\n"
    "#endif\n"
    "  outSize = vec3(0., 0., 0.);\n"
    "#ifndef BILLBOARD        \n"
    "  outInitialDirection = initialDirection;\n"
    "#endif      \n"
    "  outDirection = direction;\n"
    "  outAngle = angle;\n"
    "#ifdef ANIMATESHEET      \n"
    "  outCellIndex = cellIndex;\n"
    "#endif\n"
    "  return;\n"
    "  }\n"
    "  vec3 position;\n"
    "  vec3 direction;\n"
    "\n"
    "  // Let's get some random values\n"
    "  vec4 randoms = getRandomVec4(seed.x);\n"
    "\n"
    "  // Age and life\n"
    "  outAge = 0.0;\n"
    "  outLife = lifeTime.x + (lifeTime.y - lifeTime.x) * randoms.r;\n"
    "\n"
    "  // Seed\n"
    "  outSeed = seed;\n"
    "\n"
    "  // Size\n"
    "#ifdef SIZEGRADIENTS    \n"
    "  outSize.x = texture(sizeGradientSampler, vec2(0, 0)).r;\n"
    "#else\n"
    "  outSize.x = sizeRange.x + (sizeRange.y - sizeRange.x) * randoms.g;\n"
    "#endif\n"
    "  outSize.y = scaleRange.x + (scaleRange.y - scaleRange.x) * randoms.b;\n"
    "  outSize.z = scaleRange.z + (scaleRange.w - scaleRange.z) * randoms.a; \n"
    "\n"
    "#ifndef COLORGRADIENTS\n"
    "  // Color\n"
    "  outColor = color1 + (color2 - color1) * randoms.b;\n"
    "#endif\n"
    "\n"
    "  // Angular speed\n"
    "#ifndef ANGULARSPEEDGRADIENTS    \n"
    "  outAngle.y = angleRange.x + (angleRange.y - angleRange.x) * randoms.a;\n"
    "  outAngle.x = angleRange.z + (angleRange.w - angleRange.z) * randoms.r;\n"
    "#else\n"
    "  outAngle = angleRange.z + (angleRange.w - angleRange.z) * randoms.r;\n"
    "#endif        \n"
    "\n"
    "  // Position / Direction (based on emitter type)\n"
    "#ifdef POINTEMITTER\n"
    "  vec3 randoms2 = getRandomVec3(seed.y);\n"
    "  vec3 randoms3 = getRandomVec3(seed.z);\n"
    "\n"
    "  position = vec3(0, 0, 0);\n"
    "\n"
    "  direction = direction1 + (direction2 - direction1) * randoms3;\n"
    "#elif defined(BOXEMITTER)\n"
    "  vec3 randoms2 = getRandomVec3(seed.y);\n"
    "  vec3 randoms3 = getRandomVec3(seed.z);\n"
    "\n"
    "  position = minEmitBox + (maxEmitBox - minEmitBox) * randoms2;\n"
    "\n"
    "  direction = direction1 + (direction2 - direction1) * randoms3;  \n"
    "#elif defined(HEMISPHERICEMITTER)\n"
    "  vec3 randoms2 = getRandomVec3(seed.y);\n"
    "  vec3 randoms3 = getRandomVec3(seed.z);\n"
    "\n"
    "  // Position on the sphere surface\n"
    "  float phi = 2.0 * PI * randoms2.x;\n"
    "  float theta = acos(2.0 * randoms2.y - 1.0);\n"
    "  float randX = cos(phi) * sin(theta);\n"
    "  float randY = cos(theta);\n"
    "  float randZ = sin(phi) * sin(theta);\n"
    "\n"
    "  position = (radius - (radius * radiusRange * randoms2.z)) * vec3(randX, abs(randY), randZ);\n"
    "  direction = position + directionRandomizer * randoms3;  \n"
    "#elif defined(SPHEREEMITTER)\n"
    "  vec3 randoms2 = getRandomVec3(seed.y);\n"
    "  vec3 randoms3 = getRandomVec3(seed.z);\n"
    "\n"
    "  // Position on the sphere surface\n"
    "  float phi = 2.0 * PI * randoms2.x;\n"
    "  float theta = acos(2.0 * randoms2.y - 1.0);\n"
    "  float randX = cos(phi) * sin(theta);\n"
    "  float randY = cos(theta);\n"
    "  float randZ = sin(phi) * sin(theta);\n"
    "\n"
    "  position = (radius - (radius * radiusRange * randoms2.z)) * vec3(randX, randY, randZ);\n"
    "\n"
    "  #ifdef DIRECTEDSPHEREEMITTER\n"
    "  direction = direction1 + (direction2 - direction1) * randoms3;\n"
    "  #else\n"
    "  // Direction\n"
    "  direction = position + directionRandomizer * randoms3;\n"
    "  #endif\n"
    "#elif defined(CYLINDEREMITTER)\n"
    "  vec3 randoms2 = getRandomVec3(seed.y);\n"
    "  vec3 randoms3 = getRandomVec3(seed.z);\n"
    "\n"
    "  // Position on the cylinder\n"
    "  float yPos = (randoms2.x - 0.5)*height;\n"
    "  float angle = randoms2.y * PI * 2.;\n"
    "  float inverseRadiusRangeSquared = ((1.-radiusRange) * (1.-radiusRange));\n"
    "  float positionRadius = radius*sqrt(inverseRadiusRangeSquared + (randoms2.z * (1.-inverseRadiusRangeSquared)));\n"
    "  float xPos = positionRadius * cos(angle);\n"
    "  float zPos = positionRadius * sin(angle);\n"
    "  position = vec3(xPos, yPos, zPos);\n"
    "\n"
    "  // Direction\n"
    "  angle = angle + ((randoms3.x-0.5) * PI);\n"
    "  direction = vec3(cos(angle), randoms3.y-0.5, sin(angle));\n"
    "  direction = normalize(direction);\n"
    "#elif defined(CONEEMITTER)\n"
    "  vec3 randoms2 = getRandomVec3(seed.y);\n"
    "\n"
    "  float s = 2.0 * PI * randoms2.x;\n"
    "\n"
    "  #ifdef CONEEMITTERSPAWNPOINT\n"
    "  float h = 0.00001;\n"
    "  #else\n"
    "  float h = randoms2.y * height.y;\n"
    "  \n"
    "  // Better distribution in a cone at normal angles.\n"
    "  h = 1. - h * h;  \n"
    "  #endif\n"
    "\n"
    "  float lRadius = radius.x - radius.x * randoms2.z * radius.y;\n"
    "  lRadius = lRadius * h;\n"
    "\n"
    "  float randX = lRadius * sin(s);\n"
    "  float randZ = lRadius * cos(s);\n"
    "  float randY = h  * height.x;\n"
    "\n"
    "  position = vec3(randX, randY, randZ); \n"
    "\n"
    "  // Direction\n"
    "  if (abs(cos(coneAngle)) == 1.0) {\n"
    "  direction = vec3(0., 1.0, 0.);\n"
    "  } else {\n"
    "  vec3 randoms3 = getRandomVec3(seed.z);\n"
    "  direction = position + directionRandomizer * randoms3;\n"
    "  }\n"
    "#else    \n"
    "  // Create the particle at origin\n"
    "  position = vec3(0., 0., 0.);\n"
    "\n"
    "  // Spread in all directions\n"
    "  direction = 2.0 * (getRandomVec3(seed.w) - vec3(0.5, 0.5, 0.5));\n"
    "#endif\n"
    "\n"
    "  float power = emitPower.x + (emitPower.y - emitPower.x) * randoms.a;\n"
    "\n"
    "  outPosition = (emitterWM * vec4(position, 1.)).xyz;\n"
    "  vec3 initial = (emitterWM * vec4(normalize(direction), 0.)).xyz;\n"
    "  outDirection = initial * power;\n"
    "#ifndef BILLBOARD        \n"
    "  outInitialDirection = initial;\n"
    "#endif\n"
    "#ifdef ANIMATESHEET      \n"
    "  outCellIndex = cellInfos.x;\n"
    "#endif\n"
    "\n"
    "  } else {   \n"
    "  float directionScale = timeDelta;\n"
    "  outAge = newAge;\n"
    "  float ageGradient = newAge / life;\n"
    "\n"
    "#ifdef VELOCITYGRADIENTS\n"
    "  directionScale *= texture(velocityGradientSampler, vec2(ageGradient, 0)).r;\n"
    "#endif\n"
    "  outPosition = position + direction * directionScale;\n"
    "  \n"
    "  outLife = life;\n"
    "  outSeed = seed;\n"
    "#ifndef COLORGRADIENTS    \n"
    "  outColor = color;\n"
    "#endif\n"
    "\n"
    "#ifdef SIZEGRADIENTS\n"
    "  outSize.x = texture(sizeGradientSampler, vec2(ageGradient, 0)).r;\n"
    "  outSize.yz = size.yz;\n"
    "#else\n"
    "  outSize = size;\n"
    "#endif \n"
    "\n"
    "#ifndef BILLBOARD    \n"
    "  outInitialDirection = initialDirection;\n"
    "#endif\n"
    "  outDirection = direction + gravity * timeDelta;\n"
    "\n"
    "#ifdef NOISE\n"
    "  vec3 localPosition = outPosition - emitterWM[3].xyz;\n"
    "\n"
    "  float fetchedR = texture(noiseSampler, vec2(localPosition.y, localPosition.z) * vec2(0.5) + vec2(0.5)).r;\n"
    "  float fetchedG = texture(noiseSampler, vec2(localPosition.x + 0.33, localPosition.z + 0.33) * vec2(0.5) + vec2(0.5)).r;\n"
    "  float fetchedB = texture(noiseSampler, vec2(localPosition.z - 0.33, localPosition.y - 0.33) * vec2(0.5) + vec2(0.5)).r;\n"
    "\n"
    "  vec3 force = vec3(2. * fetchedR - 1., 2. * fetchedG - 1., 2. * fetchedB - 1.) * noiseStrength;\n"
    "\n"
    "  outDirection = outDirection + force * timeDelta;\n"
    "#endif    \n"
    "\n"
    "#ifdef ANGULARSPEEDGRADIENTS\n"
    "  float angularSpeed = texture(angularSpeedGradientSampler, vec2(ageGradient, 0)).r;\n"
    "  outAngle = angle + angularSpeed * timeDelta;\n"
    "#else\n"
    "  outAngle = vec2(angle.x + angle.y * timeDelta, angle.y);\n"
    "#endif\n"
    "\n"
    "#ifdef ANIMATESHEET      \n"
    "  float dist = cellInfos.y - cellInfos.x;\n"
    "  float ratio = clamp(mod(outAge * cellInfos.z, life) / life, 0., 1.0);\n"
    "\n"
    "  outCellIndex = float(int(cellInfos.x + ratio * dist));\n"
    "#endif\n"
    "  }\n"
    "}\n";

} // end of namespace BABYLON

#endif // end of BABYLON_SHADERS_GPU_UPDATE_PARTICLES_VERTEX_FX_H
