#ifndef BABYLON_SHADERS_PBR_FRAGMENT_FX_H
#define BABYLON_SHADERS_PBR_FRAGMENT_FX_H

namespace BABYLON {

extern const char* pbrPixelShader;

const char* pbrPixelShader
  = "#if defined(BUMP)|| !defined(NORMAL)\n"
    "#extension GL_OES_standard_derivatives : enable\n"
    "#endif\n"
    "\n"
    "#ifdef LODBASEDMICROSFURACE\n"
    "#extension GL_EXT_shader_texture_lod : enable\n"
    "#endif\n"
    "\n"
    "#ifdef LOGARITHMICDEPTH\n"
    "#extension GL_EXT_frag_depth : enable\n"
    "#endif\n"
    "\n"
    "#ifdef GL_ES\n"
    "precision highp float;\n"
    "#endif\n"
    "\n"
    "#include<__decl__pbrFragment>\n"
    "\n"
    "uniform vec3 vEyePosition;\n"
    "uniform vec3 vAmbientColor;\n"
    "uniform vec4 vCameraInfos;\n"
    "\n"
    "// Input\n"
    "varying vec3 vPositionW;\n"
    "\n"
    "#ifdef MAINUV1\n"
    "  varying vec2 vMainUV1;\n"
    "#endif \n"
    "\n"
    "#ifdef MAINUV2 \n"
    "  varying vec2 vMainUV2; \n"
    "#endif \n"
    "\n"
    "#ifdef NORMAL\n"
    "  varying vec3 vNormalW;\n"
    "  #if defined(USESPHERICALFROMREFLECTIONMAP) && !defined(USESPHERICALINFRAGMENT)\n"
    "  varying vec3 vEnvironmentIrradiance;\n"
    "  #endif\n"
    "#endif\n"
    "\n"
    "#ifdef VERTEXCOLOR\n"
    "varying vec4 vColor;\n"
    "#endif\n"
    "\n"
    "// Lights\n"
    "#include<__decl__lightFragment>[0..maxSimultaneousLights]\n"
    "\n"
    "// Samplers\n"
    "#ifdef ALBEDO\n"
    "  #if ALBEDODIRECTUV == 1\n"
    "  #define vAlbedoUV vMainUV1\n"
    "  #elif ALBEDODIRECTUV == 2\n"
    "  #define vAlbedoUV vMainUV2\n"
    "  #else\n"
    "  varying vec2 vAlbedoUV;\n"
    "  #endif\n"
    "  uniform sampler2D albedoSampler;\n"
    "#endif\n"
    "\n"
    "#ifdef AMBIENT\n"
    "  #if AMBIENTDIRECTUV == 1\n"
    "  #define vAmbientUV vMainUV1\n"
    "  #elif AMBIENTDIRECTUV == 2\n"
    "  #define vAmbientUV vMainUV2\n"
    "  #else\n"
    "  varying vec2 vAmbientUV;\n"
    "  #endif\n"
    "  uniform sampler2D ambientSampler;\n"
    "#endif\n"
    "\n"
    "#ifdef OPACITY\n"
    "  #if OPACITYDIRECTUV == 1\n"
    "  #define vOpacityUV vMainUV1\n"
    "  #elif OPACITYDIRECTUV == 2\n"
    "  #define vOpacityUV vMainUV2\n"
    "  #else\n"
    "  varying vec2 vOpacityUV;\n"
    "  #endif\n"
    "  uniform sampler2D opacitySampler;\n"
    "#endif\n"
    "\n"
    "#ifdef EMISSIVE\n"
    "  #if EMISSIVEDIRECTUV == 1\n"
    "  #define vEmissiveUV vMainUV1\n"
    "  #elif EMISSIVEDIRECTUV == 2\n"
    "  #define vEmissiveUV vMainUV2\n"
    "  #else\n"
    "  varying vec2 vEmissiveUV;\n"
    "  #endif\n"
    "  uniform sampler2D emissiveSampler;\n"
    "#endif\n"
    "\n"
    "#ifdef LIGHTMAP\n"
    "  #if LIGHTMAPDIRECTUV == 1\n"
    "  #define vLightmapUV vMainUV1\n"
    "  #elif LIGHTMAPDIRECTUV == 2\n"
    "  #define vLightmapUV vMainUV2\n"
    "  #else\n"
    "  varying vec2 vLightmapUV;\n"
    "  #endif\n"
    "  uniform sampler2D lightmapSampler;\n"
    "#endif\n"
    "\n"
    "#ifdef REFLECTIVITY\n"
    "  #if REFLECTIVITYDIRECTUV == 1\n"
    "  #define vReflectivityUV vMainUV1\n"
    "  #elif REFLECTIVITYDIRECTUV == 2\n"
    "  #define vReflectivityUV vMainUV2\n"
    "  #else\n"
    "  varying vec2 vReflectivityUV;\n"
    "  #endif\n"
    "  uniform sampler2D reflectivitySampler;\n"
    "#endif\n"
    "\n"
    "#ifdef MICROSURFACEMAP\n"
    "  #if MICROSURFACEMAPDIRECTUV == 1\n"
    "  #define vMicroSurfaceSamplerUV vMainUV1\n"
    "  #elif MICROSURFACEMAPDIRECTUV == 2\n"
    "  #define vMicroSurfaceSamplerUV vMainUV2\n"
    "  #else\n"
    "  varying vec2 vMicroSurfaceSamplerUV;\n"
    "  #endif\n"
    "  uniform sampler2D microSurfaceSampler;\n"
    "#endif\n"
    "\n"
    "// Refraction\n"
    "#ifdef REFRACTION\n"
    "  #ifdef REFRACTIONMAP_3D\n"
    "  #define sampleRefraction(s, c) textureCube(s, c)\n"
    "  \n"
    "  uniform samplerCube refractionSampler;\n"
    "\n"
    "  #ifdef LODBASEDMICROSFURACE\n"
    "  #define sampleRefractionLod(s, c, l) textureCubeLodEXT(s, c, l)\n"
    "  #else\n"
    "  uniform samplerCube refractionSamplerLow;\n"
    "  uniform samplerCube refractionSamplerHigh;\n"
    "  #endif\n"
    "  #else\n"
    "  #define sampleRefraction(s, c) texture2D(s, c)\n"
    "  \n"
    "  uniform sampler2D refractionSampler;\n"
    "\n"
    "  #ifdef LODBASEDMICROSFURACE\n"
    "  #define sampleRefractionLod(s, c, l) texture2DLodEXT(s, c, l)\n"
    "  #else\n"
    "  uniform samplerCube refractionSamplerLow;\n"
    "  uniform samplerCube refractionSamplerHigh;\n"
    "  #endif\n"
    "  #endif\n"
    "#endif\n"
    "\n"
    "// Reflection\n"
    "#ifdef REFLECTION\n"
    "  #ifdef REFLECTIONMAP_3D\n"
    "  #define sampleReflection(s, c) textureCube(s, c)\n"
    "\n"
    "  uniform samplerCube reflectionSampler;\n"
    "  \n"
    "  #ifdef LODBASEDMICROSFURACE\n"
    "  #define sampleReflectionLod(s, c, l) textureCubeLodEXT(s, c, l)\n"
    "  #else\n"
    "  uniform samplerCube reflectionSamplerLow;\n"
    "  uniform samplerCube reflectionSamplerHigh;\n"
    "  #endif\n"
    "  #else\n"
    "  #define sampleReflection(s, c) texture2D(s, c)\n"
    "\n"
    "  uniform sampler2D reflectionSampler;\n"
    "\n"
    "  #ifdef LODBASEDMICROSFURACE\n"
    "  #define sampleReflectionLod(s, c, l) texture2DLodEXT(s, c, l)\n"
    "  #else\n"
    "  uniform samplerCube reflectionSamplerLow;\n"
    "  uniform samplerCube reflectionSamplerHigh;\n"
    "  #endif\n"
    "  #endif\n"
    "\n"
    "  #ifdef REFLECTIONMAP_SKYBOX\n"
    "  varying vec3 vPositionUVW;\n"
    "  #else\n"
    "  #if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\n"
    "  varying vec3 vDirectionW;\n"
    "  #endif\n"
    "  #endif\n"
    "\n"
    "  #include<reflectionFunction>\n"
    "#endif\n"
    "\n"
    "#ifdef ENVIRONMENTBRDF\n"
    "  uniform sampler2D environmentBrdfSampler;\n"
    "#endif\n"
    "\n"
    "// Forces linear space for image processing\n"
    "#ifndef FROMLINEARSPACE\n"
    "  #define FROMLINEARSPACE;\n"
    "#endif\n"
    "\n"
    "#include<imageProcessingDeclaration>\n"
    "\n"
    "#include<helperFunctions>\n"
    "\n"
    "#include<imageProcessingFunctions>\n"
    "\n"
    "// PBR\n"
    "#include<shadowsFragmentFunctions>\n"
    "#include<pbrFunctions>\n"
    "#include<harmonicsFunctions>\n"
    "#include<pbrLightFunctions>\n"
    "\n"
    "#include<bumpFragmentFunctions>\n"
    "#include<clipPlaneFragmentDeclaration>\n"
    "#include<logDepthDeclaration>\n"
    "\n"
    "// Fog\n"
    "#include<fogFragmentDeclaration>\n"
    "\n"
    "void main(void) {\n"
    "#include<clipPlaneFragment>\n"
    "\n"
    "// _______________________________________________________________________________\n"
    "// _____________________________ Geometry Information ____________________________\n"
    "  vec3 viewDirectionW = normalize(vEyePosition - vPositionW);\n"
    "\n"
    "#ifdef NORMAL\n"
    "  vec3 normalW = normalize(vNormalW);\n"
    "#else\n"
    "  vec3 normalW = normalize(cross(dFdx(vPositionW), dFdy(vPositionW)));\n"
    "#endif\n"
    "\n"
    "#ifdef BUMP\n"
    "  vec3 originalNormalW = normalW;\n"
    "#endif\n"
    "\n"
    "#include<bumpFragment>\n"
    "\n"
    "#if defined(TWOSIDEDLIGHTING) && defined(NORMAL) \n"
    "  normalW = gl_FrontFacing ? normalW : -normalW;\n"
    "\n"
    "  #ifdef BUMP\n"
    "  originalNormalW = gl_FrontFacing ? originalNormalW : -originalNormalW;;\n"
    "  #endif\n"
    "#endif\n"
    "\n"
    "// _____________________________ Albedo Information ______________________________\n"
    "  // Albedo\n"
    "  vec3 surfaceAlbedo = vAlbedoColor.rgb;\n"
    "\n"
    "  // Alpha\n"
    "  float alpha = vAlbedoColor.a;\n"
    "\n"
    "#ifdef ALBEDO\n"
    "  vec4 albedoTexture = texture2D(albedoSampler, vAlbedoUV + uvOffset);\n"
    "  #if defined(ALPHAFROMALBEDO) || defined(ALPHATEST)\n"
    "  alpha *= albedoTexture.a;\n"
    "  #endif\n"
    "\n"
    "  surfaceAlbedo *= toLinearSpace(albedoTexture.rgb);\n"
    "  surfaceAlbedo *= vAlbedoInfos.y;\n"
    "#endif\n"
    "\n"
    "// _____________________________ Alpha Information _______________________________\n"
    "#ifdef OPACITY\n"
    "  vec4 opacityMap = texture2D(opacitySampler, vOpacityUV + uvOffset);\n"
    "\n"
    "  #ifdef OPACITYRGB\n"
    "  alpha = getLuminance(opacityMap.rgb);\n"
    "  #else\n"
    "  alpha *= opacityMap.a;\n"
    "  #endif\n"
    "\n"
    "  alpha *= vOpacityInfos.y;\n"
    "#endif\n"
    "\n"
    "#ifdef VERTEXALPHA\n"
    "  alpha *= vColor.a;\n"
    "#endif\n"
    "\n"
    "#if !defined(LINKREFRACTIONTOTRANSPARENCY) && !defined(ALPHAFRESNEL)\n"
    "  #ifdef ALPHATEST\n"
    "  if (alpha <= ALPHATESTVALUE)\n"
    "  discard;\n"
    "\n"
    "  #ifndef ALPHABLEND\n"
    "  // Prevent to blend with the canvas.\n"
    "  alpha = 1.0;\n"
    "  #endif\n"
    "  #endif\n"
    "#endif\n"
    "\n"
    "#ifdef VERTEXCOLOR\n"
    "  surfaceAlbedo *= vColor.rgb;\n"
    "#endif\n"
    "\n"
    "// _____________________________ AO    Information _______________________________\n"
    "  vec3 ambientOcclusionColor = vec3(1., 1., 1.);\n"
    "\n"
    "#ifdef AMBIENT\n"
    "  vec3 ambientOcclusionColorMap = texture2D(ambientSampler, vAmbientUV + uvOffset).rgb * vAmbientInfos.y;\n"
    "  #ifdef AMBIENTINGRAYSCALE\n"
    "  ambientOcclusionColorMap = vec3(ambientOcclusionColorMap.r, ambientOcclusionColorMap.r, ambientOcclusionColorMap.r);\n"
    "  #endif\n"
    "  ambientOcclusionColor = mix(ambientOcclusionColor, ambientOcclusionColorMap, vAmbientInfos.z);\n"
    "#endif\n"
    "\n"
    "// _____________________________ Reflectivity Info _______________________________\n"
    "  float microSurface = vReflectivityColor.a;\n"
    "  vec3 surfaceReflectivityColor = vReflectivityColor.rgb;\n"
    "\n"
    "#ifdef METALLICWORKFLOW\n"
    "  vec2 metallicRoughness = surfaceReflectivityColor.rg;\n"
    "\n"
    "  #ifdef REFLECTIVITY\n"
    "  vec4 surfaceMetallicColorMap = texture2D(reflectivitySampler, vReflectivityUV + uvOffset);\n"
    "\n"
    "  #ifdef AOSTOREINMETALMAPRED\n"
    "  vec3 aoStoreInMetalMap = vec3(surfaceMetallicColorMap.r, surfaceMetallicColorMap.r, surfaceMetallicColorMap.r);\n"
    "  ambientOcclusionColor = mix(ambientOcclusionColor, aoStoreInMetalMap, vReflectivityInfos.z);\n"
    "  #endif\n"
    "\n"
    "  #ifdef METALLNESSSTOREINMETALMAPBLUE\n"
    "  metallicRoughness.r *= surfaceMetallicColorMap.b;\n"
    "  #else\n"
    "  metallicRoughness.r *= surfaceMetallicColorMap.r;\n"
    "  #endif\n"
    "\n"
    "  #ifdef ROUGHNESSSTOREINMETALMAPALPHA\n"
    "  metallicRoughness.g *= surfaceMetallicColorMap.a;\n"
    "  #else\n"
    "  #ifdef ROUGHNESSSTOREINMETALMAPGREEN\n"
    "  metallicRoughness.g *= surfaceMetallicColorMap.g;\n"
    "  #endif\n"
    "  #endif\n"
    "  #endif\n"
    "\n"
    "  #ifdef MICROSURFACEMAP\n"
    "  vec4 microSurfaceTexel = texture2D(microSurfaceSampler, vMicroSurfaceSamplerUV + uvOffset) * vMicroSurfaceSamplerInfos.y;\n"
    "  metallicRoughness.g *= microSurfaceTexel.r;\n"
    "  #endif\n"
    "\n"
    "  // Compute microsurface form roughness.\n"
    "  microSurface = 1.0 - metallicRoughness.g;\n"
    "\n"
    "  // Diffuse is used as the base of the reflectivity.\n"
    "  vec3 baseColor = surfaceAlbedo;\n"
    "\n"
    "  // Default specular reflectance at normal incidence.\n"
    "  // 4% corresponds to index of refraction (IOR) of 1.50, approximately equal to glass.\n"
    "  const vec3 DefaultSpecularReflectanceDielectric = vec3(0.04, 0.04, 0.04);\n"
    "\n"
    "  // Compute the converted diffuse.\n"
    "  surfaceAlbedo = mix(baseColor.rgb * (1.0 - DefaultSpecularReflectanceDielectric.r), vec3(0., 0., 0.), metallicRoughness.r);\n"
    "\n"
    "  // Compute the converted reflectivity.\n"
    "  surfaceReflectivityColor = mix(DefaultSpecularReflectanceDielectric, baseColor, metallicRoughness.r);\n"
    "#else\n"
    "  #ifdef REFLECTIVITY\n"
    "  vec4 surfaceReflectivityColorMap = texture2D(reflectivitySampler, vReflectivityUV + uvOffset);\n"
    "  surfaceReflectivityColor *= toLinearSpace(surfaceReflectivityColorMap.rgb);\n"
    "  surfaceReflectivityColor *= vReflectivityInfos.y;\n"
    "\n"
    "  #ifdef MICROSURFACEFROMREFLECTIVITYMAP\n"
    "  microSurface *= surfaceReflectivityColorMap.a;\n"
    "  microSurface *= vReflectivityInfos.z;\n"
    "  #else\n"
    "  #ifdef MICROSURFACEAUTOMATIC\n"
    "  microSurface *= computeDefaultMicroSurface(microSurface, surfaceReflectivityColor);\n"
    "  #endif\n"
    "\n"
    "  #ifdef MICROSURFACEMAP\n"
    "  vec4 microSurfaceTexel = texture2D(microSurfaceSampler, vMicroSurfaceSamplerUV + uvOffset) * vMicroSurfaceSamplerInfos.y;\n"
    "  microSurface *= microSurfaceTexel.r;\n"
    "  #endif\n"
    "  #endif\n"
    "  #endif\n"
    "#endif\n"
    "\n"
    "  // Adapt microSurface.\n"
    "  microSurface = clamp(microSurface, 0., 1.);\n"
    "  // Compute roughness.\n"
    "  float roughness = 1. - microSurface;\n"
    "\n"
    "// _____________________________ Alpha Fresnel ___________________________________\n"
    "#ifdef ALPHAFRESNEL\n"
    "  // Convert approximate perceptual opacity (gamma-encoded opacity) to linear opacity (absorptance, or inverse transmission)\n"
    "  // for use with the linear HDR render target. The final composition will be converted back to gamma encoded values for eventual display.\n"
    "  // Uses power 2.0 rather than 2.2 for simplicity/efficiency, and because the mapping does not need to map the gamma applied to RGB.\n"
    "  float opacityPerceptual = alpha;\n"
    "  float opacity0 = opacityPerceptual * opacityPerceptual;\n"
    "  float opacity90 = fresnelGrazingReflectance(opacity0);\n"
    "\n"
    "  vec3 normalForward = faceforward(normalW, -viewDirectionW, normalW);\n"
    "\n"
    "  // Calculate the appropriate linear opacity for the current viewing angle (formally, this quantity is the \"directional absorptance\").\n"
    "  alpha = fresnelSchlickEnvironmentGGX(clamp(dot(V, normalForward), 0.0, 1.0), vec3(opacity0), vec3(opacity90), sqrt(microSurface)).x;\n"
    "  \n"
    "  #ifdef ALPHATEST\n"
    "  if (alpha <= ALPHATESTVALUE)\n"
    "  discard;\n"
    "\n"
    "  #ifndef ALPHABLEND\n"
    "  // Prevent to blend with the canvas.\n"
    "  alpha = 1.0;\n"
    "  #endif\n"
    "  #endif\n"
    "#endif\n"
    "\n"
    "// _____________________________ Compute LODs Fetch ____________________________________\n"
    "  // Compute N dot V.\n"
    "  float NdotVUnclamped = dot(normalW, viewDirectionW);\n"
    "  float NdotV = clamp(NdotVUnclamped,0., 1.) + 0.00001;\n"
    "  float alphaG = convertRoughnessToAverageSlope(roughness);\n"
    "\n"
    "// _____________________________ Refraction Info _______________________________________\n"
    "#ifdef REFRACTION\n"
    "  vec3 environmentRefraction = vec3(0., 0., 0.);\n"
    "  \n"
    "  vec3 refractionVector = refract(-viewDirectionW, normalW, vRefractionInfos.y);\n"
    "  #ifdef REFRACTIONMAP_OPPOSITEZ\n"
    "  refractionVector.z *= -1.0;\n"
    "  #endif\n"
    "\n"
    "  // _____________________________ 2D vs 3D Maps ________________________________\n"
    "  #ifdef REFRACTIONMAP_3D\n"
    "  refractionVector.y = refractionVector.y * vRefractionInfos.w;\n"
    "  vec3 refractionCoords = refractionVector;\n"
    "  refractionCoords = vec3(refractionMatrix * vec4(refractionCoords, 0));\n"
    "  #else\n"
    "  vec3 vRefractionUVW = vec3(refractionMatrix * (view * vec4(vPositionW + refractionVector * vRefractionInfos.z, 1.0)));\n"
    "  vec2 refractionCoords = vRefractionUVW.xy / vRefractionUVW.z;\n"
    "  refractionCoords.y = 1.0 - refractionCoords.y;\n"
    "  #endif\n"
    "\n"
    "  #ifdef LODINREFRACTIONALPHA\n"
    "  float refractionLOD = getLodFromAlphaG(vRefractionMicrosurfaceInfos.x, alphaG, NdotVUnclamped);\n"
    "  #else\n"
    "  float refractionLOD = getLodFromAlphaG(vRefractionMicrosurfaceInfos.x, alphaG, 1.0);\n"
    "  #endif\n"
    "  \n"
    "  #ifdef LODBASEDMICROSFURACE\n"
    "  // Apply environment convolution scale/offset filter tuning parameters to the mipmap LOD selection\n"
    "  refractionLOD = refractionLOD * vRefractionMicrosurfaceInfos.y + vRefractionMicrosurfaceInfos.z;\n"
    "\n"
    "  #ifdef LODINREFRACTIONALPHA\n"
    "  // Automatic LOD adjustment to ensure that the smoothness-based environment LOD selection \n"
    "  // is constrained to appropriate LOD levels in order to prevent aliasing.\n"
    "  // The environment map is first sampled without custom LOD selection to determine\n"
    "  // the hardware-selected LOD, and this is then used to constrain the final LOD selection\n"
    "  // so that excessive surface smoothness does not cause aliasing (e.g. on curved geometry \n"
    "  // where the normal is varying rapidly).\n"
    "\n"
    "  // Note: Shader Model 4.1 or higher can provide this directly via CalculateLevelOfDetail(), and\n"
    "  // manual calculation via derivatives is also possible, but for simplicity we use the \n"
    "  // hardware LOD calculation with the alpha channel containing the LOD for each mipmap.\n"
    "  float automaticRefractionLOD = UNPACK_LOD(sampleRefraction(refractionSampler, refractionCoords).a);\n"
    "  float requestedRefractionLOD = max(automaticRefractionLOD, refractionLOD);\n"
    "  #else\n"
    "  float requestedRefractionLOD = refractionLOD;\n"
    "  #endif\n"
    "\n"
    "  environmentRefraction = sampleRefractionLod(refractionSampler, refractionCoords, requestedRefractionLOD).rgb;\n"
    "  #else\n"
    "  float lodRefractionNormalized = clamp(refractionLOD / log2(vRefractionMicrosurfaceInfos.x), 0., 1.);\n"
    "  float lodRefractionNormalizedDoubled = lodRefractionNormalized * 2.0;\n"
    "\n"
    "  vec3 environmentRefractionMid = sampleRefraction(refractionSampler, refractionCoords).rgb;\n"
    "  if(lodRefractionNormalizedDoubled < 1.0){\n"
    "  environmentRefraction = mix(\n"
    "  sampleRefraction(refractionSamplerHigh, refractionCoords).rgb,\n"
    "  environmentRefractionMid,\n"
    "  lodRefractionNormalizedDoubled\n"
    "  );\n"
    "  }else{\n"
    "  environmentRefraction = mix(\n"
    "  environmentRefractionMid,\n"
    "  sampleRefraction(refractionSamplerLow, refractionCoords).rgb,\n"
    "  lodRefractionNormalizedDoubled - 1.0\n"
    "  );\n"
    "  }\n"
    "  #endif\n"
    "\n"
    "  #ifdef GAMMAREFRACTION\n"
    "  environmentRefraction = toLinearSpace(environmentRefraction.rgb);\n"
    "  #endif\n"
    "\n"
    "  // _____________________________ Levels _____________________________________\n"
    "  environmentRefraction *= vRefractionInfos.x;\n"
    "#endif\n"
    "\n"
    "// _____________________________ Reflection Info _______________________________________\n"
    "#ifdef REFLECTION\n"
    "  vec3 environmentRadiance = vec3(0., 0., 0.);\n"
    "  vec3 environmentIrradiance = vec3(0., 0., 0.);\n"
    "\n"
    "  vec3 reflectionVector = computeReflectionCoords(vec4(vPositionW, 1.0), normalW);\n"
    "  #ifdef REFLECTIONMAP_OPPOSITEZ\n"
    "  reflectionVector.z *= -1.0;\n"
    "  #endif\n"
    "\n"
    "  // _____________________________ 2D vs 3D Maps ________________________________\n"
    "  #ifdef REFLECTIONMAP_3D\n"
    "  vec3 reflectionCoords = reflectionVector;\n"
    "  #else\n"
    "  vec2 reflectionCoords = reflectionVector.xy;\n"
    "  #ifdef REFLECTIONMAP_PROJECTION\n"
    "  reflectionCoords /= reflectionVector.z;\n"
    "  #endif\n"
    "  reflectionCoords.y = 1.0 - reflectionCoords.y;\n"
    "  #endif\n"
    "  \n"
    "  #if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\n"
    "  float reflectionLOD = getLodFromAlphaG(vReflectionMicrosurfaceInfos.x, alphaG, NdotVUnclamped);\n"
    "  #else\n"
    "  float reflectionLOD = getLodFromAlphaG(vReflectionMicrosurfaceInfos.x, alphaG, 1.);\n"
    "  #endif\n"
    "\n"
    "  #ifdef LODBASEDMICROSFURACE\n"
    "  // Apply environment convolution scale/offset filter tuning parameters to the mipmap LOD selection\n"
    "  reflectionLOD = reflectionLOD * vReflectionMicrosurfaceInfos.y + vReflectionMicrosurfaceInfos.z;\n"
    "\n"
    "  #ifdef LODINREFLECTIONALPHA\n"
    "  // Automatic LOD adjustment to ensure that the smoothness-based environment LOD selection \n"
    "  // is constrained to appropriate LOD levels in order to prevent aliasing.\n"
    "  // The environment map is first sampled without custom LOD selection to determine\n"
    "  // the hardware-selected LOD, and this is then used to constrain the final LOD selection\n"
    "  // so that excessive surface smoothness does not cause aliasing (e.g. on curved geometry \n"
    "  // where the normal is varying rapidly).\n"
    "\n"
    "  // Note: Shader Model 4.1 or higher can provide this directly via CalculateLevelOfDetail(), and\n"
    "  // manual calculation via derivatives is also possible, but for simplicity we use the \n"
    "  // hardware LOD calculation with the alpha channel containing the LOD for each mipmap.\n"
    "  float automaticReflectionLOD = UNPACK_LOD(sampleReflection(reflectionSampler, reflectionCoords).a);\n"
    "  float requestedReflectionLOD = max(automaticReflectionLOD, reflectionLOD);\n"
    "  #else\n"
    "  float requestedReflectionLOD = reflectionLOD;\n"
    "  #endif\n"
    "\n"
    "  environmentRadiance = sampleReflectionLod(reflectionSampler, reflectionCoords, requestedReflectionLOD).rgb;\n"
    "  #else\n"
    "  float lodReflectionNormalized = clamp(reflectionLOD / log2(vReflectionMicrosurfaceInfos.x), 0., 1.);\n"
    "  float lodReflectionNormalizedDoubled = lodReflectionNormalized * 2.0;\n"
    "\n"
    "  vec3 environmentSpecularMid = sampleReflection(reflectionSampler, reflectionCoords).rgb;\n"
    "  if(lodReflectionNormalizedDoubled < 1.0){\n"
    "  environmentRadiance = mix(\n"
    "  sampleReflection(reflectionSamplerHigh, reflectionCoords).rgb,\n"
    "  environmentSpecularMid,\n"
    "  lodReflectionNormalizedDoubled\n"
    "  );\n"
    "  }else{\n"
    "  environmentRadiance = mix(\n"
    "  environmentSpecularMid,\n"
    "  sampleReflection(reflectionSamplerLow, reflectionCoords).rgb,\n"
    "  lodReflectionNormalizedDoubled - 1.0\n"
    "  );\n"
    "  }\n"
    "  #endif\n"
    "\n"
    "  #ifdef GAMMAREFLECTION\n"
    "  environmentRadiance = toLinearSpace(environmentRadiance.rgb);\n"
    "  #endif\n"
    "\n"
    "  // _____________________________ Irradiance ________________________________\n"
    "  #ifdef USESPHERICALFROMREFLECTIONMAP\n"
    "  #if defined(NORMAL) && !defined(USESPHERICALINFRAGMENT)\n"
    "  environmentIrradiance = vEnvironmentIrradiance;\n"
    "  #else\n"
    "  environmentIrradiance = environmentIrradianceJones(reflectionVector);\n"
    "  #endif\n"
    "  #endif\n"
    "\n"
    "  // _____________________________ Levels _____________________________________\n"
    "  environmentRadiance *= vReflectionInfos.x;\n"
    "  environmentRadiance *= vReflectionColor.rgb;\n"
    "  environmentIrradiance *= vReflectionColor.rgb;\n"
    "#endif\n"
    "\n"
    "// ____________________________________________________________________________________\n"
    "// _____________________________ Direct Lighting Param ________________________________\n"
    "  // Compute reflectance.\n"
    "  float reflectance = max(max(surfaceReflectivityColor.r, surfaceReflectivityColor.g), surfaceReflectivityColor.b);\n"
    "  float reflectance90 = fresnelGrazingReflectance(reflectance);\n"
    "  vec3 specularEnvironmentR0 = surfaceReflectivityColor.rgb;\n"
    "  vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n"
    "\n"
    "// _____________________________ Direct Lighting Info __________________________________\n"
    "  vec3 diffuseBase = vec3(0., 0., 0.);\n"
    "#ifdef SPECULARTERM\n"
    "  vec3 specularBase = vec3(0., 0., 0.);\n"
    "#endif\n"
    "\n"
    "#ifdef LIGHTMAP\n"
    "  vec3 lightmapColor = texture2D(lightmapSampler, vLightmapUV + uvOffset).rgb * vLightmapInfos.y;\n"
    "#endif\n"
    "\n"
    "  lightingInfo info;\n"
    "  float shadow = 1.; // 1 - shadowLevel\n"
    "  float NdotL = -1.;\n"
    "\n"
    "#include<lightFragment>[0..maxSimultaneousLights]\n"
    "\n"
    "// _________________________ Specular Environment Oclusion __________________________\n"
    "#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\n"
    "  // Indexed on cos(theta) and roughness\n"
    "  vec2 brdfSamplerUV = vec2(NdotV, roughness);\n"
    "  \n"
    "  // We can find the scale and offset to apply to the specular value.\n"
    "  vec4 environmentBrdf = texture2D(environmentBrdfSampler, brdfSamplerUV);\n"
    "\n"
    "  vec3 specularEnvironmentReflectance = specularEnvironmentR0 * environmentBrdf.x + environmentBrdf.y;\n"
    "\n"
    "  #ifdef AMBIENTINGRAYSCALE\n"
    "  float ambientMonochrome = ambientOcclusionColor.r;\n"
    "  #else\n"
    "  float ambientMonochrome = getLuminance(ambientOcclusionColor);\n"
    "  #endif\n"
    "\n"
    "  float seo = environmentRadianceOcclusion(ambientMonochrome, NdotVUnclamped);\n"
    "  specularEnvironmentReflectance *= seo;\n"
    "\n"
    "  #ifdef BUMP\n"
    "  #ifdef REFLECTIONMAP_3D\n"
    "  float eho = environmentHorizonOcclusion(reflectionCoords, normalW);\n"
    "  specularEnvironmentReflectance *= eho;\n"
    "  #endif\n"
    "  #endif\n"
    "#else\n"
    "  // Jones implementation of a well balanced fast analytical solution.\n"
    "  vec3 specularEnvironmentReflectance = fresnelSchlickEnvironmentGGX(NdotV, specularEnvironmentR0, specularEnvironmentR90, sqrt(microSurface));\n"
    "#endif\n"
    "\n"
    "// _____________________________ Refractance+Tint ________________________________\n"
    "#ifdef REFRACTION\n"
    "  vec3 refractance = vec3(0.0, 0.0, 0.0);\n"
    "  vec3 transmission = vec3(1.0, 1.0, 1.0);\n"
    "  #ifdef LINKREFRACTIONTOTRANSPARENCY\n"
    "  // Transmission based on alpha.\n"
    "  transmission *= (1.0 - alpha);\n"
    "\n"
    "  // Tint the material with albedo.\n"
    "  // TODO. PBR Tinting.\n"
    "  vec3 mixedAlbedo = surfaceAlbedo;\n"
    "  float maxChannel = max(max(mixedAlbedo.r, mixedAlbedo.g), mixedAlbedo.b);\n"
    "  vec3 tint = clamp(maxChannel * mixedAlbedo, 0.0, 1.0);\n"
    "\n"
    "  // Decrease Albedo Contribution\n"
    "  surfaceAlbedo *= alpha;\n"
    "\n"
    "  // Decrease irradiance Contribution\n"
    "  environmentIrradiance *= alpha;\n"
    "\n"
    "  // Tint reflectance\n"
    "  environmentRefraction *= tint;\n"
    "\n"
    "  // Put alpha back to 1;\n"
    "  alpha = 1.0;\n"
    "  #endif\n"
    "\n"
    "  // Add Multiple internal bounces.\n"
    "  vec3 bounceSpecularEnvironmentReflectance = (2.0 * specularEnvironmentReflectance) / (1.0 + specularEnvironmentReflectance);\n"
    "  specularEnvironmentReflectance = mix(bounceSpecularEnvironmentReflectance, specularEnvironmentReflectance, alpha);\n"
    "\n"
    "  // In theory T = 1 - R.\n"
    "  transmission *= 1.0 - specularEnvironmentReflectance;\n"
    "\n"
    "  // Should baked in diffuse.\n"
    "  refractance = transmission;\n"
    "#endif\n"
    "\n"
    "// ______________________________________________________________________________\n"
    "// _____________________________ Energy Conservation  ___________________________\n"
    "  // Apply Energy Conservation taking in account the environment level only if \n"
    "  // the environment is present.\n"
    "  surfaceAlbedo.rgb = (1. - reflectance) * surfaceAlbedo.rgb;\n"
    "\n"
    "// _____________________________ Diffuse ________________________________________\n"
    "  vec3 finalDiffuse = diffuseBase;\n"
    "  finalDiffuse.rgb += vAmbientColor;\n"
    "  finalDiffuse *= surfaceAlbedo.rgb;\n"
    "  finalDiffuse = max(finalDiffuse, 0.0);\n"
    "\n"
    "// _____________________________ Irradiance ______________________________________\n"
    "#ifdef REFLECTION\n"
    "  vec3 finalIrradiance = environmentIrradiance;\n"
    "  finalIrradiance *= surfaceAlbedo.rgb;\n"
    "#endif\n"
    "\n"
    "// _____________________________ Specular ________________________________________\n"
    "#ifdef SPECULARTERM\n"
    "  vec3 finalSpecular = specularBase;\n"
    "  finalSpecular *= surfaceReflectivityColor;\n"
    "  finalSpecular = max(finalSpecular, 0.0);\n"
    "#endif\n"
    "\n"
    "// _____________________________ Radiance_________________________________________\n"
    "#ifdef REFLECTION\n"
    "  vec3 finalRadiance = environmentRadiance;\n"
    "  finalRadiance *= specularEnvironmentReflectance;\n"
    "#endif\n"
    "\n"
    "// _____________________________ Refraction ______________________________________\n"
    "#ifdef REFRACTION\n"
    "  vec3 finalRefraction = environmentRefraction;\n"
    "  finalRefraction *= refractance;\n"
    "#endif\n"
    "\n"
    "// _____________________________ Emissive ________________________________________\n"
    "  vec3 finalEmissive = vEmissiveColor;\n"
    "#ifdef EMISSIVE\n"
    "  vec3 emissiveColorTex = texture2D(emissiveSampler, vEmissiveUV + uvOffset).rgb;\n"
    "  finalEmissive *= toLinearSpace(emissiveColorTex.rgb);\n"
    "  finalEmissive *=  vEmissiveInfos.y;\n"
    "#endif\n"
    "\n"
    "// _____________________________ Highlights on Alpha _____________________________\n"
    "#ifdef ALPHABLEND\n"
    "  float luminanceOverAlpha = 0.0;\n"
    "  #if  defined(REFLECTION) && defined(RADIANCEOVERALPHA)\n"
    "  luminanceOverAlpha += getLuminance(environmentRadiance);\n"
    "  #endif\n"
    "\n"
    "  #if defined(SPECULARTERM) && defined(SPECULAROVERALPHA)\n"
    "  luminanceOverAlpha += getLuminance(finalSpecular);\n"
    "  #endif\n"
    "\n"
    "  #if defined(RADIANCEOVERALPHA) || defined(SPECULAROVERALPHA)\n"
    "  alpha = clamp(alpha + luminanceOverAlpha * alpha, 0., 1.);\n"
    "  #endif\n"
    "#endif\n"
    "\n"
    "// _______________________________________________________________________________\n"
    "// _____________________________ Composition _____________________________________\n"
    "  // Reflection already includes the environment intensity.\n"
    "  vec4 finalColor = vec4(finalDiffuse      * ambientOcclusionColor * vLightingIntensity.x +\n"
    "#ifdef REFLECTION\n"
    "  finalIrradiance  * ambientOcclusionColor * vLightingIntensity.z +\n"
    "#endif\n"
    "#ifdef SPECULARTERM\n"
    "  finalSpecular  * vLightingIntensity.x * vLightingIntensity.w +\n"
    "#endif\n"
    "#ifdef REFLECTION\n"
    "  finalRadiance  * vLightingIntensity.z +\n"
    "#endif\n"
    "#ifdef REFRACTION\n"
    "  finalRefraction  * vLightingIntensity.z +\n"
    "#endif\n"
    "  finalEmissive  * vLightingIntensity.y,\n"
    "  alpha);\n"
    "\n"
    "// _____________________________ LightMappping _____________________________________\n"
    "#ifdef LIGHTMAP\n"
    "  #ifndef LIGHTMAPEXCLUDED\n"
    "  #ifdef USELIGHTMAPASSHADOWMAP\n"
    "  finalColor.rgb *= lightmapColor;\n"
    "  #else\n"
    "  finalColor.rgb += lightmapColor;\n"
    "  #endif\n"
    "  #endif\n"
    "#endif\n"
    "\n"
    "// _____________________________ Finally ___________________________________________\n"
    "  finalColor = max(finalColor, 0.0);\n"
    "\n"
    "#include<logDepthFragment>\n"
    "#include<fogFragment>(color, finalColor)\n"
    "\n"
    "#ifdef IMAGEPROCESSINGPOSTPROCESS\n"
    "  // Sanitize output incase invalid normals or tangents have caused div by 0 or undefined behavior\n"
    "  // this also limits the brightness which helpfully reduces over-sparkling in bloom (native handles this in the bloom blur shader)\n"
    "  finalColor.rgb = clamp(finalColor.rgb, 0., 30.0);\n"
    "#else\n"
    "  // Alway run even to ensure going back to gamma space.\n"
    "  finalColor = applyImageProcessing(finalColor);\n"
    "#endif\n"
    "\n"
    "#ifdef PREMULTIPLYALPHA\n"
    "  // Convert to associative (premultiplied) format if needed.\n"
    "  finalColor.rgb *= result.a;\n"
    "#endif\n"
    "\n"
    "  gl_FragColor = finalColor;\n"
    "\n"
    "  // Normal Display.\n"
    "  //gl_FragColor = vec4(normalW * 0.5 + 0.5, 1.0);\n"
    "\n"
    "  // Ambient reflection color.\n"
    "  // gl_FragColor = vec4(ambientReflectionColor, 1.0);\n"
    "\n"
    "  // Reflection color.\n"
    "  // gl_FragColor = vec4(reflectionColor, 1.0);\n"
    "\n"
    "  // Base color.\n"
    "  // gl_FragColor = vec4(surfaceAlbedo.rgb, 1.0);\n"
    "\n"
    "  // Diffuse Direct Lighting\n"
    "  // gl_FragColor = vec4(diffuseBase.rgb, 1.0);\n"
    "\n"
    "  // Specular Lighting\n"
    "  // gl_FragColor = vec4(specularBase.rgb, 1.0);\n"
    "\n"
    "  // Final Specular\n"
    "  // gl_FragColor = vec4(finalSpecular.rgb, 1.0);\n"
    "\n"
    "  // Irradiance\n"
    "  //gl_FragColor = vec4(environmentIrradiance.rgb, 1.0);\n"
    "  //gl_FragColor = vec4(environmentIrradiance.rgb / 3.0, 1.0);\n"
    "\n"
    "  // Specular color.\n"
    "  // gl_FragColor = vec4(surfaceReflectivityColor.rgb, 1.0);\n"
    "\n"
    "  // MicroSurface color.\n"
    "  // gl_FragColor = vec4(microSurface, microSurface, microSurface, 1.0);\n"
    "\n"
    "  // Roughness.\n"
    "  // gl_FragColor = vec4(roughness, roughness, roughness, 1.0);\n"
    "\n"
    "  // Specular Map\n"
    "  // gl_FragColor = vec4(reflectivityMapColor.rgb, 1.0);\n"
    "\n"
    "  // Refractance\n"
    "  // gl_FragColor = vec4(refractance.rgb, 1.0);\n"
    "\n"
    "  //// Emissive Color\n"
    "  //vec2 test = vEmissiveUV * 0.5 + 0.5;\n"
    "  //gl_FragColor = vec4(test.x, test.y, 1.0, 1.0);\n"
    "\n"
    "  // Specular Environment Occlusion\n"
    "  //gl_FragColor = vec4(seo, seo, seo, 1.0);\n"
    "\n"
    "  //// Horizon Environment Occlusion\n"
    "  //gl_FragColor = vec4(eho, eho, eho, 1.0);\n"
    "\n"
    "  //gl_FragColor = vec4(seo * eho, seo * eho, seo * eho, 1.0);\n"
    "}\n";

} // end of namespace BABYLON

#endif // end of BABYLON_SHADERS_PBR_FRAGMENT_FX_H
