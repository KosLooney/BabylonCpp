#ifndef BABYLON_SHADERS_STANDARD_FRAGMENT_FX_H
#define BABYLON_SHADERS_STANDARD_FRAGMENT_FX_H

namespace BABYLON {

extern const char* standardPixelShader;

const char* standardPixelShader
  = "uniform sampler2D textureSampler;\n"
    "varying vec2 vUV;\n"
    "\n"
    "#if defined(PASS_POST_PROCESS)\n"
    "void main(void)\n"
    "{\n"
    "  vec4 color = texture2D(textureSampler, vUV);\n"
    "  gl_FragColor = color;\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(DOWN_SAMPLE_X4)\n"
    "uniform vec2 dsOffsets[16];\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "  vec4 average = vec4(0.0, 0.0, 0.0, 0.0);\n"
    "\n"
    "  average = texture2D(textureSampler, vUV + dsOffsets[0]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[1]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[2]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[3]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[4]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[5]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[6]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[7]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[8]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[9]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[10]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[11]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[12]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[13]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[14]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[15]);\n"
    "\n"
    "  average /= 16.0;\n"
    "\n"
    "  gl_FragColor = average;\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(BRIGHT_PASS)\n"
    "uniform vec2 dsOffsets[4];\n"
    "uniform float brightThreshold;\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "  vec4 average = vec4(0.0, 0.0, 0.0, 0.0);\n"
    "\n"
    "  average = texture2D(textureSampler, vUV + vec2(dsOffsets[0].x, dsOffsets[0].y));\n"
    "  average += texture2D(textureSampler, vUV + vec2(dsOffsets[1].x, dsOffsets[1].y));\n"
    "  average += texture2D(textureSampler, vUV + vec2(dsOffsets[2].x, dsOffsets[2].y));\n"
    "  average += texture2D(textureSampler, vUV + vec2(dsOffsets[3].x, dsOffsets[3].y));\n"
    "\n"
    "  average *= 0.25;\n"
    "\n"
    "  float luminance = length(average.rgb);\n"
    "\n"
    "  if (luminance < brightThreshold) {\n"
    "  average = vec4(0.0, 0.0, 0.0, 1.0);\n"
    "  }\n"
    "\n"
    "  gl_FragColor = average;\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(TEXTURE_ADDER)\n"
    "uniform sampler2D otherSampler;\n"
    "uniform sampler2D lensSampler;\n"
    "\n"
    "uniform float exposure;\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "  vec3 colour = texture2D(textureSampler, vUV).rgb;\n"
    "\n"
    "  colour *= exposure;\n"
    "\n"
    "  vec3 X = max(vec3(0.0, 0.0, 0.0), colour - 0.004);\n"
    "  vec3 retColor = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);\n"
    "\n"
    "  colour = retColor * retColor;\n"
    "  colour += colour * texture2D(lensSampler, vUV).rgb;\n"
    "\n"
    "  vec4 finalColor = vec4(colour.rgb, 1.0) + texture2D(otherSampler, vUV);\n"
    "\n"
    "  gl_FragColor = finalColor;\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(VLS)\n"
    "#define PI 3.1415926535897932384626433832795\n"
    "\n"
    "uniform mat4 shadowViewProjection;\n"
    "uniform mat4 lightWorld;\n"
    "\n"
    "uniform vec3 cameraPosition;\n"
    "uniform vec3 sunDirection;\n"
    "uniform vec3 sunColor;\n"
    "\n"
    "uniform vec2 depthValues;\n"
    "\n"
    "uniform float scatteringCoefficient;\n"
    "uniform float scatteringPower;\n"
    "\n"
    "uniform sampler2D shadowMapSampler;\n"
    "uniform sampler2D positionSampler;\n"
    "\n"
    "float computeScattering(float lightDotView)\n"
    "{\n"
    "  float result = 1.0 - scatteringCoefficient * scatteringCoefficient;\n"
    "  result /= (4.0 * PI * pow(1.0 + scatteringCoefficient * scatteringCoefficient - (2.0 * scatteringCoefficient) * lightDotView, 1.5));\n"
    "  return result;\n"
    "}\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "  // Compute\n"
    "  vec3 worldPos = texture2D(positionSampler, vUV).rgb;\n"
    "  vec3 startPosition = cameraPosition;\n"
    "\n"
    "  vec3 rayVector = worldPos - startPosition;\n"
    "\n"
    "  float rayLength = length(rayVector);\n"
    "  vec3 rayDirection = rayVector / rayLength;\n"
    "\n"
    "  float stepLength = rayLength / NB_STEPS;\n"
    "  vec3 stepL = rayDirection * stepLength;\n"
    "  vec3 currentPosition = startPosition;\n"
    "  vec3 accumFog = vec3(0.0);\n"
    "\n"
    "  for (int i = 0; i < int(NB_STEPS); i++)\n"
    "  {\n"
    "  vec4 worldInShadowCameraSpace = shadowViewProjection * vec4(currentPosition, 1.0);\n"
    "  float depthMetric =  (worldInShadowCameraSpace.z + depthValues.x) / (depthValues.y);\n"
    "  float shadowPixelDepth = clamp(depthMetric, 0.0, 1.0);\n"
    "\n"
    "  worldInShadowCameraSpace.xyz /= worldInShadowCameraSpace.w;\n"
    "  worldInShadowCameraSpace.xyz = 0.5 * worldInShadowCameraSpace.xyz + vec3(0.5);\n"
    "\n"
    "  float shadowMapValue = texture2D(shadowMapSampler, worldInShadowCameraSpace.xy).r;\n"
    "  \n"
    "  if (shadowMapValue > shadowPixelDepth)\n"
    "  accumFog += sunColor * computeScattering(dot(rayDirection, sunDirection));\n"
    "  \n"
    "  currentPosition += stepL;\n"
    "  }\n"
    "\n"
    "  accumFog /= NB_STEPS;\n"
    "\n"
    "  vec3 color = accumFog * scatteringPower;\n"
    "  gl_FragColor = vec4(color * exp(color) , 1.0);\n"
    "}\n"
    "\n"
    "#endif\n"
    "\n"
    "#if defined(VLSMERGE)\n"
    "uniform sampler2D originalSampler;\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "  gl_FragColor = texture2D(originalSampler, vUV) + texture2D(textureSampler, vUV);\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(LUMINANCE)\n"
    "uniform vec2 lumOffsets[4];\n"
    "\n"
    "void main()\n"
    "{\n"
    "  float average = 0.0;\n"
    "  vec4 color = vec4(0.0);\n"
    "  float maximum = -1e20;\n"
    "  vec3 weight = vec3(0.299, 0.587, 0.114);\n"
    "\n"
    "  for (int i = 0; i < 4; i++)\n"
    "  {\n"
    "  color = texture2D(textureSampler, vUV+ lumOffsets[i]);\n"
    "\n"
    "  //#ifdef SIMPLE\n"
    "  float GreyValue = dot(color.rgb, vec3(0.33, 0.33, 0.33));\n"
    "  //#endif\n"
    "\n"
    "  #ifdef WEIGHTED_AVERAGE\n"
    "  float GreyValue = dot(color.rgb, weight);\n"
    "  #endif\n"
    "\n"
    "  #ifdef BRIGHTNESS\n"
    "  float GreyValue = max(color.r, max(color.g, color.b));\n"
    "  #endif\n"
    "\n"
    "  #ifdef HSL_COMPONENT\n"
    "  float GreyValue = 0.5 * (max(color.r, max(color.g, color.b)) + min(color.r, min(color.g, color.b)));\n"
    "  #endif\n"
    "\n"
    "  #ifdef MAGNITUDE\n"
    "  float GreyValue = length(color.rgb);\n"
    "  #endif\n"
    "\n"
    "  maximum = max(maximum, GreyValue);\n"
    "  average += (0.25 * log(1e-5 + GreyValue));\n"
    "  }\n"
    "\n"
    "  average = exp(average);\n"
    "\n"
    "  gl_FragColor = vec4(average, maximum, 0.0, 1.0);\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(LUMINANCE_DOWN_SAMPLE)\n"
    "uniform vec2 dsOffsets[9];\n"
    "uniform float halfDestPixelSize;\n"
    "\n"
    "#ifdef FINAL_DOWN_SAMPLER\n"
    "vec4 pack(float value) {\n"
    "  const vec4 bit_shift = vec4(255.0 * 255.0 * 255.0, 255.0 * 255.0, 255.0, 1.0);\n"
    "  const vec4 bit_mask = vec4(0.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n"
    "\n"
    "  vec4 res = fract(value * bit_shift);\n"
    "  res -= res.xxyz * bit_mask;\n"
    "\n"
    "  return res;\n"
    "}\n"
    "#endif\n"
    "\n"
    "void main()\n"
    "{\n"
    "  vec4 color = vec4(0.0);\n"
    "  float average = 0.0;\n"
    "\n"
    "  for (int i = 0; i < 9; i++)\n"
    "  {\n"
    "  color = texture2D(textureSampler, vUV + vec2(halfDestPixelSize, halfDestPixelSize) + dsOffsets[i]);\n"
    "  average += color.r;\n"
    "  }\n"
    "\n"
    "  average /= 9.0;\n"
    "\n"
    "  #ifdef FINAL_DOWN_SAMPLER\n"
    "  gl_FragColor = pack(average);\n"
    "  #else\n"
    "  gl_FragColor = vec4(average, average, 0.0, 1.0);\n"
    "  #endif\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(HDR)\n"
    "uniform sampler2D textureAdderSampler;\n"
    "uniform float averageLuminance;\n"
    "\n"
    "void main()\n"
    "{\n"
    "  vec4 color = texture2D(textureAdderSampler, vUV);\n"
    "  vec4 adjustedColor = color / averageLuminance;\n"
    "\n"
    "  color = adjustedColor;\n"
    "  color.a = 1.0;\n"
    "\n"
    "  gl_FragColor = color;\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(LENS_FLARE)\n"
    "#define GHOSTS 3\n"
    "\n"
    "uniform sampler2D lensColorSampler;\n"
    "\n"
    "uniform float strength;\n"
    "uniform float ghostDispersal;\n"
    "uniform float haloWidth;\n"
    "\n"
    "uniform vec2 resolution;\n"
    "uniform float distortionStrength;\n"
    "\n"
    "float hash(vec2 p)\n"
    "{\n"
    "  float h = dot(p, vec2(127.1, 311.7));\n"
    "  return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n"
    "}\n"
    "\n"
    "float noise(in vec2 p)\n"
    "{\n"
    "  vec2 i = floor(p);\n"
    "  vec2 f = fract(p);\n"
    "  vec2 u = f*f*(3.0 - 2.0*f);\n"
    "\n"
    "  return mix(mix(hash(i + vec2(0.0, 0.0)),\n"
    "  hash(i + vec2(1.0, 0.0)), u.x),\n"
    "  mix(hash(i + vec2(0.0, 1.0)),\n"
    "  hash(i + vec2(1.0, 1.0)), u.x), u.y);\n"
    "}\n"
    "\n"
    "float fbm(vec2 p)\n"
    "{\n"
    "  float f = 0.0;\n"
    "  f += 0.5000 * noise(p); p *= 2.02;\n"
    "  f += 0.2500 * noise(p); p *= 2.03;\n"
    "  f += 0.1250 * noise(p); p *= 2.01;\n"
    "  f += 0.0625 * noise(p); p *= 2.04;\n"
    "  f /= 0.9375;\n"
    "  return f;\n"
    "}\n"
    "\n"
    "vec3 pattern(vec2 uv)\n"
    "{\n"
    "  vec2 p = -1.0 + 2.0 * uv;\n"
    "  float p2 = dot(p, p);\n"
    "  float f = fbm(vec2(15.0*p2)) / 2.0;\n"
    "  float r = 0.2 + 0.6 * sin(12.5*length(uv - vec2(0.5)));\n"
    "  float g = 0.2 + 0.6 * sin(20.5*length(uv - vec2(0.5)));\n"
    "  float b = 0.2 + 0.6 * sin(17.2*length(uv - vec2(0.5)));\n"
    "  return (1.0 - f) * vec3(r, g, b);\n"
    "}\n"
    "\n"
    "float luminance(vec3 color)\n"
    "{\n"
    "  return dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\n"
    "}\n"
    "\n"
    "vec4 textureDistorted(sampler2D tex, vec2 texcoord, vec2 direction, vec3 distortion)\n"
    "{\n"
    "  return vec4(\n"
    "  texture2D(tex, texcoord + direction * distortion.r).r,\n"
    "  texture2D(tex, texcoord + direction * distortion.g).g,\n"
    "  texture2D(tex, texcoord + direction * distortion.b).b,\n"
    "  1.0\n"
    "  );\n"
    "}\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "  vec2 uv = -vUV + vec2(1.0);\n"
    "  vec2 ghostDir = (vec2(0.5) - uv) * ghostDispersal;\n"
    "\n"
    "  vec2 texelSize = 1.0 / resolution;\n"
    "  vec3 distortion = vec3(-texelSize.x * distortionStrength, 0.0, texelSize.x * distortionStrength);\n"
    "\n"
    "  vec4 result = vec4(0.0);\n"
    "  float ghostIndice = 1.0;\n"
    "\n"
    "  for (int i = 0; i < GHOSTS; ++i)\n"
    "  {\n"
    "  vec2 offset = fract(uv + ghostDir * ghostIndice);\n"
    "  float weight = length(vec2(0.5) - offset) / length(vec2(0.5));\n"
    "  weight = pow(1.0 - weight, 10.0);\n"
    "\n"
    "  result += textureDistorted(textureSampler, offset, normalize(ghostDir), distortion) * weight * strength;\n"
    "\n"
    "  ghostIndice += 1.0;\n"
    "  }\n"
    "\n"
    "  vec2 haloVec = normalize(ghostDir) * haloWidth;\n"
    "\n"
    "  float weight = length(vec2(0.5) - fract(uv + haloVec)) / length(vec2(0.5));\n"
    "  weight = pow(1.0 - weight, 10.0);\n"
    "\n"
    "  result += textureDistorted(textureSampler, fract(uv + haloVec), normalize(ghostDir), distortion) * weight * strength;\n"
    "\n"
    "  result *= texture2D(lensColorSampler, vec2(length(vec2(0.5) - uv) / length(vec2(0.5))));\n"
    "\n"
    "  gl_FragColor = result;\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(LENS_FLARE_COMPOSE)\n"
    "uniform sampler2D otherSampler;\n"
    "uniform sampler2D lensDirtSampler;\n"
    "uniform sampler2D lensStarSampler;\n"
    "\n"
    "uniform mat4 lensStarMatrix;\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "  vec2 lensFlareCoords = (lensStarMatrix * vec4(vUV, 1.0, 1.0)).xy;\n"
    "\n"
    "  vec4 lensMod = texture2D(lensDirtSampler, vUV);\n"
    "  lensMod += texture2D(lensStarSampler, vUV/*lensFlareCoords*/);\n"
    "\n"
    "  vec4 result = texture2D(textureSampler, vUV) * lensMod;\n"
    "\n"
    "  gl_FragColor = texture2D(otherSampler, vUV) + result;\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(DEPTH_OF_FIELD)\n"
    "uniform sampler2D otherSampler;\n"
    "uniform sampler2D depthSampler;\n"
    "\n"
    "uniform float distance;\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "  vec4 sharp = texture2D(otherSampler, vUV);\n"
    "  vec4 blur = texture2D(textureSampler, vUV);\n"
    "  float dist = clamp(texture2D(depthSampler, vUV).r * distance, 0.0, 1.0);\n"
    "  float factor = 0.0;\n"
    "\n"
    "  if (dist < 0.05)\n"
    "  factor = 1.0;\n"
    "  else if (dist < 0.1)\n"
    "  factor = 20.0 * (0.1 - dist);\n"
    "  else if (dist < 0.5)\n"
    "  factor = 0.0;\n"
    "  else\n"
    "  factor = 2.0 * (dist - 0.5);\n"
    "\n"
    "  factor = clamp(factor, 0.0, 0.90);\n"
    "  gl_FragColor = mix(sharp, blur, factor);\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(MOTION_BLUR)\n"
    "uniform mat4 inverseViewProjection;\n"
    "uniform mat4 prevViewProjection;\n"
    "\n"
    "uniform vec2 screenSize;\n"
    "\n"
    "uniform float motionScale;\n"
    "uniform float motionStrength;\n"
    "\n"
    "uniform sampler2D depthSampler;\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "  vec2 texelSize = 1.0 / screenSize;\n"
    "  float depth = texture2D(depthSampler, vUV).r;\n"
    "\n"
    "  vec4 cpos = vec4(vUV * 2.0 - 1.0, depth, 1.0);\n"
    "  cpos = cpos * inverseViewProjection;\n"
    "\n"
    "  vec4 ppos = cpos * prevViewProjection;\n"
    "  ppos.xyz /= ppos.w;\n"
    "  ppos.xy = ppos.xy * 0.5 + 0.5;\n"
    "\n"
    "  vec2 velocity = (ppos.xy - vUV) * motionScale * motionStrength;\n"
    "  float speed = length(velocity / texelSize);\n"
    "  int nSamples = int(clamp(speed, 1.0, MAX_MOTION_SAMPLES));\n"
    "\n"
    "  vec4 result = texture2D(textureSampler, vUV);\n"
    "\n"
    "  for (int i = 1; i < int(MAX_MOTION_SAMPLES); ++i) {\n"
    "  if (i >= nSamples)\n"
    "  break;\n"
    "  \n"
    "  vec2 offset1 = vUV + velocity * (float(i) / float(nSamples - 1) - 0.5);\n"
    "  result += texture2D(textureSampler, offset1);\n"
    "  }\n"
    "\n"
    "  gl_FragColor = result / float(nSamples);\n"
    "}\n"
    "#endif\n";

} // end of namespace BABYLON

#endif // end of BABYLON_SHADERS_STANDARD_FRAGMENT_FX_H
