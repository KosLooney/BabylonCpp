#ifndef BABYLON_SHADERS_SHADERS_INCLUDE_PBR_LIGHT_FUNCTIONS_FX_H
#define BABYLON_SHADERS_SHADERS_INCLUDE_PBR_LIGHT_FUNCTIONS_FX_H

namespace BABYLON {

extern const char* pbrLightFunctions;

const char* pbrLightFunctions
  = "// Light Computing\n"
    "struct lightingInfo\n"
    "{\n"
    "  vec3 diffuse;\n"
    "  #ifdef SPECULARTERM\n"
    "  vec3 specular;\n"
    "  #endif\n"
    "};\n"
    "\n"
    "struct pointLightingInfo\n"
    "{\n"
    "  vec3 lightOffset;\n"
    "  float lightDistanceSquared;\n"
    "\n"
    "  float attenuation;\n"
    "};\n"
    "\n"
    "struct spotLightingInfo\n"
    "{\n"
    "  vec3 lightOffset;\n"
    "  float lightDistanceSquared;\n"
    "  vec3 directionToLightCenterW;\n"
    "\n"
    "  float attenuation;\n"
    "};\n"
    "\n"
    "float computeDistanceLightFalloff_Standard(vec3 lightOffset, float range)\n"
    "{\n"
    "  return max(0., 1.0 - length(lightOffset) / range);\n"
    "}\n"
    "\n"
    "float computeDistanceLightFalloff_Physical(float lightDistanceSquared)\n"
    "{\n"
    "  return 1.0 / ((lightDistanceSquared + 0.001));\n"
    "}\n"
    "\n"
    "float computeDistanceLightFalloff_GLTF(float lightDistanceSquared, float inverseSquaredRange)\n"
    "{\n"
    "  const float minDistanceSquared = 0.01*0.01;\n"
    "  float lightDistanceFalloff = 1.0 / (max(lightDistanceSquared, minDistanceSquared));\n"
    "\n"
    "  float factor = lightDistanceSquared * inverseSquaredRange;\n"
    "  float attenuation = clamp(1.0 - factor * factor, 0., 1.);\n"
    "  attenuation *= attenuation;\n"
    "\n"
    "  // Smooth attenuation of the falloff defined by the range.\n"
    "  lightDistanceFalloff *= attenuation;\n"
    "  \n"
    "  return lightDistanceFalloff;\n"
    "}\n"
    "\n"
    "float computeDistanceLightFalloff(vec3 lightOffset, float lightDistanceSquared, float range, float inverseSquaredRange)\n"
    "{   \n"
    "  #ifdef USEPHYSICALLIGHTFALLOFF\n"
    "  return computeDistanceLightFalloff_Physical(lightDistanceSquared);\n"
    "  #elif defined(USEGLTFLIGHTFALLOFF)\n"
    "  return computeDistanceLightFalloff_GLTF(lightDistanceSquared, inverseSquaredRange);\n"
    "  #else\n"
    "  return computeDistanceLightFalloff_Standard(lightOffset, range);\n"
    "  #endif\n"
    "}\n"
    "\n"
    "float computeDirectionalLightFalloff_Standard(vec3 lightDirection, vec3 directionToLightCenterW, float cosHalfAngle, float exponent)\n"
    "{\n"
    "  float falloff = 0.0;\n"
    "\n"
    "  float cosAngle = max(0.000000000000001, dot(-lightDirection, directionToLightCenterW));\n"
    "  if (cosAngle >= cosHalfAngle)\n"
    "  {\n"
    "  falloff = max(0., pow(cosAngle, exponent));\n"
    "  }\n"
    "  \n"
    "  return falloff;\n"
    "}\n"
    "\n"
    "float computeDirectionalLightFalloff_Physical(vec3 lightDirection, vec3 directionToLightCenterW, float cosHalfAngle)\n"
    "{\n"
    "  const float kMinusLog2ConeAngleIntensityRatio = 6.64385618977; // -log2(0.01)\n"
    "\n"
    "  // Calculate a Spherical Gaussian (von Mises-Fisher distribution, not angle-based Gaussian) such that the peak is in the light direction,\n"
    "  // and the value at the nominal cone angle is 1% of the peak. Because we want the distribution to decay from unity (100%)\n"
    "  // at the peak direction (dot product = 1) down to 1% at the nominal cone cutoff (dot product = cosAngle) \n"
    "  // the falloff rate expressed in terms of the base-two dot product is therefore -log2(ConeAngleIntensityRatio) / (1.0 - cosAngle).\n"
    "  // Note that the distribution is unnormalised in that peak density is unity, rather than the total energy is unity.\n"
    "  float concentrationKappa = kMinusLog2ConeAngleIntensityRatio / (1.0 - cosHalfAngle);\n"
    "\n"
    "  // Evaluate spherical gaussian for light directional falloff for spot light type (note: spot directional falloff; \n"
    "  // not directional light type)\n"
    "  vec4 lightDirectionSpreadSG = vec4(-lightDirection * concentrationKappa, -concentrationKappa);\n"
    "  float falloff = exp2(dot(vec4(directionToLightCenterW, 1.0), lightDirectionSpreadSG));\n"
    "  return falloff;\n"
    "}\n"
    "\n"
    "float computeDirectionalLightFalloff_GLTF(vec3 lightDirection, vec3 directionToLightCenterW, float lightAngleScale, float lightAngleOffset)\n"
    "{\n"
    "  // On the CPU\n"
    "  // float lightAngleScale = 1.0 f / max (0.001f, ( cosInner - cosOuter ));\n"
    "  // float lightAngleOffset = -cosOuter * angleScale;\n"
    "\n"
    "  float cd = dot(-lightDirection, directionToLightCenterW);\n"
    "  float falloff = clamp(cd * lightAngleScale + lightAngleOffset, 0., 1.);\n"
    "  // smooth the transition\n"
    "  falloff *= falloff;\n"
    "  return falloff;\n"
    "}\n"
    "\n"
    "float computeDirectionalLightFalloff(vec3 lightDirection, vec3 directionToLightCenterW, float cosHalfAngle, float exponent, float lightAngleScale, float lightAngleOffset)\n"
    "{\n"
    "  #ifdef USEPHYSICALLIGHTFALLOFF\n"
    "  return computeDirectionalLightFalloff_Physical(lightDirection, directionToLightCenterW, cosHalfAngle);\n"
    "  #elif defined(USEGLTFLIGHTFALLOFF)\n"
    "  return computeDirectionalLightFalloff_GLTF(lightDirection, directionToLightCenterW, lightAngleScale, lightAngleOffset);\n"
    "  #else\n"
    "  return computeDirectionalLightFalloff_Standard(lightDirection, directionToLightCenterW, cosHalfAngle, exponent);\n"
    "  #endif\n"
    "}\n"
    "\n"
    "pointLightingInfo computePointLightingInfo(vec4 lightData) {\n"
    "  pointLightingInfo result;\n"
    "\n"
    "  result.lightOffset = lightData.xyz - vPositionW;\n"
    "  result.lightDistanceSquared = dot(result.lightOffset, result.lightOffset);\n"
    "\n"
    "  return result;\n"
    "}\n"
    "\n"
    "spotLightingInfo computeSpotLightingInfo(vec4 lightData) {\n"
    "  spotLightingInfo result;\n"
    "\n"
    "  result.lightOffset = lightData.xyz - vPositionW;\n"
    "  result.directionToLightCenterW = normalize(result.lightOffset);\n"
    "  result.lightDistanceSquared = dot(result.lightOffset, result.lightOffset);\n"
    "\n"
    "  return result;\n"
    "}\n"
    "\n"
    "lightingInfo computePointLighting(pointLightingInfo info, vec3 viewDirectionW, vec3 vNormal, vec3 diffuseColor,  float lightRadius, float roughness, float NdotV, vec3 reflectance0, vec3 reflectance90, float geometricRoughnessFactor, out float NdotL) {\n"
    "  lightingInfo result;\n"
    "\n"
    "  float lightDistance = sqrt(info.lightDistanceSquared);\n"
    "  vec3 lightDirection = normalize(info.lightOffset);\n"
    "  \n"
    "  // Roughness\n"
    "  roughness = adjustRoughnessFromLightProperties(roughness, lightRadius, lightDistance);\n"
    "  \n"
    "  // diffuse\n"
    "  vec3 H = normalize(viewDirectionW + lightDirection);\n"
    "  NdotL = clamp(dot(vNormal, lightDirection), 0.00000000001, 1.0);\n"
    "  float VdotH = clamp(dot(viewDirectionW, H), 0.0, 1.0);\n"
    "\n"
    "  float diffuseTerm = computeDiffuseTerm(NdotL, NdotV, VdotH, roughness);\n"
    "  result.diffuse = diffuseTerm * diffuseColor * info.attenuation;\n"
    "\n"
    "  #ifdef SPECULARTERM\n"
    "  // Specular\n"
    "  float NdotH = clamp(dot(vNormal, H), 0.000000000001, 1.0);\n"
    "\n"
    "  vec3 specTerm = computeSpecularTerm(NdotH, NdotL, NdotV, VdotH, roughness, reflectance0, reflectance90, geometricRoughnessFactor);\n"
    "  result.specular = specTerm * diffuseColor * info.attenuation;\n"
    "  #endif\n"
    "\n"
    "  return result;\n"
    "}\n"
    "\n"
    "lightingInfo computeSpotLighting(spotLightingInfo info, vec3 viewDirectionW, vec3 vNormal, vec4 lightDirection, vec3 diffuseColor, float lightRadius, float roughness, float NdotV, vec3 reflectance0, vec3 reflectance90, float geometricRoughnessFactor, out float NdotL) {\n"
    "  lightingInfo result;\n"
    "\n"
    "  // Roughness.\n"
    "  float lightDistance = sqrt(info.lightDistanceSquared);\n"
    "  roughness = adjustRoughnessFromLightProperties(roughness, lightRadius, lightDistance);\n"
    "  \n"
    "  // Diffuse\n"
    "  vec3 H = normalize(viewDirectionW + info.directionToLightCenterW);\n"
    "  NdotL = clamp(dot(vNormal, info.directionToLightCenterW), 0.000000000001, 1.0);\n"
    "  float VdotH = clamp(dot(viewDirectionW, H), 0.0, 1.0);\n"
    "\n"
    "  float diffuseTerm = computeDiffuseTerm(NdotL, NdotV, VdotH, roughness);\n"
    "  result.diffuse = diffuseTerm * diffuseColor * info.attenuation;\n"
    "\n"
    "  #ifdef SPECULARTERM\n"
    "  // Specular\n"
    "  float NdotH = clamp(dot(vNormal, H), 0.000000000001, 1.0);\n"
    "\n"
    "  vec3 specTerm = computeSpecularTerm(NdotH, NdotL, NdotV, VdotH, roughness, reflectance0, reflectance90, geometricRoughnessFactor);\n"
    "  result.specular = specTerm * diffuseColor * info.attenuation;\n"
    "  #endif\n"
    "\n"
    "  return result;\n"
    "}\n"
    "\n"
    "lightingInfo computeDirectionalLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, float lightRadius, float roughness, float NdotV, vec3 reflectance0, vec3 reflectance90, float geometricRoughnessFactor, out float NdotL) {\n"
    "  lightingInfo result;\n"
    "\n"
    "  float lightDistance = length(-lightData.xyz);\n"
    "  vec3 lightDirection = normalize(-lightData.xyz);\n"
    "\n"
    "  // Roughness\n"
    "  roughness = adjustRoughnessFromLightProperties(roughness, lightRadius, lightDistance);\n"
    "  \n"
    "  // diffuse\n"
    "  vec3 H = normalize(viewDirectionW + lightDirection);\n"
    "  NdotL = clamp(dot(vNormal, lightDirection), 0.00000000001, 1.0);\n"
    "  float VdotH = clamp(dot(viewDirectionW, H), 0.0, 1.0);\n"
    "\n"
    "  float diffuseTerm = computeDiffuseTerm(NdotL, NdotV, VdotH, roughness);\n"
    "  result.diffuse = diffuseTerm * diffuseColor;\n"
    "\n"
    "  #ifdef SPECULARTERM\n"
    "  // Specular\n"
    "  float NdotH = clamp(dot(vNormal, H), 0.000000000001, 1.0);\n"
    "\n"
    "  vec3 specTerm = computeSpecularTerm(NdotH, NdotL, NdotV, VdotH, roughness, reflectance0, reflectance90, geometricRoughnessFactor);\n"
    "  result.specular = specTerm * diffuseColor;\n"
    "  #endif\n"
    "\n"
    "  return result;\n"
    "}\n"
    "\n"
    "lightingInfo computeHemisphericLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, vec3 groundColor, float roughness, float NdotV, vec3 reflectance0, vec3 reflectance90, float geometricRoughnessFactor, out float NdotL) {\n"
    "  lightingInfo result;\n"
    "\n"
    "  // Roughness\n"
    "  // Do not touch roughness on hemispheric.\n"
    "\n"
    "  // Diffuse\n"
    "  NdotL = dot(vNormal, lightData.xyz) * 0.5 + 0.5;\n"
    "  result.diffuse = mix(groundColor, diffuseColor, NdotL);\n"
    "\n"
    "  #ifdef SPECULARTERM\n"
    "  // Specular\n"
    "  vec3 lightVectorW = normalize(lightData.xyz);\n"
    "  vec3 H = normalize(viewDirectionW + lightVectorW);\n"
    "  float NdotH = clamp(dot(vNormal, H), 0.000000000001, 1.0);\n"
    "  NdotL = clamp(NdotL, 0.000000000001, 1.0);\n"
    "  float VdotH = clamp(dot(viewDirectionW, H), 0.0, 1.0);\n"
    "\n"
    "  vec3 specTerm = computeSpecularTerm(NdotH, NdotL, NdotV, VdotH, roughness, reflectance0, reflectance90, geometricRoughnessFactor);\n"
    "  result.specular = specTerm * diffuseColor;\n"
    "  #endif\n"
    "\n"
    "  return result;\n"
    "}\n"
    "\n"
    "vec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler, mat4 textureProjectionMatrix){\n"
    "  vec4 strq = textureProjectionMatrix * vec4(vPositionW, 1.0);\n"
    "  strq /= strq.w;\n"
    "  vec3 textureColor = texture2D(projectionLightSampler, strq.xy).rgb;\n"
    "  return toLinearSpace(textureColor);\n"
    "}\n";

} // end of namespace BABYLON

#endif // end of BABYLON_SHADERS_SHADERS_INCLUDE_PBR_LIGHT_FUNCTIONS_FX_H
