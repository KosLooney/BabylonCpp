#ifndef BABYLON_SHADERS_SHADERS_INCLUDE_IMAGE_PROCESSING_FUNCTIONS_FX_H
#define BABYLON_SHADERS_SHADERS_INCLUDE_IMAGE_PROCESSING_FUNCTIONS_FX_H

namespace BABYLON {

extern const char* imageProcessingFunctions;

const char* imageProcessingFunctions
  = "#if defined(COLORGRADING) && !defined(COLORGRADING3D)\n"
    "  /** \n"
    "  * Polyfill for SAMPLE_TEXTURE_3D, which is unsupported in WebGL.\n"
    "  * sampler3dSetting.x = textureOffset (0.5 / textureSize).\n"
    "  * sampler3dSetting.y = textureSize.\n"
    "  */\n"
    "  vec3 sampleTexture3D(sampler2D colorTransform, vec3 color, vec2 sampler3dSetting)\n"
    "  {\n"
    "  float sliceSize = 2.0 * sampler3dSetting.x; // Size of 1 slice relative to the texture, for example 1/8\n"
    "\n"
    "  #ifdef SAMPLER3DGREENDEPTH\n"
    "  float sliceContinuous = (color.g - sampler3dSetting.x) * sampler3dSetting.y;\n"
    "  #else\n"
    "  float sliceContinuous = (color.b - sampler3dSetting.x) * sampler3dSetting.y;\n"
    "  #endif\n"
    "  float sliceInteger = floor(sliceContinuous);\n"
    "\n"
    "  // Note: this is mathematically equivalent to fract(sliceContinuous); but we use explicit subtract\n"
    "  // rather than separate fract() for correct results near slice boundaries (matching sliceInteger choice)\n"
    "  float sliceFraction = sliceContinuous - sliceInteger;\n"
    "\n"
    "  #ifdef SAMPLER3DGREENDEPTH\n"
    "  vec2 sliceUV = color.rb;\n"
    "  #else\n"
    "  vec2 sliceUV = color.rg;\n"
    "  #endif\n"
    "  \n"
    "  sliceUV.x *= sliceSize;\n"
    "  sliceUV.x += sliceInteger * sliceSize;\n"
    "\n"
    "  sliceUV = clamp(sliceUV, 0., 1.);\n"
    "\n"
    "  vec4 slice0Color = texture2D(colorTransform, sliceUV);\n"
    "\n"
    "  sliceUV.x += sliceSize;\n"
    "  \n"
    "  sliceUV = clamp(sliceUV, 0., 1.);\n"
    "  vec4 slice1Color = texture2D(colorTransform, sliceUV);\n"
    "\n"
    "  vec3 result = mix(slice0Color.rgb, slice1Color.rgb, sliceFraction);\n"
    "\n"
    "  #ifdef SAMPLER3DBGRMAP\n"
    "  color.rgb = result.rgb;\n"
    "  #else\n"
    "  color.rgb = result.bgr;\n"
    "  #endif\n"
    "\n"
    "  return color;\n"
    "  }\n"
    "#endif\n"
    "\n"
    "vec4 applyImageProcessing(vec4 result) {\n"
    "\n"
    "#ifdef EXPOSURE\n"
    "  result.rgb *= exposureLinear;\n"
    "#endif\n"
    "\n"
    "#ifdef VIGNETTE\n"
    "  //vignette\n"
    "  vec2 viewportXY = gl_FragCoord.xy * vInverseScreenSize;\n"
    "  viewportXY = viewportXY * 2.0 - 1.0;\n"
    "  vec3 vignetteXY1 = vec3(viewportXY * vignetteSettings1.xy + vignetteSettings1.zw, 1.0);\n"
    "  float vignetteTerm = dot(vignetteXY1, vignetteXY1);\n"
    "  float vignette = pow(vignetteTerm, vignetteSettings2.w);\n"
    "\n"
    "  // Interpolate between the artist 'color' and white based on the physical transmission value 'vignette'.\n"
    "  vec3 vignetteColor = vignetteSettings2.rgb;\n"
    "\n"
    "  #ifdef VIGNETTEBLENDMODEMULTIPLY\n"
    "  vec3 vignetteColorMultiplier = mix(vignetteColor, vec3(1, 1, 1), vignette);\n"
    "  result.rgb *= vignetteColorMultiplier;\n"
    "  #endif\n"
    "\n"
    "  #ifdef VIGNETTEBLENDMODEOPAQUE\n"
    "  result.rgb = mix(vignetteColor, result.rgb, vignette);\n"
    "  #endif\n"
    "#endif\n"
    "  \n"
    "#ifdef TONEMAPPING\n"
    "  const float tonemappingCalibration = 1.590579;\n"
    "  result.rgb = 1.0 - exp2(-tonemappingCalibration * result.rgb);\n"
    "#endif\n"
    "\n"
    "  // Going back to gamma space\n"
    "  result.rgb = toGammaSpace(result.rgb);\n"
    "  result.rgb = clamp(result.rgb, 0.0, 1.0);\n"
    "\n"
    "#ifdef CONTRAST\n"
    "  // Contrast\n"
    "  vec3 resultHighContrast = applyEaseInOut(result.rgb);\n"
    "\n"
    "  if (contrast < 1.0) {\n"
    "  // Decrease contrast: interpolate towards zero-contrast image (flat grey)\n"
    "  result.rgb = mix(vec3(0.5, 0.5, 0.5), result.rgb, contrast);\n"
    "  } else {\n"
    "  // Increase contrast: apply simple shoulder-toe high contrast curve\n"
    "  result.rgb = mix(result.rgb, resultHighContrast, contrast - 1.0);\n"
    "  }\n"
    "#endif\n"
    "\n"
    "  // Apply Color Transform\n"
    "#ifdef COLORGRADING\n"
    "  vec3 colorTransformInput = result.rgb * colorTransformSettings.xxx + colorTransformSettings.yyy;\n"
    "  #ifdef COLORGRADING3D\n"
    "  vec3 colorTransformOutput = texture(txColorTransform, colorTransformInput).rgb;\n"
    "  #else\n"
    "  vec3 colorTransformOutput = sampleTexture3D(txColorTransform, colorTransformInput, colorTransformSettings.yz).rgb;\n"
    "  #endif\n"
    "\n"
    "  result.rgb = mix(result.rgb, colorTransformOutput, colorTransformSettings.www);\n"
    "#endif\n"
    "\n"
    "#ifdef COLORCURVES\n"
    "  // Apply Color Curves\n"
    "  float luma = getLuminance(result.rgb);\n"
    "  vec2 curveMix = clamp(vec2(luma * 3.0 - 1.5, luma * -3.0 + 1.5), vec2(0.0), vec2(1.0));\n"
    "  vec4 colorCurve = vCameraColorCurveNeutral + curveMix.x * vCameraColorCurvePositive - curveMix.y * vCameraColorCurveNegative;\n"
    "\n"
    "  result.rgb *= colorCurve.rgb;\n"
    "  result.rgb = mix(vec3(luma), result.rgb, colorCurve.a);\n"
    "#endif\n"
    "\n"
    "  return result;\n"
    "}\n";

} // end of namespace BABYLON

#endif // end of BABYLON_SHADERS_SHADERS_INCLUDE_IMAGE_PROCESSING_FUNCTIONS_FX_H
