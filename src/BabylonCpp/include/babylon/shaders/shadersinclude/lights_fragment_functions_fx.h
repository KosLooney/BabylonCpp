#ifndef BABYLON_SHADERS_SHADERS_INCLUDE_LIGHTS_FRAGMENT_FUNCTIONS_FX_H
#define BABYLON_SHADERS_SHADERS_INCLUDE_LIGHTS_FRAGMENT_FUNCTIONS_FX_H

namespace BABYLON {

extern const char* lightsFragmentFunctions;

const char* lightsFragmentFunctions
  = "// Light Computing\n"
    "struct lightingInfo\n"
    "{\n"
    "  vec3 diffuse;\n"
    "#ifdef SPECULARTERM\n"
    "  vec3 specular;\n"
    "#endif\n"
    "#ifdef NDOTL\n"
    "  float ndl;\n"
    "#endif\n"
    "};\n"
    "\n"
    "lightingInfo computeLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, float range, float glossiness) {\n"
    "  lightingInfo result;\n"
    "\n"
    "  vec3 lightVectorW;\n"
    "  float attenuation = 1.0;\n"
    "  if (lightData.w == 0.)\n"
    "  {\n"
    "  vec3 direction = lightData.xyz - vPositionW;\n"
    "\n"
    "  attenuation = max(0., 1.0 - length(direction) / range);\n"
    "  lightVectorW = normalize(direction);\n"
    "  }\n"
    "  else\n"
    "  {\n"
    "  lightVectorW = normalize(-lightData.xyz);\n"
    "  }\n"
    "\n"
    "  // diffuse\n"
    "  float ndl = max(0., dot(vNormal, lightVectorW));\n"
    "#ifdef NDOTL\n"
    "  result.ndl = ndl;\n"
    "#endif\n"
    "  result.diffuse = ndl * diffuseColor * attenuation;\n"
    "#ifdef SPECULARTERM\n"
    "  // Specular\n"
    "  vec3 angleW = normalize(viewDirectionW + lightVectorW);\n"
    "  float specComp = max(0., dot(vNormal, angleW));\n"
    "  specComp = pow(specComp, max(1., glossiness));\n"
    "\n"
    "  result.specular = specComp * specularColor * attenuation;\n"
    "#endif\n"
    "  return result;\n"
    "}\n"
    "\n"
    "lightingInfo computeSpotLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 lightDirection, vec3 diffuseColor, vec3 specularColor, float range, float glossiness) {\n"
    "  lightingInfo result;\n"
    "\n"
    "  vec3 direction = lightData.xyz - vPositionW;\n"
    "  vec3 lightVectorW = normalize(direction);\n"
    "  float attenuation = max(0., 1.0 - length(direction) / range);\n"
    "\n"
    "  // diffuse\n"
    "  float cosAngle = max(0., dot(lightDirection.xyz, -lightVectorW));\n"
    "\n"
    "  if (cosAngle >= lightDirection.w)\n"
    "  {\n"
    "  cosAngle = max(0., pow(cosAngle, lightData.w));\n"
    "  attenuation *= cosAngle;\n"
    "\n"
    "  // Diffuse\n"
    "  float ndl = max(0., dot(vNormal, lightVectorW));\n"
    "#ifdef NDOTL\n"
    "  result.ndl = ndl;\n"
    "#endif\n"
    "  result.diffuse = ndl * diffuseColor * attenuation;\n"
    "#ifdef SPECULARTERM\n"
    "  // Specular\n"
    "  vec3 angleW = normalize(viewDirectionW + lightVectorW);\n"
    "  float specComp = max(0., dot(vNormal, angleW));\n"
    "  specComp = pow(specComp, max(1., glossiness));\n"
    "\n"
    "  result.specular = specComp * specularColor * attenuation;\n"
    "#endif\n"
    "  return result;\n"
    "  }\n"
    "\n"
    "  result.diffuse = vec3(0.);\n"
    "#ifdef SPECULARTERM\n"
    "  result.specular = vec3(0.);\n"
    "#endif\n"
    "#ifdef NDOTL\n"
    "  result.ndl = 0.;\n"
    "#endif\n"
    "\n"
    "  return result;\n"
    "}\n"
    "\n"
    "lightingInfo computeHemisphericLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, vec3 groundColor, float glossiness) {\n"
    "  lightingInfo result;\n"
    "\n"
    "  // Diffuse\n"
    "  float ndl = dot(vNormal, lightData.xyz) * 0.5 + 0.5;\n"
    "#ifdef NDOTL\n"
    "  result.ndl = ndl;\n"
    "#endif\n"
    "\n"
    "  result.diffuse = mix(groundColor, diffuseColor, ndl);\n"
    "\n"
    "#ifdef SPECULARTERM\n"
    "  // Specular\n"
    "  vec3 angleW = normalize(viewDirectionW + lightData.xyz);\n"
    "  float specComp = max(0., dot(vNormal, angleW));\n"
    "  specComp = pow(specComp, max(1., glossiness));\n"
    "\n"
    "  result.specular = specComp * specularColor;\n"
    "#endif\n"
    "  return result;\n"
    "}\n"
    "\n"
    "vec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler, mat4 textureProjectionMatrix){\n"
    "  vec4 strq = textureProjectionMatrix * vec4(vPositionW, 1.0);\n"
    "  strq /= strq.w;\n"
    "  vec3 textureColor = texture2D(projectionLightSampler, strq.xy).rgb;\n"
    "  return textureColor;\n"
    "}\n";

} // end of namespace BABYLON

#endif // end of BABYLON_SHADERS_SHADERS_INCLUDE_LIGHTS_FRAGMENT_FUNCTIONS_FX_H
