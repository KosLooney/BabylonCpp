#ifndef BABYLON_SHADERS_SHADERS_INCLUDE_PBR_DIRECT_LIGHTING_FUNCTIONS_FX_H
#define BABYLON_SHADERS_SHADERS_INCLUDE_PBR_DIRECT_LIGHTING_FUNCTIONS_FX_H

namespace BABYLON {

extern const char* pbrDirectLightingFunctions;

const char* pbrDirectLightingFunctions
  = "#define CLEARCOATREFLECTANCE90 1.0\n"
    "\n"
    "// Light Results\n"
    "struct lightingInfo\n"
    "{\n"
    "  vec3 diffuse;\n"
    "  #ifdef SPECULARTERM\n"
    "  vec3 specular;\n"
    "  #endif\n"
    "  #ifdef CLEARCOAT\n"
    "  // xyz contains the clearcoat color.\n"
    "  // w contains the 1 - clearcoat fresnel to ease the energy conservation computation.\n"
    "  vec4 clearCoat;\n"
    "  #endif\n"
    "  #ifdef SHEEN\n"
    "  vec3 sheen;\n"
    "  #endif\n"
    "};\n"
    "\n"
    "// Simulate area (small) lights by increasing roughness\n"
    "float adjustRoughnessFromLightProperties(float roughness, float lightRadius, float lightDistance) {\n"
    "  #if defined(USEPHYSICALLIGHTFALLOFF) || defined(USEGLTFLIGHTFALLOFF)\n"
    "  // At small angle this approximation works. \n"
    "  float lightRoughness = lightRadius / lightDistance;\n"
    "  // Distribution can sum.\n"
    "  float totalRoughness = saturate(lightRoughness + roughness);\n"
    "  return totalRoughness;\n"
    "  #else\n"
    "  return roughness;\n"
    "  #endif\n"
    "}\n"
    "\n"
    "vec3 computeHemisphericDiffuseLighting(preLightingInfo info, vec3 lightColor, vec3 groundColor) {\n"
    "  return mix(groundColor, lightColor, info.NdotL);\n"
    "}\n"
    "\n"
    "vec3 computeDiffuseLighting(preLightingInfo info, vec3 lightColor) {\n"
    "  float diffuseTerm = diffuseBRDF_Burley(info.NdotL, info.NdotV, info.VdotH, info.roughness);\n"
    "  return diffuseTerm * info.attenuation * info.NdotL * lightColor;\n"
    "}\n"
    "\n"
    "vec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler, mat4 textureProjectionMatrix){\n"
    "  vec4 strq = textureProjectionMatrix * vec4(vPositionW, 1.0);\n"
    "  strq /= strq.w;\n"
    "  vec3 textureColor = texture2D(projectionLightSampler, strq.xy).rgb;\n"
    "  return toLinearSpace(textureColor);\n"
    "}\n"
    "\n"
    "#ifdef SS_TRANSLUCENCY\n"
    "  vec3 computeDiffuseAndTransmittedLighting(preLightingInfo info, vec3 lightColor, vec3 transmittance) {\n"
    "  float NdotL = absEps(info.NdotLUnclamped);\n"
    "\n"
    "  // Use wrap lighting to simulate SSS.\n"
    "  float wrapNdotL = computeWrappedDiffuseNdotL(NdotL, 0.02);\n"
    "\n"
    "  // Remap transmittance from tr to 1. if ndotl is negative.\n"
    "  float trAdapt = step(0., info.NdotLUnclamped);\n"
    "  vec3 transmittanceNdotL = mix(transmittance * wrapNdotL, vec3(wrapNdotL), trAdapt);\n"
    "\n"
    "  float diffuseTerm = diffuseBRDF_Burley(NdotL, info.NdotV, info.VdotH, info.roughness);\n"
    "  return diffuseTerm * transmittanceNdotL * info.attenuation * lightColor;\n"
    "  }\n"
    "#endif\n"
    "\n"
    "#ifdef SPECULARTERM\n"
    "  vec3 computeSpecularLighting(preLightingInfo info, vec3 N, vec3 reflectance0, vec3 reflectance90, float geometricRoughnessFactor, vec3 lightColor) {\n"
    "  float NdotH = saturateEps(dot(N, info.H));\n"
    "  float roughness = max(info.roughness, geometricRoughnessFactor);\n"
    "  float alphaG = convertRoughnessToAverageSlope(roughness);\n"
    "\n"
    "  vec3 fresnel = fresnelSchlickGGX(info.VdotH, reflectance0, reflectance90);\n"
    "  float distribution = normalDistributionFunction_TrowbridgeReitzGGX(NdotH, alphaG);\n"
    "\n"
    "  #ifdef BRDF_V_HEIGHT_CORRELATED\n"
    "  float visibility = smithVisibility_GGXCorrelated(info.NdotL, info.NdotV, alphaG);\n"
    "  #else\n"
    "  float visibility = smithVisibility_TrowbridgeReitzGGXFast(info.NdotL, info.NdotV, alphaG);\n"
    "  #endif\n"
    "\n"
    "  vec3 specTerm = fresnel * distribution * visibility;\n"
    "  return specTerm * info.attenuation * info.NdotL * lightColor;\n"
    "  }\n"
    "#endif\n"
    "\n"
    "#ifdef ANISOTROPIC\n"
    "  vec3 computeAnisotropicSpecularLighting(preLightingInfo info, vec3 V, vec3 N, vec3 T, vec3 B, float anisotropy, vec3 reflectance0, vec3 reflectance90, float geometricRoughnessFactor, vec3 lightColor) {\n"
    "  float NdotH = saturateEps(dot(N, info.H));\n"
    "  float TdotH = dot(T, info.H);\n"
    "  float BdotH = dot(B, info.H);\n"
    "  float TdotV = dot(T, V);\n"
    "  float BdotV = dot(B, V);\n"
    "  float TdotL = dot(T, info.L);\n"
    "  float BdotL = dot(B, info.L);\n"
    "  float alphaG = convertRoughnessToAverageSlope(info.roughness);\n"
    "  vec2 alphaTB = getAnisotropicRoughness(alphaG, anisotropy);\n"
    "  alphaTB = max(alphaTB, square(geometricRoughnessFactor));\n"
    "\n"
    "  vec3 fresnel = fresnelSchlickGGX(info.VdotH, reflectance0, reflectance90);\n"
    "  float distribution = normalDistributionFunction_BurleyGGX_Anisotropic(NdotH, TdotH, BdotH, alphaTB);\n"
    "  float visibility = smithVisibility_GGXCorrelated_Anisotropic(info.NdotL, info.NdotV, TdotV, BdotV, TdotL, BdotL, alphaTB);\n"
    "\n"
    "  vec3 specTerm = fresnel * distribution * visibility;\n"
    "  return specTerm * info.attenuation * info.NdotL * lightColor;\n"
    "  }\n"
    "#endif\n"
    "\n"
    "#ifdef CLEARCOAT\n"
    "  vec4 computeClearCoatLighting(preLightingInfo info, vec3 Ncc, float geometricRoughnessFactor, float clearCoatIntensity, vec3 lightColor) {\n"
    "  float NccdotL = saturateEps(dot(Ncc, info.L));\n"
    "  float NccdotH = saturateEps(dot(Ncc, info.H));\n"
    "  float clearCoatRoughness = max(info.roughness, geometricRoughnessFactor);\n"
    "  float alphaG = convertRoughnessToAverageSlope(clearCoatRoughness);\n"
    "\n"
    "  float fresnel = fresnelSchlickGGX(info.VdotH, vClearCoatRefractionParams.x, CLEARCOATREFLECTANCE90);\n"
    "  fresnel *= clearCoatIntensity;\n"
    "  float distribution = normalDistributionFunction_TrowbridgeReitzGGX(NccdotH, alphaG);\n"
    "  float visibility = visibility_Kelemen(info.VdotH);\n"
    "\n"
    "  float clearCoatTerm = fresnel * distribution * visibility;\n"
    "\n"
    "  return vec4(\n"
    "  clearCoatTerm * info.attenuation * NccdotL * lightColor,\n"
    "  1.0 - fresnel\n"
    "  );\n"
    "  }\n"
    "\n"
    "  vec3 computeClearCoatLightingAbsorption(float NdotVRefract, vec3 L, vec3 Ncc, vec3 clearCoatColor, float clearCoatThickness, float clearCoatIntensity) {\n"
    "  vec3 LRefract = -refract(L, Ncc, vClearCoatRefractionParams.y);\n"
    "  float NdotLRefract = saturateEps(dot(Ncc, LRefract));\n"
    "\n"
    "  vec3 absorption = computeClearCoatAbsorption(NdotVRefract, NdotLRefract, clearCoatColor, clearCoatThickness, clearCoatIntensity);\n"
    "  return absorption;\n"
    "  }\n"
    "#endif\n"
    "\n"
    "#ifdef SHEEN\n"
    "  vec3 computeSheenLighting(preLightingInfo info, vec3 N, vec3 reflectance0, vec3 reflectance90, float geometricRoughnessFactor, vec3 lightColor) {\n"
    "  float NdotH = saturateEps(dot(N, info.H));\n"
    "  float roughness = max(info.roughness, geometricRoughnessFactor);\n"
    "  float alphaG = convertRoughnessToAverageSlope(roughness);\n"
    "\n"
    "  // No Fresnel Effect with sheen\n"
    "  // vec3 fresnel = fresnelSchlickGGX(info.VdotH, reflectance0, reflectance90);\n"
    "  vec3 fresnel = reflectance0;\n"
    "  float distribution = normalDistributionFunction_CharlieSheen(NdotH, alphaG);\n"
    "  float visibility = visibility_Ashikhmin(info.NdotL, info.NdotV);\n"
    "\n"
    "  vec3 sheenTerm = fresnel * distribution * visibility;\n"
    "  return sheenTerm * info.attenuation * info.NdotL * lightColor;\n"
    "  }\n"
    "#endif\n";

} // end of namespace BABYLON

#endif // end of BABYLON_SHADERS_SHADERS_INCLUDE_PBR_DIRECT_LIGHTING_FUNCTIONS_FX_H
