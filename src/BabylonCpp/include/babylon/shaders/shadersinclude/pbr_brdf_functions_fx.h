#ifndef BABYLON_SHADERS_SHADERS_INCLUDE_PBR_BRDF_FUNCTIONS_FX_H
#define BABYLON_SHADERS_SHADERS_INCLUDE_PBR_BRDF_FUNCTIONS_FX_H

namespace BABYLON {

extern const char* pbrBRDFFunctions;

const char* pbrBRDFFunctions
  = "// Constants\n"
    "#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\n"
    "\n"
    "// ______________________________________________________________________\n"
    "//\n"
    "//                              BRDF LOOKUP\n"
    "// ______________________________________________________________________\n"
    "\n"
    "#ifdef MS_BRDF_ENERGY_CONSERVATION\n"
    "  // http://www.jcgt.org/published/0008/01/03/\n"
    "  // http://advances.realtimerendering.com/s2018/Siggraph%202018%20HDRP%20talk_with%20notes.pdf\n"
    "  vec3 getEnergyConservationFactor(const vec3 specularEnvironmentR0, const vec3 environmentBrdf) {\n"
    "  return 1.0 + specularEnvironmentR0 * (1.0 / environmentBrdf.y - 1.0);\n"
    "  }\n"
    "#endif\n"
    "\n"
    "#ifdef ENVIRONMENTBRDF\n"
    "  vec3 getBRDFLookup(float NdotV, float perceptualRoughness, sampler2D brdfSampler) {\n"
    "  // Indexed on cos(theta) and roughness\n"
    "  vec2 UV = vec2(NdotV, perceptualRoughness);\n"
    "  \n"
    "  // We can find the scale and offset to apply to the specular value.\n"
    "  vec4 brdfLookup = texture2D(brdfSampler, UV);\n"
    "\n"
    "  #ifdef ENVIRONMENTBRDF_RGBD\n"
    "  brdfLookup.rgb = fromRGBD(brdfLookup.rgba);\n"
    "  #endif\n"
    "\n"
    "  return brdfLookup.rgb;\n"
    "  }\n"
    "\n"
    "  vec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0, const vec3 environmentBrdf) {\n"
    "  #ifdef BRDF_V_HEIGHT_CORRELATED\n"
    "  vec3 reflectance = mix(environmentBrdf.xxx, environmentBrdf.yyy, specularEnvironmentR0);\n"
    "  #else\n"
    "  vec3 reflectance = specularEnvironmentR0 * environmentBrdf.x + environmentBrdf.y;\n"
    "  #endif\n"
    "  return reflectance;\n"
    "  }\n"
    "#endif\n"
    "\n"
    "#if !defined(ENVIRONMENTBRDF) || defined(REFLECTIONMAP_SKYBOX) || defined(ALPHAFRESNEL)\n"
    "  vec3 getReflectanceFromAnalyticalBRDFLookup_Jones(float VdotN, vec3 reflectance0, vec3 reflectance90, float smoothness)\n"
    "  {\n"
    "  // Schlick fresnel approximation, extended with basic smoothness term so that rough surfaces do not approach reflectance90 at grazing angle\n"
    "  float weight = mix(FRESNEL_MAXIMUM_ON_ROUGH, 1.0, smoothness);\n"
    "  return reflectance0 + weight * (reflectance90 - reflectance0) * pow5(saturate(1.0 - VdotN));\n"
    "  }\n"
    "#endif\n"
    "\n"
    "#if defined(SHEEN) && defined(REFLECTION)\n"
    "  /**\n"
    "   * The sheen BRDF not containing F can be easily stored in the blue channel of the BRDF texture.\n"
    "   * The blue channel contains DCharlie * VAshikhmin * NdotL as a lokkup table\n"
    "   */\n"
    "  vec3 getSheenReflectanceFromBRDFLookup(const vec3 reflectance0, const vec3 environmentBrdf) {\n"
    "  vec3 sheenEnvironmentReflectance = reflectance0 * environmentBrdf.b;\n"
    "  return sheenEnvironmentReflectance;\n"
    "  }\n"
    "#endif\n"
    "\n"
    "// ______________________________________________________________________\n"
    "//\n"
    "//                              Schlick/Fresnel\n"
    "// ______________________________________________________________________\n"
    "\n"
    "// Schlick's approximation for R0 (Fresnel Reflectance Values)\n"
    "// Keep for references\n"
    "// vec3 getR0fromAirToSurfaceIOR(vec3 ior1) {\n"
    "//     return getR0fromIOR(ior1, vec3(1.0));\n"
    "// }\n"
    "\n"
    "// vec3 getR0fromIOR(vec3 ior1, vec3 ior2) {\n"
    "//     vec3 t = (ior1 - ior2) / (ior1 + ior2);\n"
    "//     return t * t;\n"
    "// }\n"
    "\n"
    "// vec3 getIORfromAirToSurfaceR0(vec3 f0) {\n"
    "//     vec3 s = sqrt(f0);\n"
    "//     return (1.0 + s) / (1.0 - s);\n"
    "// }\n"
    "\n"
    "// f0 Remapping due to layers\n"
    "// vec3 getR0RemappedForClearCoat(vec3 f0, vec3 clearCoatF0) {\n"
    "//     vec3 iorBase = getIORfromAirToSurfaceR0(f0);\n"
    "//     vec3 clearCoatIor = getIORfromAirToSurfaceR0(clearCoatF0);\n"
    "//     return getR0fromIOR(iorBase, clearCoatIor);\n"
    "// }\n"
    "\n"
    "vec3 fresnelSchlickGGX(float VdotH, vec3 reflectance0, vec3 reflectance90)\n"
    "{\n"
    "  return reflectance0 + (reflectance90 - reflectance0) * pow5(1.0 - VdotH);\n"
    "}\n"
    "\n"
    "float fresnelSchlickGGX(float VdotH, float reflectance0, float reflectance90)\n"
    "{\n"
    "  return reflectance0 + (reflectance90 - reflectance0) * pow5(1.0 - VdotH);\n"
    "}\n"
    "\n"
    "#ifdef CLEARCOAT\n"
    "  // Knowing ior clear coat is fix for the material\n"
    "  // Solving iorbase = 1 + sqrt(fo) / (1 - sqrt(fo)) and f0base = square((iorbase - iorclearcoat) / (iorbase - iorclearcoat))\n"
    "  // provide f0base = square(A + B * sqrt(fo)) / (B + A * sqrt(fo))\n"
    "  // where A = 1 - iorclearcoat\n"
    "  // and   B = 1 + iorclearcoat\n"
    "  vec3 getR0RemappedForClearCoat(vec3 f0) {\n"
    "  #ifdef CLEARCOAT_DEFAULTIOR\n"
    "  #ifdef MOBILE\n"
    "  return saturate(f0 * (f0 * 0.526868 + 0.529324) - 0.0482256);\n"
    "  #else\n"
    "  return saturate(f0 * (f0 * (0.941892 - 0.263008 * f0) + 0.346479) - 0.0285998);\n"
    "  #endif\n"
    "  #else\n"
    "  vec3 s = sqrt(f0);\n"
    "  vec3 t = (vClearCoatRefractionParams.z + vClearCoatRefractionParams.w * s) / (vClearCoatRefractionParams.w + vClearCoatRefractionParams.z * s);\n"
    "  return t * t;\n"
    "  #endif\n"
    "  }\n"
    "#endif\n"
    "\n"
    "// ______________________________________________________________________\n"
    "//\n"
    "//                              Distribution\n"
    "// ______________________________________________________________________\n"
    "\n"
    "// Trowbridge-Reitz (GGX)\n"
    "// Generalised Trowbridge-Reitz with gamma power=2.0\n"
    "float normalDistributionFunction_TrowbridgeReitzGGX(float NdotH, float alphaG)\n"
    "{\n"
    "  // Note: alphaG is average slope (gradient) of the normals in slope-space.\n"
    "  // It is also the (trigonometric) tangent of the median distribution value, i.e. 50% of normals have\n"
    "  // a tangent (gradient) closer to the macrosurface than this slope.\n"
    "  float a2 = square(alphaG);\n"
    "  float d = NdotH * NdotH * (a2 - 1.0) + 1.0;\n"
    "  return a2 / (PI * d * d);\n"
    "}\n"
    "\n"
    "#ifdef SHEEN\n"
    "  // https://knarkowicz.wordpress.com/2018/01/04/cloth-shading/\n"
    "  float normalDistributionFunction_CharlieSheen(float NdotH, float alphaG)\n"
    "  {\n"
    "  float invR = 1. / alphaG;\n"
    "  float cos2h = NdotH * NdotH;\n"
    "  float sin2h = 1. - cos2h;\n"
    "  return (2. + invR) * pow(sin2h, invR * .5) / (2. * PI);\n"
    "  }\n"
    "#endif\n"
    "\n"
    "#ifdef ANISOTROPIC\n"
    "  // GGX Distribution Anisotropic\n"
    "  // https://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf Addenda\n"
    "  float normalDistributionFunction_BurleyGGX_Anisotropic(float NdotH, float TdotH, float BdotH, const vec2 alphaTB) {\n"
    "  float a2 = alphaTB.x * alphaTB.y;\n"
    "  vec3 v = vec3(alphaTB.y * TdotH, alphaTB.x  * BdotH, a2 * NdotH);\n"
    "  float v2 = dot(v, v);\n"
    "  float w2 = a2 / v2;\n"
    "  return a2 * w2 * w2 * RECIPROCAL_PI;\n"
    "  }\n"
    "#endif\n"
    "\n"
    "// ______________________________________________________________________\n"
    "//\n"
    "//                              Visibility/Geometry\n"
    "// ______________________________________________________________________\n"
    "\n"
    "#ifdef BRDF_V_HEIGHT_CORRELATED\n"
    "  // GGX Mask/Shadowing Isotropic \n"
    "  // Heitz http://jcgt.org/published/0003/02/03/paper.pdf\n"
    "  // https://twvideo01.ubm-us.net/o1/vault/gdc2017/Presentations/Hammon_Earl_PBR_Diffuse_Lighting.pdf\n"
    "  float smithVisibility_GGXCorrelated(float NdotL, float NdotV, float alphaG) {\n"
    "  #ifdef MOBILE\n"
    "  // Appply simplification as all squared root terms are below 1 and squared\n"
    "  float GGXV = NdotL * (NdotV * (1.0 - alphaG) + alphaG);\n"
    "  float GGXL = NdotV * (NdotL * (1.0 - alphaG) + alphaG);\n"
    "  return 0.5 / (GGXV + GGXL);\n"
    "  #else\n"
    "  float a2 = alphaG * alphaG;\n"
    "  float GGXV = NdotL * sqrt(NdotV * (NdotV - a2 * NdotV) + a2);\n"
    "  float GGXL = NdotV * sqrt(NdotL * (NdotL - a2 * NdotL) + a2);\n"
    "  return 0.5 / (GGXV + GGXL);\n"
    "  #endif\n"
    "  }\n"
    "#else\n"
    "  // From Microfacet Models for Refraction through Rough Surfaces, Walter et al. 2007\n"
    "  // Keep for references\n"
    "  // float smithVisibilityG1_TrowbridgeReitzGGX(float dot, float alphaG)\n"
    "  // {\n"
    "  //   float tanSquared = (1.0 - dot * dot) / (dot * dot);\n"
    "  //   return 2.0 / (1.0 + sqrt(1.0 + alphaG * alphaG * tanSquared));\n"
    "  // }\n"
    "\n"
    "  // float smithVisibility_TrowbridgeReitzGGX_Walter(float NdotL, float NdotV, float alphaG)\n"
    "  // {\n"
    "  //   float visibility = smithVisibilityG1_TrowbridgeReitzGGX(NdotL, alphaG) * smithVisibilityG1_TrowbridgeReitzGGX(NdotV, alphaG);\n"
    "  //   visibility /= (4.0 * NdotL * NdotV); // Cook Torance Denominator  integrated in visibility to avoid issues when visibility function changes.\n"
    "  //   return visibility;\n"
    "  // }\n"
    "\n"
    "  // From smithVisibilityG1_TrowbridgeReitzGGX * dot / dot to cancel the cook\n"
    "  // torrance denominator :-)\n"
    "  float smithVisibilityG1_TrowbridgeReitzGGXFast(float dot, float alphaG)\n"
    "  {\n"
    "  #ifdef MOBILE\n"
    "  // Appply simplification as all squared root terms are below 1 and squared\n"
    "  return 1.0 / (dot + alphaG + (1.0 - alphaG) * dot ));\n"
    "  #else\n"
    "  float alphaSquared = alphaG * alphaG;\n"
    "  return 1.0 / (dot + sqrt(alphaSquared + (1.0 - alphaSquared) * dot * dot));\n"
    "  #endif\n"
    "  }\n"
    "\n"
    "  float smithVisibility_TrowbridgeReitzGGXFast(float NdotL, float NdotV, float alphaG)\n"
    "  {\n"
    "  float visibility = smithVisibilityG1_TrowbridgeReitzGGXFast(NdotL, alphaG) * smithVisibilityG1_TrowbridgeReitzGGXFast(NdotV, alphaG);\n"
    "  // No Cook Torance Denominator as it is canceled out in the previous form\n"
    "  return visibility;\n"
    "  }\n"
    "#endif\n"
    "\n"
    "#ifdef ANISOTROPIC\n"
    "  // GGX Mask/Shadowing Anisotropic \n"
    "  // Heitz http://jcgt.org/published/0003/02/03/paper.pdf\n"
    "  float smithVisibility_GGXCorrelated_Anisotropic(float NdotL, float NdotV, float TdotV, float BdotV, float TdotL, float BdotL, const vec2 alphaTB) {\n"
    "  float lambdaV = NdotL * length(vec3(alphaTB.x * TdotV, alphaTB.y * BdotV, NdotV));\n"
    "  float lambdaL = NdotV * length(vec3(alphaTB.x * TdotL, alphaTB.y * BdotL, NdotL));\n"
    "  float v = 0.5 / (lambdaV + lambdaL);\n"
    "  return v;\n"
    "  }\n"
    "#endif\n"
    "\n"
    "#ifdef CLEARCOAT\n"
    "  float visibility_Kelemen(float VdotH) {\n"
    "  // Simplified form integration the cook torrance denminator.\n"
    "  // Expanded is nl * nv / vh2 which factor with 1 / (4 * nl * nv)\n"
    "  // giving 1 / (4 * vh2))\n"
    "  return 0.25 / (VdotH * VdotH); \n"
    "  }\n"
    "#endif\n"
    "\n"
    "#ifdef SHEEN\n"
    "  // https://knarkowicz.wordpress.com/2018/01/04/cloth-shading/\n"
    "  // https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_sheen.pdf\n"
    "  // http://www.cs.utah.edu/~premoze/dbrdf/dBRDF.pdf\n"
    "  float visibility_Ashikhmin(float NdotL, float NdotV)\n"
    "  {\n"
    "  return 1. / (4. * (NdotL + NdotV - NdotL * NdotV));\n"
    "  }\n"
    "#endif\n"
    "\n"
    "// ______________________________________________________________________\n"
    "//\n"
    "//                              DiffuseBRDF\n"
    "// ______________________________________________________________________\n"
    "\n"
    "// Disney diffuse term\n"
    "// https://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf\n"
    "// Page 14\n"
    "float diffuseBRDF_Burley(float NdotL, float NdotV, float VdotH, float roughness) {\n"
    "  // Diffuse fresnel falloff as per Disney principled BRDF, and in the spirit of\n"
    "  // of general coupled diffuse/specular models e.g. Ashikhmin Shirley.\n"
    "  float diffuseFresnelNV = pow5(saturateEps(1.0 - NdotL));\n"
    "  float diffuseFresnelNL = pow5(saturateEps(1.0 - NdotV));\n"
    "  float diffuseFresnel90 = 0.5 + 2.0 * VdotH * VdotH * roughness;\n"
    "  float fresnel =\n"
    "  (1.0 + (diffuseFresnel90 - 1.0) * diffuseFresnelNL) *\n"
    "  (1.0 + (diffuseFresnel90 - 1.0) * diffuseFresnelNV);\n"
    "\n"
    "  return fresnel / PI;\n"
    "}\n"
    "\n"
    "#ifdef SS_TRANSLUCENCY\n"
    "  // Pixar diffusion profile\n"
    "  // http://graphics.pixar.com/library/ApproxBSSRDF/paper.pdf\n"
    "  vec3 transmittanceBRDF_Burley(const vec3 tintColor, const vec3 diffusionDistance, float thickness) {\n"
    "  vec3 S = 1. / maxEps(diffusionDistance);\n"
    "  vec3 temp = exp((-0.333333333 * thickness) * S);\n"
    "  return tintColor.rgb * 0.25 * (temp * temp * temp + 3.0 * temp);\n"
    "  }\n"
    "\n"
    "  // Extends the dark area to prevent seams\n"
    "  // Keep it energy conserving by using McCauley solution: https://blog.selfshadow.com/2011/12/31/righting-wrap-part-1/\n"
    "  float computeWrappedDiffuseNdotL(float NdotL, float w) {\n"
    "  float t = 1.0 + w;\n"
    "  float invt2 = 1.0 / square(t);\n"
    "  return saturate((NdotL + w) * invt2);\n"
    "  }\n"
    "#endif\n";

} // end of namespace BABYLON

#endif // end of BABYLON_SHADERS_SHADERS_INCLUDE_PBR_BRDF_FUNCTIONS_FX_H
