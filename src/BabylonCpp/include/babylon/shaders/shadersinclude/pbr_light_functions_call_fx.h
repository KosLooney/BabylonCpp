#ifndef BABYLON_SHADERS_SHADERS_INCLUDE_PBR_LIGHT_FUNCTIONS_CALL_FX_H
#define BABYLON_SHADERS_SHADERS_INCLUDE_PBR_LIGHT_FUNCTIONS_CALL_FX_H

namespace BABYLON {

extern const char* pbrLightFunctionsCall;

const char* pbrLightFunctionsCall
  = "#ifdef LIGHT{X}\n"
    "  #if defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n"
    "  //No light calculation\n"
    "  #else\n"
    "  #ifdef SPOTLIGHT{X}\n"
    "  info = computeSpotLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDirection, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular, light{X}.vLightDiffuse.a, roughness, NdotV, specularEnvironmentR90, NdotL);\n"
    "  #endif\n"
    "  #ifdef HEMILIGHT{X}\n"
    "  info = computeHemisphericLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular, light{X}.vLightGround, roughness, NdotV, specularEnvironmentR90, NdotL);\n"
    "  #endif\n"
    "  #if defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\n"
    "  info = computeLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular, light{X}.vLightDiffuse.a, roughness, NdotV, specularEnvironmentR90, NdotL);\n"
    "  #endif\n"
    "  #endif\n"
    "  \n"
    "  #ifdef SHADOW{X}\n"
    "  #ifdef SHADOWESM{X}\n"
    "  #if defined(POINTLIGHT{X})\n"
    "  notShadowLevel = computeShadowWithESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z);\n"
    "  #else\n"
    "  notShadowLevel = computeShadowWithESM(light{X}.vPositionFromLight, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z);\n"
    "  #endif\n"
    "  #else\n"
    "  #ifdef SHADOWPCF{X}\n"
    "  #if defined(POINTLIGHT{X})\n"
    "  notShadowLevel = computeShadowWithPCFCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x);\n"
    "  #else\n"
    "  notShadowLevel = computeShadowWithPCF(vPositionFromLight{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x);\n"
    "  #endif\n"
    "  #else\n"
    "  #if defined(POINTLIGHT{X})\n"
    "  notShadowLevel = computeShadowCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x);\n"
    "  #else\n"
    "  notShadowLevel = computeShadow(vPositionFromLight{X}, shadowSampler{X}, light{X}.shadowsInfo.x);\n"
    "  #endif\n"
    "  #endif\n"
    "  #endif\n"
    "  #else\n"
    "  notShadowLevel = 1.;\n"
    "  #endif\n"
    "  \n"
    "  #if defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\n"
    "  lightDiffuseContribution += lightmapColor * notShadowLevel;\n"
    "  \n"
    "  #ifdef SPECULARTERM\n"
    "  #ifndef LIGHTMAPNOSPECULAR{X}\n"
    "  lightSpecularContribution += info.specular * notShadowLevel * lightmapColor;\n"
    "  #endif\n"
    "  #endif\n"
    "  #else\n"
    "  lightDiffuseContribution += info.diffuse * notShadowLevel;\n"
    "  \n"
    "  #ifdef OVERLOADEDSHADOWVALUES\n"
    "  if (NdotL < 0.000000000011)\n"
    "  {\n"
    "  notShadowLevel = 1.;\n"
    "  }\n"
    "  shadowedOnlyLightDiffuseContribution *= notShadowLevel;\n"
    "  #endif\n"
    "\n"
    "  #ifdef SPECULARTERM\n"
    "  lightSpecularContribution += info.specular * notShadowLevel;\n"
    "  #endif\n"
    "  #endif\n"
    "#endif\n";

} // end of namespace BABYLON

#endif // end of BABYLON_SHADERS_SHADERS_INCLUDE_PBR_LIGHT_FUNCTIONS_CALL_FX_H
