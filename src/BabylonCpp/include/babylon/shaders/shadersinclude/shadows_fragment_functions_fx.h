#ifndef BABYLON_SHADERS_SHADERS_INCLUDE_SHADOWS_FRAGMENT_FUNCTIONS_FX_H
#define BABYLON_SHADERS_SHADERS_INCLUDE_SHADOWS_FRAGMENT_FUNCTIONS_FX_H

namespace BABYLON {

extern const char* shadowsFragmentFunctions;

const char* shadowsFragmentFunctions
  = "#ifdef SHADOWS\n"
    "  #ifndef SHADOWFLOAT\n"
    "  float unpack(vec4 color)\n"
    "  {\n"
    "  const vec4 bit_shift = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\n"
    "  return dot(color, bit_shift);\n"
    "  }\n"
    "  #endif\n"
    "\n"
    "  float computeShadowCube(vec3 lightPosition, samplerCube shadowSampler, float darkness, vec2 depthValues)\n"
    "  {\n"
    "  vec3 directionToLight = vPositionW - lightPosition;\n"
    "  float depth = length(directionToLight);\n"
    "  depth = (depth + depthValues.x) / (depthValues.y);\n"
    "  depth = clamp(depth, 0., 1.0);\n"
    "\n"
    "  directionToLight = normalize(directionToLight);\n"
    "  directionToLight.y = -directionToLight.y;\n"
    "  \n"
    "  #ifndef SHADOWFLOAT\n"
    "  float shadow = unpack(textureCube(shadowSampler, directionToLight));\n"
    "  #else\n"
    "  float shadow = textureCube(shadowSampler, directionToLight).x;\n"
    "  #endif\n"
    "\n"
    "  if (depth > shadow)\n"
    "  {\n"
    "  return darkness;\n"
    "  }\n"
    "  return 1.0;\n"
    "  }\n"
    "\n"
    "  float computeShadowWithPCFCube(vec3 lightPosition, samplerCube shadowSampler, float mapSize, float darkness, vec2 depthValues)\n"
    "  {\n"
    "  vec3 directionToLight = vPositionW - lightPosition;\n"
    "  float depth = length(directionToLight);\n"
    "  depth = (depth + depthValues.x) / (depthValues.y);\n"
    "  depth = clamp(depth, 0., 1.0);\n"
    "\n"
    "  directionToLight = normalize(directionToLight);\n"
    "  directionToLight.y = -directionToLight.y;\n"
    "\n"
    "  float visibility = 1.;\n"
    "\n"
    "  vec3 poissonDisk[4];\n"
    "  poissonDisk[0] = vec3(-1.0, 1.0, -1.0);\n"
    "  poissonDisk[1] = vec3(1.0, -1.0, -1.0);\n"
    "  poissonDisk[2] = vec3(-1.0, -1.0, -1.0);\n"
    "  poissonDisk[3] = vec3(1.0, -1.0, 1.0);\n"
    "\n"
    "  // Poisson Sampling\n"
    "\n"
    "  #ifndef SHADOWFLOAT\n"
    "  if (unpack(textureCube(shadowSampler, directionToLight + poissonDisk[0] * mapSize)) < depth) visibility -= 0.25;\n"
    "  if (unpack(textureCube(shadowSampler, directionToLight + poissonDisk[1] * mapSize)) < depth) visibility -= 0.25;\n"
    "  if (unpack(textureCube(shadowSampler, directionToLight + poissonDisk[2] * mapSize)) < depth) visibility -= 0.25;\n"
    "  if (unpack(textureCube(shadowSampler, directionToLight + poissonDisk[3] * mapSize)) < depth) visibility -= 0.25;\n"
    "  #else\n"
    "  if (textureCube(shadowSampler, directionToLight + poissonDisk[0] * mapSize).x < depth) visibility -= 0.25;\n"
    "  if (textureCube(shadowSampler, directionToLight + poissonDisk[1] * mapSize).x < depth) visibility -= 0.25;\n"
    "  if (textureCube(shadowSampler, directionToLight + poissonDisk[2] * mapSize).x < depth) visibility -= 0.25;\n"
    "  if (textureCube(shadowSampler, directionToLight + poissonDisk[3] * mapSize).x < depth) visibility -= 0.25;\n"
    "  #endif\n"
    "\n"
    "  return  min(1.0, visibility + darkness);\n"
    "  }\n"
    "\n"
    "  float computeShadowWithESMCube(vec3 lightPosition, samplerCube shadowSampler, float darkness, float depthScale, vec2 depthValues)\n"
    "  {\n"
    "  vec3 directionToLight = vPositionW - lightPosition;\n"
    "  float depth = length(directionToLight);\n"
    "  depth = (depth + depthValues.x) / (depthValues.y);\n"
    "  float shadowPixelDepth = clamp(depth, 0., 1.0);\n"
    "\n"
    "  directionToLight = normalize(directionToLight);\n"
    "  directionToLight.y = -directionToLight.y;\n"
    "  \n"
    "  #ifndef SHADOWFLOAT\n"
    "  float shadowMapSample = unpack(textureCube(shadowSampler, directionToLight));\n"
    "  #else\n"
    "  float shadowMapSample = textureCube(shadowSampler, directionToLight).x;\n"
    "  #endif\n"
    "\n"
    "  float esm = 1.0 - clamp(exp(min(87., depthScale * shadowPixelDepth)) * shadowMapSample, 0., 1. - darkness);  \n"
    "  return esm;\n"
    "  }\n"
    "\n"
    "  float computeShadowWithCloseESMCube(vec3 lightPosition, samplerCube shadowSampler, float darkness, float depthScale, vec2 depthValues)\n"
    "  {\n"
    "  vec3 directionToLight = vPositionW - lightPosition;\n"
    "  float depth = length(directionToLight);\n"
    "  depth = (depth + depthValues.x) / (depthValues.y);\n"
    "  float shadowPixelDepth = clamp(depth, 0., 1.0);\n"
    "\n"
    "  directionToLight = normalize(directionToLight);\n"
    "  directionToLight.y = -directionToLight.y;\n"
    "  \n"
    "  #ifndef SHADOWFLOAT\n"
    "  float shadowMapSample = unpack(textureCube(shadowSampler, directionToLight));\n"
    "  #else\n"
    "  float shadowMapSample = textureCube(shadowSampler, directionToLight).x;\n"
    "  #endif\n"
    "\n"
    "  float esm = clamp(exp(min(87., -depthScale * (shadowPixelDepth - shadowMapSample))), darkness, 1.);\n"
    "\n"
    "  return esm;\n"
    "  }\n"
    "\n"
    "  float computeShadow(vec4 vPositionFromLight, float depthMetric, sampler2D shadowSampler, float darkness)\n"
    "  {\n"
    "  vec3 clipSpace = vPositionFromLight.xyz / vPositionFromLight.w;\n"
    "  clipSpace = 0.5 * clipSpace + vec3(0.5);\n"
    "  vec2 uv = clipSpace.xy;\n"
    "\n"
    "  if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n"
    "  {\n"
    "  return 1.0;\n"
    "  }\n"
    "\n"
    "  float shadowPixelDepth = clamp(depthMetric, 0., 1.0);\n"
    "\n"
    "  #ifndef SHADOWFLOAT\n"
    "  float shadow = unpack(texture2D(shadowSampler, uv));\n"
    "  #else\n"
    "  float shadow = texture2D(shadowSampler, uv).x;\n"
    "  #endif\n"
    "\n"
    "  if (shadowPixelDepth > shadow)\n"
    "  {\n"
    "  return darkness;\n"
    "  }\n"
    "  return 1.;\n"
    "  }\n"
    "\n"
    "  float computeShadowWithPCF(vec4 vPositionFromLight, float depthMetric, sampler2D shadowSampler, float mapSize, float darkness)\n"
    "  {\n"
    "  vec3 clipSpace = vPositionFromLight.xyz / vPositionFromLight.w;\n"
    "  clipSpace = 0.5 * clipSpace + vec3(0.5);\n"
    "  vec2 uv = clipSpace.xy;\n"
    "\n"
    "  if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n"
    "  {\n"
    "  return 1.0;\n"
    "  }\n"
    "\n"
    "  float shadowPixelDepth = clamp(depthMetric, 0., 1.0);\n"
    "\n"
    "  float visibility = 1.;\n"
    "\n"
    "  vec2 poissonDisk[4];\n"
    "  poissonDisk[0] = vec2(-0.94201624, -0.39906216);\n"
    "  poissonDisk[1] = vec2(0.94558609, -0.76890725);\n"
    "  poissonDisk[2] = vec2(-0.094184101, -0.92938870);\n"
    "  poissonDisk[3] = vec2(0.34495938, 0.29387760);\n"
    "\n"
    "  // Poisson Sampling\n"
    "\n"
    "  #ifndef SHADOWFLOAT\n"
    "  if (unpack(texture2D(shadowSampler, uv + poissonDisk[0] * mapSize)) < shadowPixelDepth) visibility -= 0.25;\n"
    "  if (unpack(texture2D(shadowSampler, uv + poissonDisk[1] * mapSize)) < shadowPixelDepth) visibility -= 0.25;\n"
    "  if (unpack(texture2D(shadowSampler, uv + poissonDisk[2] * mapSize)) < shadowPixelDepth) visibility -= 0.25;\n"
    "  if (unpack(texture2D(shadowSampler, uv + poissonDisk[3] * mapSize)) < shadowPixelDepth) visibility -= 0.25;\n"
    "  #else\n"
    "  if (texture2D(shadowSampler, uv + poissonDisk[0] * mapSize).x < shadowPixelDepth) visibility -= 0.25;\n"
    "  if (texture2D(shadowSampler, uv + poissonDisk[1] * mapSize).x < shadowPixelDepth) visibility -= 0.25;\n"
    "  if (texture2D(shadowSampler, uv + poissonDisk[2] * mapSize).x < shadowPixelDepth) visibility -= 0.25;\n"
    "  if (texture2D(shadowSampler, uv + poissonDisk[3] * mapSize).x < shadowPixelDepth) visibility -= 0.25;\n"
    "  #endif\n"
    "\n"
    "  return  min(1.0, visibility + darkness);\n"
    "  }\n"
    "\n"
    "  float computeShadowWithESM(vec4 vPositionFromLight, float depthMetric, sampler2D shadowSampler, float darkness, float depthScale)\n"
    "  {\n"
    "  vec3 clipSpace = vPositionFromLight.xyz / vPositionFromLight.w;\n"
    "  clipSpace = 0.5 * clipSpace + vec3(0.5);\n"
    "  vec2 uv = clipSpace.xy;\n"
    "\n"
    "  if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n"
    "  {\n"
    "  return 1.0;\n"
    "  }\n"
    "\n"
    "  float shadowPixelDepth = clamp(depthMetric, 0., 1.0);\n"
    "\n"
    "  #ifndef SHADOWFLOAT\n"
    "  float shadowMapSample = unpack(texture2D(shadowSampler, uv));\n"
    "  #else\n"
    "  float shadowMapSample = texture2D(shadowSampler, uv).x;\n"
    "  #endif\n"
    "  \n"
    "  float esm = 1.0 - clamp(exp(min(87., depthScale * shadowPixelDepth)) * shadowMapSample, 0., 1. - darkness);\n"
    "\n"
    "  // Apply fade out at frustum edge\n"
    "  // const float fadeDistance = 0.07;\n"
    "  // vec2 cs2 = clipSpace.xy * clipSpace.xy; //squarish falloff\n"
    "  // float mask = smoothstep(1.0, 1.0 - fadeDistance, dot(cs2, cs2));\n"
    "\n"
    "  // esm = mix(1.0, esm, mask);\n"
    "\n"
    "  return esm;\n"
    "  }\n"
    "\n"
    "  float computeShadowWithCloseESM(vec4 vPositionFromLight, float depthMetric, sampler2D shadowSampler, float darkness, float depthScale)\n"
    "  {\n"
    "  vec3 clipSpace = vPositionFromLight.xyz / vPositionFromLight.w;\n"
    "  clipSpace = 0.5 * clipSpace + vec3(0.5);\n"
    "  vec2 uv = clipSpace.xy;\n"
    "\n"
    "  if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n"
    "  {\n"
    "  return 1.0;\n"
    "  }\n"
    "\n"
    "  float shadowPixelDepth = clamp(depthMetric, 0., 1.0);  \n"
    "  \n"
    "  #ifndef SHADOWFLOAT\n"
    "  float shadowMapSample = unpack(texture2D(shadowSampler, uv));\n"
    "  #else\n"
    "  float shadowMapSample = texture2D(shadowSampler, uv).x;\n"
    "  #endif\n"
    "  \n"
    "  float esm = clamp(exp(min(87., -depthScale * (shadowPixelDepth - shadowMapSample))), darkness, 1.);\n"
    "\n"
    "  // Apply fade out at frustum edge\n"
    "  // const float fadeDistance = 0.07;\n"
    "  // vec2 cs2 = clipSpace.xy * clipSpace.xy; //squarish falloff\n"
    "  // float mask = smoothstep(1.0, 1.0 - fadeDistance, dot(cs2, cs2));\n"
    "\n"
    "  // esm = mix(1.0, esm, mask);\n"
    "\n"
    "  return esm;\n"
    "  }\n"
    "#endif\n";

} // end of namespace BABYLON

#endif // end of BABYLON_SHADERS_SHADERS_INCLUDE_SHADOWS_FRAGMENT_FUNCTIONS_FX_H
