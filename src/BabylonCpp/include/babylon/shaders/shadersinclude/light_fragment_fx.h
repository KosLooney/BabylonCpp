#ifndef BABYLON_SHADERS_SHADERS_INCLUDE_LIGHT_FRAGMENT_FX_H
#define BABYLON_SHADERS_SHADERS_INCLUDE_LIGHT_FRAGMENT_FX_H

namespace BABYLON {

extern const char* lightFragment;

const char* lightFragment
  = "#ifdef LIGHT{X}\n"
    "  #if defined(SHADOWONLY) || (defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X}))\n"
    "  //No light calculation\n"
    "  #else\n"
    "  #ifdef PBR\n"
    "  // Compute Pre Lighting infos\n"
    "  #ifdef SPOTLIGHT{X}\n"
    "  preInfo = computePointAndSpotPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n"
    "  #elif defined(POINTLIGHT{X})\n"
    "  preInfo = computePointAndSpotPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n"
    "  #elif defined(HEMILIGHT{X})\n"
    "  preInfo = computeHemisphericPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n"
    "  #elif defined(DIRLIGHT{X})\n"
    "  preInfo = computeDirectionalPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n"
    "  #endif\n"
    "\n"
    "  preInfo.NdotV = NdotV;\n"
    "\n"
    "  // Compute Attenuation infos\n"
    "  #ifdef SPOTLIGHT{X}\n"
    "  #ifdef LIGHT_FALLOFF_GLTF{X}\n"
    "  preInfo.attenuation = computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared, light{X}.vLightFalloff.y);\n"
    "  preInfo.attenuation *= computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightFalloff.z, light{X}.vLightFalloff.w);\n"
    "  #elif defined(LIGHT_FALLOFF_PHYSICAL{X})\n"
    "  preInfo.attenuation = computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n"
    "  preInfo.attenuation *= computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightDirection.w);\n"
    "  #elif defined(LIGHT_FALLOFF_STANDARD{X})\n"
    "  preInfo.attenuation = computeDistanceLightFalloff_Standard(preInfo.lightOffset, light{X}.vLightFalloff.x);\n"
    "  preInfo.attenuation *= computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightDirection.w, light{X}.vLightData.w);\n"
    "  #else\n"
    "  preInfo.attenuation = computeDistanceLightFalloff(preInfo.lightOffset, preInfo.lightDistanceSquared, light{X}.vLightFalloff.x, light{X}.vLightFalloff.y);\n"
    "  preInfo.attenuation *= computeDirectionalLightFalloff(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightDirection.w, light{X}.vLightData.w, light{X}.vLightFalloff.z, light{X}.vLightFalloff.w);\n"
    "  #endif\n"
    "  #elif defined(POINTLIGHT{X})\n"
    "  #ifdef LIGHT_FALLOFF_GLTF{X}\n"
    "  preInfo.attenuation = computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared, light{X}.vLightFalloff.y);\n"
    "  #elif defined(LIGHT_FALLOFF_PHYSICAL{X})\n"
    "  preInfo.attenuation = computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n"
    "  #elif defined(LIGHT_FALLOFF_STANDARD{X})\n"
    "  preInfo.attenuation = computeDistanceLightFalloff_Standard(preInfo.lightOffset, light{X}.vLightFalloff.x);\n"
    "  #else\n"
    "  preInfo.attenuation = computeDistanceLightFalloff(preInfo.lightOffset, preInfo.lightDistanceSquared, light{X}.vLightFalloff.x, light{X}.vLightFalloff.y);\n"
    "  #endif\n"
    "  #else\n"
    "  preInfo.attenuation = 1.0;\n"
    "  #endif\n"
    "\n"
    "  // Simulates Light radius for diffuse and spec term\n"
    "  // clear coat is using a dedicated roughness\n"
    "  #ifdef HEMILIGHT{X}\n"
    "  preInfo.roughness = roughness;\n"
    "  #else\n"
    "  preInfo.roughness = adjustRoughnessFromLightProperties(roughness, light{X}.vLightDiffuse.a, preInfo.lightDistance);\n"
    "  #endif\n"
    "\n"
    "  // Diffuse contribution\n"
    "  #ifdef HEMILIGHT{X}\n"
    "  info.diffuse = computeHemisphericDiffuseLighting(preInfo, light{X}.vLightDiffuse.rgb, light{X}.vLightGround);\n"
    "  #elif defined(SS_TRANSLUCENCY)\n"
    "  info.diffuse = computeDiffuseAndTransmittedLighting(preInfo, light{X}.vLightDiffuse.rgb, transmittance);\n"
    "  #else\n"
    "  info.diffuse = computeDiffuseLighting(preInfo, light{X}.vLightDiffuse.rgb);\n"
    "  #endif\n"
    "\n"
    "  // Specular contribution\n"
    "  #ifdef SPECULARTERM\n"
    "  #ifdef ANISOTROPIC\n"
    "  info.specular = computeAnisotropicSpecularLighting(preInfo, viewDirectionW, normalW, anisotropicTangent, anisotropicBitangent, anisotropy, specularEnvironmentR0, specularEnvironmentR90, AARoughnessFactors.x, light{X}.vLightDiffuse.rgb);\n"
    "  #else\n"
    "  info.specular = computeSpecularLighting(preInfo, normalW, specularEnvironmentR0, specularEnvironmentR90, AARoughnessFactors.x, light{X}.vLightDiffuse.rgb);\n"
    "  #endif\n"
    "  #endif\n"
    "\n"
    "  // Sheen contribution\n"
    "  #ifdef SHEEN\n"
    "  #ifdef SHEEN_LINKWITHALBEDO\n"
    "  // BE Carefull: Sheen intensity is replacing the roughness value.\n"
    "  preInfo.roughness = sheenIntensity;\n"
    "  #endif\n"
    "  info.sheen = computeSheenLighting(preInfo, normalW, sheenColor, specularEnvironmentR90, AARoughnessFactors.x, light{X}.vLightDiffuse.rgb);\n"
    "  #endif\n"
    "\n"
    "  // Clear Coat contribution\n"
    "  #ifdef CLEARCOAT\n"
    "  // Simulates Light radius\n"
    "  #ifdef HEMILIGHT{X}\n"
    "  preInfo.roughness = clearCoatRoughness;\n"
    "  #else\n"
    "  preInfo.roughness = adjustRoughnessFromLightProperties(clearCoatRoughness, light{X}.vLightDiffuse.a, preInfo.lightDistance);\n"
    "  #endif\n"
    "\n"
    "  info.clearCoat = computeClearCoatLighting(preInfo, clearCoatNormalW, clearCoatAARoughnessFactors.x, clearCoatIntensity, light{X}.vLightDiffuse.rgb);\n"
    "  \n"
    "  #ifdef CLEARCOAT_TINT\n"
    "  // Absorption\n"
    "  absorption = computeClearCoatLightingAbsorption(clearCoatNdotVRefract, preInfo.L, clearCoatNormalW, clearCoatColor, clearCoatThickness, clearCoatIntensity);\n"
    "  info.diffuse *= absorption;\n"
    "  #ifdef SPECULARTERM\n"
    "  info.specular *= absorption;\n"
    "  #endif\n"
    "  #endif\n"
    "\n"
    "  // Apply energy conservation on diffuse and specular term.\n"
    "  info.diffuse *= info.clearCoat.w;\n"
    "  #ifdef SPECULARTERM\n"
    "  info.specular *= info.clearCoat.w * info.clearCoat.w;\n"
    "  #endif\n"
    "  #ifdef SHEEN\n"
    "  info.sheen *= info.clearCoat.w * info.clearCoat.w;\n"
    "  #endif\n"
    "  #endif\n"
    "  #else\n"
    "  #ifdef SPOTLIGHT{X}\n"
    "  info = computeSpotLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDirection, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular, light{X}.vLightDiffuse.a, glossiness);\n"
    "  #elif defined(HEMILIGHT{X})\n"
    "  info = computeHemisphericLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular, light{X}.vLightGround, glossiness);\n"
    "  #elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\n"
    "  info = computeLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular, light{X}.vLightDiffuse.a, glossiness);\n"
    "  #endif\n"
    "  #endif\n"
    "\n"
    "  #ifdef PROJECTEDLIGHTTEXTURE{X}\n"
    "  info.diffuse *= computeProjectionTextureDiffuseLighting(projectionLightSampler{X}, textureProjectionMatrix{X});\n"
    "  #endif\n"
    "  #endif\n"
    "\n"
    "  #ifdef SHADOW{X}\n"
    "  #ifdef SHADOWCLOSEESM{X}\n"
    "  #if defined(SHADOWCUBE{X})\n"
    "  shadow = computeShadowWithCloseESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\n"
    "  #else\n"
    "  shadow = computeShadowWithCloseESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\n"
    "  #endif\n"
    "  #elif defined(SHADOWESM{X})\n"
    "  #if defined(SHADOWCUBE{X})\n"
    "  shadow = computeShadowWithESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\n"
    "  #else\n"
    "  shadow = computeShadowWithESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\n"
    "  #endif\n"
    "  #elif defined(SHADOWPOISSON{X})\n"
    "  #if defined(SHADOWCUBE{X})\n"
    "  shadow = computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.depthValues);\n"
    "  #else\n"
    "  shadow = computeShadowWithPoissonSampling(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n"
    "  #endif\n"
    "  #elif defined(SHADOWPCF{X})\n"
    "  #if defined(SHADOWLOWQUALITY{X})\n"
    "  shadow = computeShadowWithPCF1(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n"
    "  #elif defined(SHADOWMEDIUMQUALITY{X})\n"
    "  shadow = computeShadowWithPCF3(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n"
    "  #else\n"
    "  shadow = computeShadowWithPCF5(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n"
    "  #endif\n"
    "  #elif defined(SHADOWPCSS{X})\n"
    "  #if defined(SHADOWLOWQUALITY{X})\n"
    "  shadow = computeShadowWithPCSS16(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n"
    "  #elif defined(SHADOWMEDIUMQUALITY{X})\n"
    "  shadow = computeShadowWithPCSS32(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n"
    "  #else\n"
    "  shadow = computeShadowWithPCSS64(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n"
    "  #endif\n"
    "  #else\n"
    "  #if defined(SHADOWCUBE{X})\n"
    "  shadow = computeShadowCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.depthValues);\n"
    "  #else\n"
    "  shadow = computeShadow(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n"
    "  #endif\n"
    "  #endif\n"
    "\n"
    "  #ifdef SHADOWONLY\n"
    "  #ifndef SHADOWINUSE\n"
    "  #define SHADOWINUSE\n"
    "  #endif\n"
    "  globalShadow += shadow;\n"
    "  shadowLightCount += 1.0;\n"
    "  #endif\n"
    "  #else\n"
    "  shadow = 1.;\n"
    "  #endif\n"
    "\n"
    "  #ifndef SHADOWONLY\n"
    "  #ifdef CUSTOMUSERLIGHTING\n"
    "  diffuseBase += computeCustomDiffuseLighting(info, diffuseBase, shadow);\n"
    "  #ifdef SPECULARTERM\n"
    "  specularBase += computeCustomSpecularLighting(info, specularBase, shadow);\n"
    "  #endif\n"
    "  #elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\n"
    "  diffuseBase += lightmapColor * shadow;\n"
    "  #ifdef SPECULARTERM\n"
    "  #ifndef LIGHTMAPNOSPECULAR{X}\n"
    "  specularBase += info.specular * shadow * lightmapColor;\n"
    "  #endif\n"
    "  #endif\n"
    "  #ifdef CLEARCOAT\n"
    "  #ifndef LIGHTMAPNOSPECULAR{X}\n"
    "  clearCoatBase += info.clearCoat.rgb * shadow * lightmapColor;\n"
    "  #endif\n"
    "  #endif\n"
    "  #ifdef SHEEN\n"
    "  #ifndef LIGHTMAPNOSPECULAR{X}\n"
    "  sheenBase += info.sheen.rgb * shadow;\n"
    "  #endif\n"
    "  #endif\n"
    "  #else\n"
    "  diffuseBase += info.diffuse * shadow;\n"
    "  #ifdef SPECULARTERM\n"
    "  specularBase += info.specular * shadow;\n"
    "  #endif\n"
    "  #ifdef CLEARCOAT\n"
    "  clearCoatBase += info.clearCoat.rgb * shadow;\n"
    "  #endif\n"
    "  #ifdef SHEEN\n"
    "  sheenBase += info.sheen.rgb * shadow;\n"
    "  #endif\n"
    "  #endif\n"
    "  #endif\n"
    "#endif\n";

} // end of namespace BABYLON

#endif // end of BABYLON_SHADERS_SHADERS_INCLUDE_LIGHT_FRAGMENT_FX_H
