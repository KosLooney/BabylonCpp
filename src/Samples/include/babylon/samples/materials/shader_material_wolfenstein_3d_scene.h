#ifndef BABYLON_SAMPLES_MATERIALS_SHADER_MATERIAL_WOLFENSTEIN_3D_SCENE_H
#define BABYLON_SAMPLES_MATERIALS_SHADER_MATERIAL_WOLFENSTEIN_3D_SCENE_H

#include <babylon/interfaces/irenderable_scene.h>

namespace BABYLON {
namespace Samples {

class ShaderMaterialWolfenstein3DScene : public IRenderableScene {

public:
  /** Vertex Shader **/
  static constexpr const char* customVertexShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Attributes\n"
      "attribute vec3 position;\n"
      "attribute vec2 uv;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "\n"
      "// Varying\n"
      "varying vec2 vUV;\n"
      "\n"
      "void main(void) {\n"
      "    gl_Position = worldViewProjection * vec4(position, 1.0);\n"
      "    vUV = uv;\n"
      "}\n";

  /** Pixel (Fragment) Shader **/
  // Wolfenstein 3D ( https://www.shadertoy.com/view/4sfGWX )
  static constexpr const char* customFragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float iTime;\n"
      "uniform float aspectRatio;\n"
      "\n"
      "// Wolfenstein. Created by Reinder Nijhoff 2013\n"
      "// @reindernijhoff\n"
      "//\n"
      "// https://www.shadertoy.com/view/4sfGWX\n"
      "//\n"
      "\n"
      "#define NUM_MATERIALS 3\n"
      "#define NUM_OBJECTS 1\n"
      "#define SECONDS_IN_ROOM 3.\n"
      "#define ROOM_SIZE 10.\n"
      "#define MAXSTEPS 17\n"
      "#define MATERIAL_DOOR 200\n"
      "#define MATERIAL_DOORWAY 201\n"
      "\n"
      "#define COL(r, g, b) vec3(r / 255., g / 255., b / 255.)\n"
      "\n"
      "#define time (iTime + 40.)\n"
      "    vec3 rdcenter;\n"
      "\n"
      "//--------------------------------------------------------------------\n"
      "// Math functions\n"
      "\n"
      "float hash(const float n) {\n"
      "  return fract(sin(n * 14.1234512) * 51231.545341231);\n"
      "}\n"
      "\n"
      "float hash(const vec2 x) {\n"
      "  float n = dot(x, vec2(14.1432, 1131.15532));\n"
      "  return fract(sin(n) * 51231.545341231);\n"
      "}\n"
      "\n"
      "float crossp(const vec2 a, const vec2 b) {\n"
      "  return a.x * b.y - a.y * b.x;\n"
      "}\n"
      "\n"
      "vec3 rotate(vec3 r, float v) {\n"
      "  return vec3(r.x * cos(v) + r.z * sin(v),\n"
      "              r.y,\n"
      "              r.z * cos(v) - r.x * sin(v));\n"
      "}\n"
      "\n"
      "bool intersectSegment(const vec3 ro, const vec3 rd,\n"
      "                      const vec2 a, const vec2 b,\n"
      "                      out float dist, out float u) {\n"
      "  vec2 p = ro.xz;\n"
      "  vec2 r = rd.xz;\n"
      "  vec2 q = a - p;\n"
      "  vec2 s = b - a;\n"
      "  float rCrossS = crossp(r, s);\n"
      "\n"
      "  if (rCrossS == 0.) {\n"
      "    return false;\n"
      "  }\n"
      "  dist = crossp(q, s) / rCrossS;\n"
      "  u = crossp(q, r) / rCrossS;\n"
      "\n"
      "  if (0. <= dist && 0. <= u && u <= 1.) {\n"
      "    return true;\n"
      "  }\n"
      "  return false;\n"
      "}\n"
      "\n"
      "//--------------------------------------------------------------------\n"
      "// Material helper functions\n"
      "\n"
      "float onCircle(const vec2 c, const vec2 centre, const float radius) {\n"
      "  return clamp(4. * (radius - distance(c, centre)), 0., 1.);\n"
      "}\n"
      "\n"
      "float onCircleLine(const vec2 c, const vec2 centre,\n"
      "                   const float radius) {\n"
      "  return clamp(1. - 1.5 * abs(radius - distance(c, centre)), 0., 1.);\n"
      "}\n"
      "\n"
      "float onLine(const float c, const float b) {\n"
      "  return clamp(1. - abs(b - c), 0., 1.);\n"
      "}\n"
      "\n"
      "float onBand(const float c, const float mi, const float ma) {\n"
      "  return clamp((ma - c + 1.), 0., 1.) * clamp((c - mi + 1.), 0., 1.);\n"
      "}\n"
      "\n"
      "float onLineSegmentX(const vec2 c, const float b, const float mi,\n"
      "                     const float ma) {\n"
      "  return onLine(c.x, b) * onBand(c.y, mi, ma);\n"
      "}\n"
      "\n"
      "float onLineSegmentY(const vec2 c, const float b, const float mi,\n"
      "                     const float ma) {\n"
      "  return onLine(c.y, b) * onBand(c.x, mi, ma);\n"
      "}\n"
      "\n"
      "float onRect(const vec2 c, const vec2 lt, const vec2 rb) {\n"
      "  return onBand(c.x, lt.x, rb.x) * onBand(c.y, lt.y, rb.y);\n"
      "}\n"
      "\n"
      "vec3 addBevel(const vec2 c, const vec2 lt,\n"
      "              const vec2 rb, const float size,\n"
      "              const float strength, const float lil, const float lit,\n"
      "              const vec3 col) {\n"
      "  float xl = clamp((c.x - lt.x) / size, 0., 1.);\n"
      "  float xr = clamp((rb.x - c.x) / size, 0., 1.);\n"
      "  float yt = clamp((c.y - lt.y) / size, 0., 1.);\n"
      "  float yb = clamp((rb.y - c.y) / size, 0., 1.);\n"
      "\n"
      "  return mix(\n"
      "      col,\n"
      "      col * clamp(1.0 + strength * (lil * (xl - xr) +\n"
      "                  lit * (yb - yt)), 0., 2.),\n"
      "      onRect(c, lt, rb));\n"
      "}\n"
      "\n"
      "vec3 addKnob(const vec2 c, const vec2 centre, const float radius,\n"
      "             const float strength, const vec3 col) {\n"
      "  vec2 lv = normalize(centre - c);\n"
      "  return mix(col,\n"
      "             col * (1.0 + strength * dot(lv, vec2(-0.7071, 0.7071))),\n"
      "             onCircle(c, centre, radius));\n"
      "}\n"
      "\n"
      "float stepeq(float a, float b) { return step(a, b) * step(b, a); }\n"
      "\n"
      "//--------------------------------------------------------------------\n"
      "// Generate materials!\n"
      "\n"
      "void getMaterialColor(const int material, in vec2 uv,\n"
      "                      const float decorationHash, out vec3 col) {\n"
      "  vec3 fgcol;\n"
      "\n"
      "  uv = floor(mod(uv + 64., vec2(64.)));\n"
      "  vec2 uvs = uv / 64.;\n"
      "\n"
      "  // basecolor\n"
      "  vec3 basecol = vec3(mix(55. / 255., 84. / 255., uvs.y));\n"
      "  float br = hash(uv);\n"
      "  col = basecol;\n"
      "  // grey bricks\n"
      "  if (material == 0 || material == 1) {\n"
      "    vec2 buv = vec2(mod(uv.x + 1. + (floor((uv.y + 1.) / 16.) * 16.),\n"
      "                        32.),\n"
      "                    mod(uv.y + 1., 16.));\n"
      "    float bbr = mix(190. / 255., 91. / 255.,\n"
      "                    (buv.y) / 14.) + 0.05 * br;\n"
      "    if (buv.x < 2. || buv.y < 2.) {\n"
      "      bbr = 72. / 255.;\n"
      "    }\n"
      "    col = vec3(bbr * 0.95);\n"
      "    col = addBevel(buv, vec2(1., 1.), vec2(31.5, 15.),\n"
      "                   2., 0.35, 1., 1., col);\n"
      "    // blue wall\n"
      "    if (material == 1) {\n"
      "      col *= 1.3 * COL(11., 50., 209.);\n"
      "      col = mix(col, COL(2., 15., 86.), onBand(uv.y, 14., 49.));\n"
      "      col = mix(col, COL(9., 44., 185.) * (0.9 + 0.1 * br),\n"
      "                onBand(uv.y, 16., 47.));\n"
      "      col = mix(col, COL(3., 25., 122.), onBand(uv.y, 21., 42.));\n"
      "      col = addBevel(uv, vec2(-1., 16.), vec2(65., 21.),\n"
      "                     1., 0.35, 1., 1., col);\n"
      "      col = addBevel(uv, vec2(-1., 43.), vec2(65., 48.),\n"
      "                     1., 0.35, 1., 1., col);\n"
      "\n"
      "      col = mix(col, COL(2., 11., 74.),\n"
      "                onRect(uv, vec2(22., 22.), vec2(42., 42.)));\n"
      "      col = mix(col, COL(9., 44., 185.) * (0.95 + 0.1 * br),\n"
      "                onRect(uv, vec2(22., 23.), vec2(42., 40.)));\n"
      "      col = addBevel(uv, vec2(22., 23.), vec2(42., 40.),\n"
      "                     1., 0.2, -1., 1., col);\n"
      "      col = mix(col,\n"
      "                mix(COL(2., 11., 74.), COL(3., 25., 122.),\n"
      "                    (uv.x - 26.) / 3.),\n"
      "                onRect(uv, vec2(26., 23.), vec2(29., 29.)));\n"
      "      col = mix(col,\n"
      "                mix(COL(2., 11., 74.), COL(3., 25., 122.),\n"
      "                    (uv.y - 34.) / 2.),\n"
      "                onRect(uv, vec2(22., 34.), vec2(29., 36.)));\n"
      "      col = mix(col,\n"
      "                mix(COL(2., 11., 74.), COL(3., 25., 122.),\n"
      "                    (uv.y - 27.) / 2.),\n"
      "                onRect(uv, vec2(35., 27.), vec2(42., 29.)));\n"
      "      col = mix(col,\n"
      "                mix(COL(2., 11., 74.), COL(3., 25., 122.),\n"
      "                    (uv.y - 34.) / 8.),\n"
      "                onRect(uv, vec2(35., 34.), vec2(38., 42.)));\n"
      "    }\n"
      "  }\n"
      "  // wooden wall\n"
      "  else if (material == 2) {\n"
      "    float mx = mod(uv.x, 64. / 5.);\n"
      "    float h1 = hash(floor(uv.x / (64. / 5.)));\n"
      "    float h2 = hash(1. + 1431.16 * floor(uv.x / (64. / 5.)));\n"
      "    col = mix(\n"
      "        COL(115., 75., 43.), COL(71., 56., 26.),\n"
      "        smoothstep(0.2, 1.,\n"
      "                   (0.7 + h2) *\n"
      "                       abs(mod(h2 - uv.y * (0.05 + 0.1 * h2) +\n"
      "                                   (1. + h1 + h2) * sin(mx *\n"
      "                                       (0.1 + 0.2 * h2)),\n"
      "                               2.) -\n"
      "                           1.)));\n"
      "\n"
      "    col = mix(col, mix(COL(40., 31., 13.), COL(142., 91., 56.),\n"
      "             (uv.x) / 2.), step(uv.x, 2.));\n"
      "    col = mix(col,\n"
      "              mix(COL(40., 31., 13.), COL(142., 91., 56.),\n"
      "                  (uv.x - 10.) / 2.),\n"
      "              step(10., uv.x) * step(uv.x, 12.));\n"
      "    col = mix(col,\n"
      "              mix(COL(40., 31., 13.), COL(142., 91., 56.),\n"
      "                  (uv.x - 26.) / 2.),\n"
      "              step(26., uv.x) * step(uv.x, 28.));\n"
      "    col = mix(col,\n"
      "              mix(COL(40., 31., 13.), COL(142., 91., 56.),\n"
      "                  (uv.x - 40.) / 2.),\n"
      "              step(40., uv.x) * step(uv.x, 42.));\n"
      "    col = mix(col,\n"
      "              mix(COL(40., 31., 13.), COL(142., 91., 56.),\n"
      "                  (uv.x - 54.) / 2.),\n"
      "              step(54., uv.x) * step(uv.x, 56.));\n"
      "\n"
      "    col = mix(col, mix(COL(83., 60., 31.), COL(142., 91., 56.),\n"
      "              (uv.x - 8.)), step(8., uv.x) * step(uv.x, 9.));\n"
      "    col = mix(col, mix(COL(83., 60., 31.), COL(142., 91., 56.),\n"
      "              (uv.x - 24.)), step(24., uv.x) * step(uv.x, 25.));\n"
      "    col = mix(col, mix(COL(83., 60., 31.), COL(142., 91., 56.),\n"
      "              (uv.x - 38.)), step(38., uv.x) * step(uv.x, 39.));\n"
      "    col = mix(col, mix(COL(83., 60., 31.), COL(142., 91., 56.),\n"
      "              (uv.x - 52.)), step(52., uv.x) * step(uv.x, 53.));\n"
      "    col = mix(col, mix(COL(83., 60., 31.), COL(142., 91., 56.),\n"
      "              (uv.x - 62.)), step(62., uv.x));\n"
      "\n"
      "    col = mix(col, mix(COL(40., 31., 13.), COL(142., 91., 56.),\n"
      "              (uv.y) / 2.), step(uv.y, 2.));\n"
      "    col *= 1. - 0.3 * stepeq(uv.y, 3.);\n"
      "  }\n"
      "  // door\n"
      "  else if (material == MATERIAL_DOOR) {\n"
      "    fgcol = COL(44., 176., 175.) *\n"
      "            (0.95 +\n"
      "             0.15 * sin(-0.25 + 4. * ((-0.9 - uvs.y) /\n"
      "                        (1.3 - 0.8 * uvs.x))));\n"
      "    fgcol =\n"
      "        addBevel(uv, vec2(-1., 1.), vec2(62., 66.),\n"
      "                 2., 0.4, -1., -1., fgcol);\n"
      "    fgcol =\n"
      "        addBevel(uv, vec2(6., 6.), vec2(57., 57.),\n"
      "                 2.25, 0.5, -1., -1., fgcol);\n"
      "    fgcol = mix(addKnob(mod(uv, vec2(8.)), vec2(3.5),\n"
      "                        1.65, 0.5, fgcol), fgcol,\n"
      "                onRect(uv, vec2(6., 6.), vec2(57., 57.)));\n"
      "\n"
      "    // knob\n"
      "    fgcol *= 1. - 0.2 * onRect(uv, vec2(13.5, 28.5),\n"
      "                               vec2(22.5, 44.5));\n"
      "    fgcol = mix(fgcol, mix(COL(44., 44., 44.), COL(152., 152., 152.),\n"
      "                           ((uv.x + (43. - uv.y) - 15.) / 25.)),\n"
      "                onRect(uv, vec2(15., 27.), vec2(24., 43.)));\n"
      "    fgcol =\n"
      "        addBevel(uv, vec2(15., 27.), vec2(24., 43.),\n"
      "                 1., 0.45, 1., 1., fgcol);\n"
      "    fgcol = mix(fgcol,\n"
      "                addKnob(mod(uv, vec2(6.)), vec2(4.25, 5.5),\n"
      "                        1.15, 0.75, fgcol),\n"
      "                onRect(uv, vec2(15., 27.), vec2(24., 43.)));\n"
      "\n"
      "    fgcol *= 1. - 0.5 * onRect(uv, vec2(16.5, 33.5),\n"
      "                               vec2(20.5, 38.5));\n"
      "    fgcol = mix(fgcol, mix(COL(88., 84., 11.), COL(251., 242., 53.),\n"
      "                           ((uv.x + (37. - uv.y) - 18.) / 7.)),\n"
      "                onRect(uv, vec2(18., 33.), vec2(21., 37.)));\n"
      "    fgcol = mix(fgcol, COL(0., 0., 0.),\n"
      "                onRect(uv, vec2(19., 34.), vec2(20., 35.7)));\n"
      "\n"
      "    fgcol *= 1. - 0.2 * onRect(uv, vec2(6.5, 29.5), vec2(10.5, 41.5));\n"
      "    fgcol = mix(fgcol, mix(COL(88., 84., 11.), COL(251., 242., 53.),\n"
      "                           ((uv.x + (40. - uv.y) - 9.) / 13.)),\n"
      "                onRect(uv, vec2(9., 29.), vec2(11., 40.)));\n"
      "    fgcol =\n"
      "        addBevel(uv, vec2(9., 29.), vec2(11., 40.),\n"
      "                 0.75, 0.5, 1., 1., fgcol);\n"
      "\n"
      "    col = mix(basecol, fgcol, onRect(uv, vec2(1., 1.),\n"
      "              vec2(62., 62.)));\n"
      "  }\n"
      "  // doorway\n"
      "  else if (material == MATERIAL_DOORWAY) {\n"
      "    fgcol = COL(44., 176., 175.) *\n"
      "            (0.95 +\n"
      "             0.15 * sin(-0.25 + 4. * ((-0.9 - uvs.y) /\n"
      "             (1.3 - 0.8 * uvs.x))));\n"
      "    vec2 uvhx = vec2(32. - abs(uv.x - 32.), uv.y);\n"
      "    fgcol =\n"
      "        addBevel(uvhx, vec2(-1., 1.), vec2(28., 66.),\n"
      "                 2., 0.4, -1., -1., fgcol);\n"
      "    fgcol = addBevel(uvhx, vec2(6., 6.), vec2(23., 57.),\n"
      "                     2.25, 0.5, -1., -1., fgcol);\n"
      "    fgcol = mix(addKnob(vec2(mod(uvhx.x, 22.), mod(uvhx.y, 28.)),\n"
      "                        vec2(3.5),\n"
      "                        1.65, 0.5, fgcol),\n"
      "                fgcol, onRect(uvhx, vec2(6., 6.), vec2(24., 57.)));\n"
      "    fgcol = mix(fgcol, vec3(0.), onRect(uv, vec2(29., 1.),\n"
      "                vec2(35., 63.)));\n"
      "    col = mix(basecol, fgcol, onRect(uv, vec2(1., 1.),\n"
      "              vec2(62., 62.)));\n"
      "  }\n"
      "\n"
      "  // prison door\n"
      "  if (decorationHash > 0.93 && material < (NUM_MATERIALS + 1)) {\n"
      "    vec4 prisoncoords = vec4(12., 14., 52., 62.);\n"
      "    // shadow\n"
      "    col *= 1. - 0.5 * onRect(uv, vec2(11., 13.), vec2(53., 63.));\n"
      "    // hinge\n"
      "    col = mix(col, COL(72., 72., 72.),\n"
      "              stepeq(uv.x, 53.) * step(mod(uv.y + 2., 25.), 5.) *\n"
      "                  step(13., uv.y));\n"
      "    col = mix(col, COL(100., 100., 100.),\n"
      "              stepeq(uv.x, 53.) * step(mod(uv.y + 1., 25.), 3.) *\n"
      "                  step(13., uv.y));\n"
      "\n"
      "    vec3 pcol = vec3(0.) + COL(100., 100., 100.) *\n"
      "                step(mod(uv.x - 4., 7.), 0.);\n"
      "    pcol += COL(55., 55., 55.) * step(mod(uv.x - 5., 7.), 0.);\n"
      "    pcol = addBevel(uv, vec2(0., 17.), vec2(63., 70.),\n"
      "                    3., 0.8, 0., -1., pcol);\n"
      "    pcol = addBevel(uv, vec2(0., 45.), vec2(22., 70.),\n"
      "                    3., 0.8, 0., -1., pcol);\n"
      "\n"
      "    fgcol = COL(72., 72., 72.);\n"
      "    fgcol = addBevel(uv, prisoncoords.xy, prisoncoords.zw +\n"
      "                     vec2(1., 1.), 1., 0.5, -1., 1., fgcol);\n"
      "    fgcol = addBevel(uv, prisoncoords.xy + vec2(3., 3.),\n"
      "                     prisoncoords.zw - vec2(2., 1.),\n"
      "                     1., 0.5, 1., -1., fgcol);\n"
      "    fgcol = mix(fgcol, pcol, onRect(uv,\n"
      "                                    prisoncoords.xy + vec2(3., 3.),\n"
      "                                    prisoncoords.zw - vec2(3., 2.)));\n"
      "    fgcol = mix(fgcol, COL(72., 72., 72.),\n"
      "                onRect(uv, vec2(15., 32.5), vec2(21., 44.)));\n"
      "\n"
      "    fgcol = mix(fgcol, mix(COL(0., 0., 0.), COL(43., 43., 43.),\n"
      "                (uv.y - 37.)),\n"
      "                stepeq(uv.x, 15.) * step(37., uv.y) * step(uv.y, 38.));\n"
      "    fgcol =\n"
      "        mix(fgcol, mix(COL(0., 0., 0.), COL(43., 43., 43.),\n"
      "            (uv.y - 37.) / 3.),\n"
      "            stepeq(uv.x, 17.) * step(37., uv.y) * step(uv.y, 40.));\n"
      "    fgcol = mix(fgcol, COL(43., 43., 43.),\n"
      "                stepeq(uv.x, 18.) * step(37., uv.y) *\n"
      "                step(uv.y, 41.));\n"
      "    fgcol = mix(fgcol,\n"
      "                mix(COL(0., 0., 0.), COL(100., 100., 100.),\n"
      "                (uv.y - 37.) / 3.),\n"
      "                stepeq(uv.x, 18.) * step(36., uv.y) *\n"
      "                step(uv.y, 40.));\n"
      "    fgcol = mix(fgcol, COL(43., 43., 43.),\n"
      "                stepeq(uv.x, 19.) * step(37., uv.y) *\n"
      "                step(uv.y, 40.));\n"
      "\n"
      "    fgcol = mix(fgcol, mix(COL(84., 84., 84.), COL(108., 108., 108.),\n"
      "                           (uv.x - 15.) / 2.),\n"
      "                stepeq(uv.y, 32.) * step(15., uv.x) *\n"
      "                step(uv.x, 17.));\n"
      "    fgcol = mix(fgcol, COL(81., 81., 81.),\n"
      "                stepeq(uv.y, 32.) * step(20., uv.x) *\n"
      "                step(uv.x, 21.));\n"
      "\n"
      "    col = mix(col, fgcol, onRect(uv, prisoncoords.xy,\n"
      "                                 prisoncoords.zw));\n"
      "  }\n"
      "  // flag\n"
      "  else if (decorationHash > 0.63 && material < (NUM_MATERIALS + 1)) {\n"
      "    vec2 uvc = uv - vec2(32., 30.);\n"
      "\n"
      "    // shadow\n"
      "    vec4 shadowcoords =\n"
      "        vec4(14., 7., 54., max(56. + sin(uv.x * 0.32 - 1.), 56.));\n"
      "    col *= 1. - 0.3 * onRect(uv, vec2(6., 6.), vec2(61., 7.));\n"
      "    col *= 1. -\n"
      "           0.3 * clamp(0.25 * (56. - uv.x), 0., 1.) *\n"
      "               onRect(uv, shadowcoords.xy, shadowcoords.zw);\n"
      "\n"
      "    // rod\n"
      "    col = mix(col, COL(250., 167., 98.),\n"
      "              onLineSegmentX(vec2(abs(uv.x - 32.), uv.y),\n"
      "              26., 4., 6.5));\n"
      "    col = mix(col, COL(251., 242., 53.),\n"
      "              onLineSegmentY(uv, 5., 4., 60.));\n"
      "    col = mix(col, COL(155., 76., 17.),\n"
      "              onLineSegmentY(uv, 6., 4., 60.));\n"
      "    col = mix(col, COL(202., 96., 25.),\n"
      "              onLineSegmentY(vec2(abs(uv.x - 32.), uv.y),\n"
      "                             6., 26., 28.));\n"
      "    col = mix(col, COL(251., 242., 53.),\n"
      "              onLineSegmentX(vec2(abs(uv.x - 32.), uv.y),\n"
      "                             25., 3., 7.));\n"
      "    col = mix(col, COL(252., 252., 217.),\n"
      "              onLineSegmentX(vec2(abs(uv.x - 32.), uv.y),\n"
      "                             25., 4.3, 5.5));\n"
      "    col = mix(col, COL(252., 252., 217.),\n"
      "              onLineSegmentX(vec2(abs(uv.x - 32.), uv.y),\n"
      "                             26., 5.3, 5.5));\n"
      "    col = mix(col, COL(0., 0., 0.),\n"
      "              onLineSegmentY(vec2(abs(uv.x - 32.), uv.y),\n"
      "                             6., 18.3, 19.5));\n"
      "\n"
      "    // flag\n"
      "    vec4 flagcoords = vec4(13.,\n"
      "                          min(9.5 - pow(5.5 * (uvs.x - 0.5), 2.), 9.),\n"
      "                          51., max(55. + sin(uv.x * 0.4 + 2.7), 55.));\n"
      "\n"
      "    fgcol = COL(249., 41., 27.);\n"
      "\n"
      "    fgcol = mix(fgcol, COL(255., 255., 255.),\n"
      "                onBand(min(abs(uvc.x), abs(uvc.y)), 2., 4.));\n"
      "    fgcol =\n"
      "        mix(fgcol, COL(72., 72., 72.), onLine(min(abs(uvc.x),\n"
      "            abs(uvc.y)), 3.));\n"
      "\n"
      "    fgcol =\n"
      "        mix(fgcol, COL(255., 255., 255.),\n"
      "            onCircle(uv, vec2(32., 30.), 12.5));\n"
      "    fgcol = mix(fgcol, COL(0., 0., 0.),\n"
      "                onCircleLine(uv, vec2(32., 30.), 11.));\n"
      "    fgcol = mix(fgcol, COL(0., 0., 0.),\n"
      "                onCircleLine(uv, vec2(32., 30.), 9.));\n"
      "\n"
      "    vec2 uvr = vec2((uvc.x - uvc.y) * 0.7071,\n"
      "                    (uvc.y + uvc.x) * 0.7071) *\n"
      "               sign(uvc.x + 0.5);\n"
      "    fgcol = mix(fgcol, COL(72., 72., 72.),\n"
      "                onRect(uvr, vec2(-1., -1.), vec2(1., 4.)));\n"
      "    fgcol = mix(fgcol, COL(72., 72., 72.),\n"
      "                onRect(uvr, vec2(-4.2, 4.2), vec2(1., 6.15)));\n"
      "    fgcol = mix(fgcol, COL(72., 72., 72.),\n"
      "                onRect(uvr, vec2(-1., -1.), vec2(4., 1.)));\n"
      "    fgcol = mix(fgcol, COL(72., 72., 72.),\n"
      "                onRect(uvr, vec2(4.2, -1.), vec2(6.15, 4.2)));\n"
      "\n"
      "    fgcol *= (0.8 + 0.2 * sin(uv.x * 0.4 + 2.7));\n"
      "    fgcol *= (0.8 + 0.2 * clamp(0.5 * (uv.y - 7.), 0., 1.));\n"
      "\n"
      "    // mix flag on background\n"
      "    col = mix(col, fgcol, onRect(uv, flagcoords.xy, flagcoords.zw));\n"
      "  }\n"
      "\n"
      "  // fake 8-bit color palette and dithering\n"
      "  col = floor((col + 0.5 * mod(uv.x + uv.y, 2.) / 32.) * 32.) / 32.;\n"
      "}\n"
      "\n"
      "bool getObjectColor(const int object, in vec2 uv, inout vec3 icol) {\n"
      "  uv = floor(mod(uv, vec2(64.)));\n"
      "  vec2 uvs = uv / 64.;\n"
      "  vec3 col = vec3(20. / 255.);\n"
      "  float d;\n"
      "\n"
      "  // only a lamp for now\n"
      "\n"
      "  // lamp top\n"
      "  d = distance(uv * vec2(1., 2.), vec2(28.1, 5.8) * vec2(1., 2.));\n"
      "  col = mix(col, mix(COL(41., 250., 46.), COL(13., 99., 12.),\n"
      "                     clamp(d / 8. - 0.2, 0., 1.)),\n"
      "            onCircle(uv, vec2(31., 13.6), 11.7) * step(uv.y, 6.));\n"
      "  col = mix(col, COL(9., 75., 6.),\n"
      "            onCircleLine(uv, vec2(31., 14.), 11.6) *\n"
      "                step(length(uv - vec2(31., 13.6)), 11.7) *\n"
      "                step(uv.y, 6.));\n"
      "  col = mix(col, COL(100., 100., 100.),\n"
      "            onLine(abs(uv.x - 31.), 1.) * step(uv.y, 1.));\n"
      "  col = mix(col, COL(140., 140., 140.),\n"
      "            onLine(abs(uv.x - 31.), 0.25) * step(uv.y, 1.) *\n"
      "            step(1., uv.y));\n"
      "\n"
      "  // lamp bottom\n"
      "  d = distance(uv * vec2(1., 2.), vec2(30.5, 6.5) * vec2(1., 2.));\n"
      "  col = mix(col, mix(COL(41., 250., 46.), COL(13., 99., 12.),\n"
      "                     clamp(abs(uv.x - 31.) / 4. - 1.25, 0., 1.)),\n"
      "            step(abs(uv.x - 31.), 9.) * stepeq(uv.y, 7.));\n"
      "  col = mix(col, mix(COL(41., 250., 46.), COL(16., 123., 17.),\n"
      "                     clamp(abs(uv.x - 31.) / 4. - 1.25, 0., 1.)),\n"
      "            step(abs(uv.x - 31.), 9.) * stepeq(uv.y, 8.));\n"
      "  col = mix(col, mix(COL(133., 250., 130.), COL(22., 150., 23.),\n"
      "                     clamp(abs(uv.x - 31.) / 4. - 0.75, 0., 1.)),\n"
      "            step(abs(uv.x - 31.), 7.) * stepeq(uv.y, 9.));\n"
      "\n"
      "  col =\n"
      "      mix(col, mix(COL(255., 251., 187.), col,\n"
      "          clamp(d / 4.5 - 0.6, 0., 1.)),\n"
      "          onCircle(uv, vec2(31., 1.), 10.2) * step(uv.y, 8.) *\n"
      "                   step(7., uv.y));\n"
      "  col = mix(col, mix(COL(255., 255., 255.), col,\n"
      "            clamp(d / 4. - 0.7, 0., 1.)),\n"
      "            onCircle(uv, vec2(31., 1.), 7.2) * step(uv.y, 8.) *\n"
      "                     step(7., uv.y));\n"
      "\n"
      "  // floor\n"
      "  d = distance(vec2(mod(uv.x, 32.), uv.y) * vec2(1.5, 30. / 3.),\n"
      "               vec2(16., 61.5) * vec2(1.5, 30. / 3.));\n"
      "  col = mix(col, mix(COL(168., 168., 168.), COL(124., 124., 124.),\n"
      "                     clamp(d / 15. - 0.5, 0., 1.)),\n"
      "            step(d, 24.5));\n"
      "  col = mix(col, mix(COL(124., 124., 124.), COL(140., 140., 140.),\n"
      "                     clamp((uv.y - 59.) / 1., 0., 1.)),\n"
      "            step(59., uv.y) * step(uv.x, 57.) * step(7., uv.x));\n"
      "  col =\n"
      "      mix(col, mix(COL(168., 168., 168.), COL(124., 124., 124.),\n"
      "                   clamp(abs(32. - uv.x) / 10. - 2., 0., 1.)),\n"
      "          step(uv.y, 62.) * step(62., uv.y) * step(uv.x, 61.) *\n"
      "          step(3., uv.x));\n"
      "  col =\n"
      "      mix(col, mix(COL(152., 152., 152.), COL(124., 124., 124.),\n"
      "                   clamp(abs(32. - uv.x) / 10. - 2.25, 0., 1.)),\n"
      "          step(uv.y, 61.) * step(61., uv.y) * step(uv.x, 59.) *\n"
      "          step(5., uv.x));\n"
      "\n"
      "  col = floor((col)*32.) / 32.;\n"
      "  if (any(notEqual(col, vec3(floor((20. / 255.) * 32.) / 32.)))) {\n"
      "    icol = col;\n"
      "    return true;\n"
      "  }\n"
      "  return false;\n"
      "}\n"
      "\n"
      "//--------------------------------------------------------------------\n"
      "// Proocedural MAP functions\n"
      "\n"
      "bool isWall(const vec2 vos) {\n"
      "  return vos.y < 0.4 * ROOM_SIZE || vos.y > 2.75 * ROOM_SIZE ||\n"
      "         any(equal(mod(vos, vec2(ROOM_SIZE)), vec2(0., 0.)));\n"
      "}\n"
      "\n"
      "bool isDoor(const vec2 vos) {\n"
      "  return isWall(vos) &&\n"
      "         ((hash(vos) > 0.75 &&\n"
      "           any(equal(mod(vos, vec2(ROOM_SIZE * 0.5)), vec2(2.)))) ||\n"
      "          any(equal(mod(vos, vec2(ROOM_SIZE)),\n"
      "          vec2(ROOM_SIZE * 0.5))));\n"
      "}\n"
      "\n"
      "bool isObject(const vec2 vos) { return hash(vos * 10.) > 0.95; }\n"
      "\n"
      "bool map(const vec2 vos) { return isObject(vos) || isWall(vos); }\n"
      "\n"
      "//--------------------------------------------------------------------\n"
      "// Render MAP functions\n"
      "\n"
      "bool intersectSprite(const vec3 ro, const vec3 rd, const vec3 vos,\n"
      "                     const vec3 nor, out vec2 uv) {\n"
      "  float dist, u;\n"
      "  vec2 a = vos.xz + nor.zx * vec2(-0.5, 0.5) + vec2(0.5, 0.5);\n"
      "  vec2 b = vos.xz - nor.zx * vec2(-0.5, 0.5) + vec2(0.5, 0.5);\n"
      "  if (intersectSegment(ro, rd, a, b, dist, u)) {\n"
      "    uv.x = u;\n"
      "    uv.y = 1. - (ro + dist * rd).y;\n"
      "    if (sign(nor.x) < 0.)\n"
      "      uv.x = 1. - uv.x;\n"
      "    return uv.y > 0. && uv.y < 1.;\n"
      "  }\n"
      "  return false;\n"
      "}\n"
      "\n"
      "int getMaterialId(const vec2 vos) {\n"
      "  return int(mod(521.21 * hash(floor((vos - vec2(0.5)) / ROOM_SIZE)),\n"
      "                 float(NUM_MATERIALS)));\n"
      "}\n"
      "\n"
      "bool getColorForPosition(const vec3 ro, const vec3 rd, const vec3 vos,\n"
      "                         const vec3 pos, const vec3 nor,\n"
      "                         inout vec3 col) {\n"
      "  vec2 uv;\n"
      "\n"
      "  if (isWall(vos.xz)) {\n"
      "    if (isDoor(vos.xz)) {\n"
      "      if (intersectSprite(ro, rd, vos + nor * 0.03, nor, uv)) {\n"
      "        // open the door\n"
      "        uv.x -= clamp(2. - 0.75 * distance(ro.xz, vos.xz + vec2(0.5)),\n"
      "                                           0., 1.);\n"
      "        if (uv.x > 0.) {\n"
      "          getMaterialColor(MATERIAL_DOOR, uv * 64., 0., col);\n"
      "          return true;\n"
      "        }\n"
      "      }\n"
      "      return false;\n"
      "    }\n"
      "    // a wall is hit\n"
      "    if (pos.y <= 1. && pos.y >= 0.) {\n"
      "      vec2 mpos = vec2(dot(vec3(-nor.z, 0.0, nor.x), pos), -pos.y);\n"
      "      float sha = 0.6 + 0.4 * abs(nor.z);\n"
      "      getMaterialColor(isDoor(vos.xz + nor.xz)\n"
      "                       ? MATERIAL_DOORWAY\n"
      "                       : getMaterialId(vos.xz),\n"
      "                       mpos * 64., hash(vos.xz), col);\n"
      "      col *= sha;\n"
      "      return true;\n"
      "    }\n"
      "    return true;\n"
      "  }\n"
      "  if (isObject(vos.xz) && !isWall(vos.xz + vec2(1., 0.)) &&\n"
      "      !isWall(vos.xz + vec2(-1., 0.)) &&\n"
      "      !isWall(vos.xz + vec2(0., -1.)) &&\n"
      "      !isWall(vos.xz + vec2(0., 1.)) &&\n"
      "      intersectSprite(ro, rd, vos, rdcenter, uv)) {\n"
      "    return getObjectColor(0, uv * 64., col);\n"
      "  }\n"
      "  return false;\n"
      "}\n"
      "\n"
      "bool castRay(const vec3 ro, const vec3 rd, inout vec3 col) {\n"
      "  vec3 pos = floor(ro);\n"
      "  vec3 ri = 1.0 / rd;\n"
      "  vec3 rs = sign(rd);\n"
      "  vec3 dis = (pos - ro + 0.5 + rs * 0.5) * ri;\n"
      "\n"
      "  float res = 0.0;\n"
      "  vec3 mm = vec3(0.0);\n"
      "  bool hit = false;\n"
      "\n"
      "  for (int i = 0; i < MAXSTEPS; i++) {\n"
      "    if (hit)\n"
      "      continue;\n"
      "\n"
      "    mm = step(dis.xyz, dis.zyx);\n"
      "    dis += mm * rs * ri;\n"
      "    pos += mm * rs;\n"
      "\n"
      "    if (map(pos.xz)) {\n"
      "      vec3 mini = (pos - ro + 0.5 - 0.5 * vec3(rs)) * ri;\n"
      "      float t = max(mini.x, mini.z);\n"
      "      hit = getColorForPosition(ro, rd, pos, ro + rd * t,\n"
      "                                -mm * sign(rd), col);\n"
      "    }\n"
      "  }\n"
      "  return hit;\n"
      "}\n"
      "\n"
      "//--------------------------------------------------------------------\n"
      "// Some really ugly code\n"
      "\n"
      "#define CCOS(a) cos(clamp(a, 0., 1.) * 1.57079632679)\n"
      "#define CSIN(a) sin(clamp(a, 0., 1.) * 1.57079632679)\n"
      "vec3 path(const float t) {\n"
      "  float tmod = mod(t / SECONDS_IN_ROOM, 8.);\n"
      "  float tfloor = floor(tmod);\n"
      "\n"
      "  vec3 pos = vec3(4. * ROOM_SIZE * floor(t / (SECONDS_IN_ROOM * 8.)) +\n"
      "                  0.5, 0.5,\n"
      "                  0.5 * ROOM_SIZE + 0.5);\n"
      "  return pos +\n"
      "         ROOM_SIZE *\n"
      "           vec3(clamp(tmod, 0., 1.) + clamp(tmod - 4., 0., 1.) +\n"
      "                     0.5 * (2. + CSIN(tmod - 1.) - CCOS(tmod - 3.) +\n"
      "                                 CSIN(tmod - 5.) - CCOS(tmod - 7.)),\n"
      "                     0.,\n"
      "                     clamp(tmod - 2., 0., 1.) -\n"
      "                     clamp(tmod - 6., 0., 1.) +\n"
      "                           0.5 * (-CCOS(tmod - 1.) + CSIN(tmod - 3.) +\n"
      "                                  CCOS(tmod - 5.) - CSIN(tmod - 7.)));\n"
      "}\n"
      "\n"
      "//--------------------------------------------------------------------\n"
      "// Main\n"
      "\n"
      "void main(void) {\n"
      "  vec2 q = -1.0 + 2.0 * vUV.xy;\n"
      "  vec2 p = -0.5 + 2.0 * q;\n"
      "  p.x *= aspectRatio;\n"
      "\n"
      "  vec3 ro = path(time);\n"
      "  vec3 ta = path(time + 0.1);\n"
      "\n"
      "  rdcenter = rotate(normalize(ta - ro), 0.3 * cos(time * 0.75));\n"
      "  vec3 uu = normalize(cross(vec3(0., 1., 0.), rdcenter));\n"
      "  vec3 vv = normalize(cross(rdcenter, uu));\n"
      "  vec3 rd = normalize(p.x * uu + p.y * vv + 2.5 * rdcenter);\n"
      "\n"
      "  vec3 col = rd.y > 0. ? vec3(56. / 255.) : vec3(112. / 255.);\n"
      "  castRay(ro, rd, col);\n"
      "\n"
      "  gl_FragColor = vec4(col, 1.0);\n"
      "}\n";

public:
  ShaderMaterialWolfenstein3DScene(ICanvas* iCanvas);
  ~ShaderMaterialWolfenstein3DScene();

  const char* getName() override;
  void initializeScene(ICanvas* canvas, Scene* scene) override;

private:
  float _time;
  ShaderMaterial* _shaderMaterial;

}; // end of class ShaderMaterialWolfenstein3DScene

} // end of namespace Samples
} // end of namespace BABYLON

#endif // end of
       // BABYLON_SAMPLES_MATERIALS_SHADER_MATERIAL_WOLFENSTEIN_3D_SCENE_H
