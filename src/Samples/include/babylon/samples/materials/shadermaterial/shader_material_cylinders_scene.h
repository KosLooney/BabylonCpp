#ifndef BABYLON_SAMPLES_MATERIALS_SHADER_MATERIAL_CYLINDERS_SCENE_H
#define BABYLON_SAMPLES_MATERIALS_SHADER_MATERIAL_CYLINDERS_SCENE_H

#include <babylon/interfaces/irenderable_scene.h>

namespace BABYLON {
namespace Samples {

class ShaderMaterialCylindersScene : public IRenderableScene {

public:
  static constexpr const char* customVertexShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Attributes\n"
      "attribute vec3 position;\n"
      "attribute vec3 normal;\n"
      "attribute vec2 uv;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float time;\n"
      "\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "void main(void) {\n"
      "  vec3 v = position;\n"
      "  gl_Position = worldViewProjection * vec4(v, 1.0);\n"
      "  vPosition = position;\n"
      "  vNormal = normal;\n"
      "  vUV = uv;\n"
      "}\n";

  // Mandelbrot - distance ( https://www.shadertoy.com/view/lsX3W4 )
  static constexpr const char* custom1FragmentShader
    = "// Created by inigo quilez - iq/2013\n"
      "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n"
      "// Unported License.\n"
      "//\n"
      "// This shader computes the distance to the Mandelbrot Set for every\n"
      "// pixel, and colorizes it accoringly.\n"
      "//\n"
      "// Z -> Z²+c, Z0 = 0.\n"
      "// therefore Z' -> 2·Z·Z' + 1\n"
      "//\n"
      "// The Hubbard-Douady potential G(c) is G(c) = log Z/2^n\n"
      "// G'(c) = Z'/Z/2^n\n"
      "//\n"
      "// So the distance is |G(c)|/|G'(c)| = |Z|·log|Z|/|Z'|\n"
      "//\n"
      "// More info here:\n"
      "// http://www.iquilezles.org/www/articles/distancefractals/\n"
      "// distancefractals.htm\n"
      "\n"
      "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float time;\n"
      "\n"
      "void main(void) {\n"
      "  vec2 p = -1.0 + 2.0 * vUV.xy;\n"
      "\n"
      "  // animation\n"
      "  float tz = 0.5 - 0.5 * cos(0.225 * time);\n"
      "  float zoo = pow(0.5, 13.0 * tz);\n"
      "  vec2 c = vec2(-0.05, .6805) + p * zoo;\n"
      "\n"
      "  // iterate\n"
      "  float di = 1.0;\n"
      "  vec2 z = vec2(0.0);\n"
      "  float m2 = 0.0;\n"
      "  vec2 dz = vec2(0.0);\n"
      "  for (int i = 0; i < 300; i++) {\n"
      "    if (m2 > 1024.0) {\n"
      "      di = 0.0;\n"
      "      break;\n"
      "    }\n"
      "\n"
      "    // Z' -> 2·Z·Z' + 1\n"
      "    dz = 2.0 * vec2(z.x * dz.x - z.y * dz.y,\n"
      "                    z.x * dz.y + z.y * dz.x)\n"
      "         + vec2(1.0, 0.0);\n"
      "\n"
      "    // Z -> Z² + c\n"
      "    z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n"
      "\n"
      "    m2 = dot(z, z);\n"
      "  }\n"
      "\n"
      "  // distance\n"
      "  // d(c) = |Z|·log|Z|/|Z'|\n"
      "  float d = 0.5 * sqrt(dot(z, z) / dot(dz, dz)) * log(dot(z, z));\n"
      "  if (di > 0.5)\n"
      "    d = 0.0;\n"
      "\n"
      "  // do some soft coloring based on distance\n"
      "  d = clamp(pow(4.0 * d / zoo, 0.2), 0.0, 1.0);\n"
      "\n"
      "  vec3 col = vec3(d);\n"
      "\n"
      "  gl_FragColor = vec4(col, 1.0);\n"
      "}\n";

  // Heart - 2D ( https://www.shadertoy.com/view/XsfGRn )
  static constexpr const char* custom3FragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float time;\n"
      "\n"
      "void main(void) {\n"
      "  vec2 p = -1.0 + 2.0 * vUV.xy;\n"
      "\n"
      "  // background color\n"
      "  vec3 bcol = vec3(1.0, 0.8, 0.7 - 0.07 * p.y)\n"
      "                * (1.0 - 0.25 * length(p));\n"
      "\n"
      "  // animate\n"
      "  float tt = mod(time, 1.5) / 1.5;\n"
      "  float ss = pow(tt, .2) * 0.5 + 0.5;\n"
      "  ss = 1.0 + ss * 0.5 * sin(tt * 6.2831 * 3.0 + p.y * 0.5)\n"
      "           * exp(-tt * 4.0);\n"
      "  p *= vec2(0.5, 1.5) + ss * vec2(0.5, -0.5);\n"
      "\n"
      "  // shape\n"
      "  p *= 0.8;\n"
      "  p.y = -0.1 - p.y * 1.2 + abs(p.x) * (1.0 - abs(p.x));\n"
      "  float r = length(p);\n"
      "  float d = 0.5;\n"
      "\n"
      "  // color\n"
      "  float s = 0.75 + 0.75 * p.x;\n"
      "  s *= 1.0 - 0.4 * r;\n"
      "  s = 0.3 + 0.7 * s;\n"
      "  s *= 0.5 + 0.5 * pow(1.0 - clamp(r / d, 0.0, 1.0), 0.1);\n"
      "  vec3 hcol = vec3(1.0, 0.5 * r, 0.3) * s;\n"
      "\n"
      "  vec3 col = mix(bcol, hcol, smoothstep(-0.01, 0.01, d - r));\n"
      "\n"
      "  gl_FragColor = vec4(col, 1.0);\n"
      "}\n";

  // [SIG2014] - Total Noob ( https://www.shadertoy.com/view/XdlSDs )
  static constexpr const char* custom2FragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float time;\n"
      "\n"
      "void main(void) {\n"
      "  vec2 p = -1.0 + 2.0 * vUV.xy;\n"
      "  float tau = 3.1415926535 * 2.0;\n"
      "  float a = atan(p.x, p.y);\n"
      "  float r = length(p) * 0.75;\n"
      "  vec2 uv = vec2(a / tau, r);\n"
      "\n"
      "  // get the color\n"
      "  float xCol = (uv.x - (time / 3.0)) * 3.0;\n"
      "  xCol = mod(xCol, 3.0);\n"
      "  vec3 horColour = vec3(0.25, 0.25, 0.25);\n"
      "\n"
      "  if (xCol < 1.0) {\n"
      "    horColour.r += 1.0 - xCol;\n"
      "    horColour.g += xCol;\n"
      "  } else if (xCol < 2.0) {\n"
      "    xCol -= 1.0;\n"
      "    horColour.g += 1.0 - xCol;\n"
      "    horColour.b += xCol;\n"
      "  } else {\n"
      "    xCol -= 2.0;\n"
      "    horColour.b += 1.0 - xCol;\n"
      "    horColour.r += xCol;\n"
      "  }\n"
      "\n"
      "  // draw color beam\n"
      "  uv = (2.0 * uv) - 1.0;\n"
      "  float beamWidth =\n"
      "      (0.7 +\n"
      "       0.5 * cos(uv.x * 10.0 * tau * 0.15 *\n"
      "                 clamp(floor(5.0 + 10.0 * cos(time)), 0.0, 10.0))) *\n"
      "      abs(1.0 / (30.0 * uv.y));\n"
      "  vec3 horBeam = vec3(beamWidth);\n"
      "  gl_FragColor = vec4(((horBeam)*horColour), 1.0);\n"
      "}\n";

  // Bubbles ( https://www.shadertoy.com/view/4dl3zn )
  static constexpr const char* custom4FragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float time;\n"
      "\n"
      "void main(void) {\n"
      "  vec2 uv = vUV.xy;\n"
      "\n"
      "  // background\n"
      "  vec3 color = vec3(0.8 + 0.2 * uv.y);\n"
      "\n"
      "  // bubbles\n"
      "  for (int i = 0; i < 40; i++) {\n"
      "    // bubble seeds\n"
      "    float pha = sin(float(i) * 546.13 + 1.0) * 0.5 + 0.5;\n"
      "    float siz = pow(sin(float(i) * 651.74 + 5.0) * 0.5 + 0.5, 4.0);\n"
      "    float pox = sin(float(i) * 321.55 + 4.1);\n"
      "\n"
      "    // buble size, position and color\n"
      "    float rad = 0.1 + 0.5 * siz;\n"
      "    vec2 pos = vec2(pox,\n"
      "                    -1.0 - rad +\n"
      "                        (2.0 + 2.0 * rad) *\n"
      "                            mod(pha + 0.1 * time *\n"
      "                                (0.2 + 0.8 * siz), 1.0));\n"
      "    float dis = length(uv - pos);\n"
      "    vec3 col = mix(vec3(0.94, 0.3, 0.0), vec3(0.1, 0.4, 0.8),\n"
      "                   0.5 + 0.5 * sin(float(i) * 1.2 + 1.9));\n"
      "\n"
      "    // render\n"
      "    float f = length(uv - pos) / rad;\n"
      "    f = sqrt(clamp(1.0 - f * f, 0.0, 1.0));\n"
      "    color -= col.zyx * (1.0 - smoothstep(rad * 0.95, rad, dis)) * f;\n"
      "  }\n"
      "\n"
      "  // vigneting\n"
      "  color *= sqrt(1.5 - 0.5 * length(uv));\n"
      "\n"
      "  gl_FragColor = vec4(color, 1.0);\n"
      "}\n";

  // Basic Fractal ( https://www.shadertoy.com/view/Mss3Wf )
  static constexpr const char* custom5FragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float time;\n"
      "\n"
      "const int maxIterations = 8;\n"
      "\n"
      "float circleSize = 1.0 / (3.0 * pow(2.0, float(maxIterations)));\n"
      "\n"
      "// generic rotation formula\n"
      "vec2 rot(vec2 uv, float a) {\n"
      "  return vec2(uv.x * cos(a) - uv.y * sin(a),\n"
      "              uv.y * cos(a) + uv.x * sin(a));\n"
      "}\n"
      "\n"
      "void main(void) {\n"
      "  // normalize stuff\n"
      "  vec2 uv = -1.0 + 2.0 * vUV.xy;\n"
      "\n"
      "  // global rotation and zoom\n"
      "  uv = rot(uv, time);\n"
      "  uv *= sin(time) * 0.5 + 1.5;\n"
      "\n"
      "  // mirror, rotate and scale 6 times...\n"
      "  float s = 0.3;\n"
      "  for (int i = 0; i < maxIterations; i++) {\n"
      "    uv = abs(uv) - s;\n"
      "    uv = rot(uv, time);\n"
      "    s = s / 2.1;\n"
      "  }\n"
      "\n"
      "  // draw a circle\n"
      "  float c = length(uv) > circleSize ? 0.0 : 1.0;\n"
      "\n"
      "  gl_FragColor = vec4(c, c, c, 1.0);\n"
      "}\n";

  // Iterations - inversion ( https://www.shadertoy.com/view/XdXGDS )
  static constexpr const char* custom6FragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float time;\n"
      "\n"
      "void main(void) {\n"
      "  vec2 uv = vUV.xy;\n"
      "\n"
      "  // shape (16 points)\n"
      "  float iTime = time + 47.0;\n"
      "  vec2 z = -1.0 + 2.0 * uv;\n"
      "  vec3 col = vec3(1.0);\n"
      "  for (int j = 0; j < 16; j++) {\n"
      "    // deform\n"
      "    float s = float(j) / 16.0;\n"
      "    float f = 0.2 * (0.5 + 1.0 * fract(sin(s * 113.1)\n"
      "                     * 43758.5453123));\n"
      "    vec2 c = 0.5 * vec2(cos(f * iTime + 17.0 * s),\n"
      "                        sin(f * iTime + 19.0 * s));\n"
      "    z -= c;\n"
      "    float zr = length(z);\n"
      "    float ar = atan(z.y, z.x) + zr * 0.6;\n"
      "    z = vec2(cos(ar), sin(ar)) / zr;\n"
      "    z += c;\n"
      "    z += 0.05 * sin(2.0 * z.x);\n"
      "\n"
      "    // color\n"
      "    col -= 0.7 * exp(-8.0 * dot(z, z)) *\n"
      "           (0.5 + 0.5 * sin(4.2 * s + vec3(1.6, 0.9, 0.3)));\n"
      "  }\n"
      "  col *= 0.75 + 0.25 * clamp(length(z - uv) * 0.6, 0.0, 1.0);\n"
      "\n"
      "  // 3d effect\n"
      "  float h = dot(col, vec3(0.333));\n"
      "  vec3 nor = normalize(vec3(dFdx(h), dFdy(h), 1.0 / 1000.0));\n"
      "  col -= 0.05 * vec3(1.0, 0.9, 0.5) * dot(nor, vec3(0.8, 0.4, 0.2));\n"
      "  col += 0.25 * (1.0 - 0.8 * col) * nor.z * nor.z;\n"
      "\n"
      "  // 2d postpro\n"
      "  col *= 1.12;\n"
      "  col = pow(clamp(col, 0.0, 1.0), vec3(0.8));\n"
      "  col *= 0.8 + 0.2 * pow(16.0 * uv.x * uv.y\n"
      "                         * (1.0 - uv.x) * (1.0 - uv.y), 0.1);\n"
      "  gl_FragColor = vec4(col, 1.0);\n"
      "}\n";

  // Iterations - trigonometric ( https://www.shadertoy.com/view/Mdl3RH )
  static constexpr const char* custom7FragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float time;\n"
      "\n"
      "vec2 iterate(in vec2 p, in vec4 t) {\n"
      "  return p -\n"
      "         0.05 * cos(t.xz + p.x * p.y +\n"
      "                    cos(t.yw + 1.5 * 3.1415927 * p.yx) +\n"
      "                    p.yx * p.yx);\n"
      "}\n"
      "\n"
      "void main(void) {\n"
      "  vec2 q = -1.0 + 2.0 * vUV.xy;\n"
      "  vec2 p = -1.0 + 2.0 * q;\n"
      "  p.x *= 1.0;\n"
      "  p *= 1.5;\n"
      "\n"
      "  vec4 t = 0.15 * time * vec4(1.0, -1.5, 1.2, -1.6) +\n"
      "                         vec4(0.0, 2.0, 3.0, 1.0);\n"
      "\n"
      "  vec2 z = p;\n"
      "  vec3 s = vec3(0.0);\n"
      "  for (int i = 0; i < 100; i++) {\n"
      "    z = iterate(z, t);\n"
      "\n"
      "    float d = dot(z - p, z - p);\n"
      "    s.x += 1.0 / (0.1 + d);\n"
      "    s.y += sin(atan(p.x - z.x, p.y - z.y));\n"
      "    s.z += exp(-0.2 * d);\n"
      "  }\n"
      "  s /= 100.0;\n"
      "\n"
      "  vec3 col = 0.5 + 0.5 * cos(vec3(0.0, 0.4, 0.8)\n"
      "                 + 2.5 + s.z * 6.2831);\n"
      "\n"
      "  col *= 0.5 + 0.5 * s.y;\n"
      "  col *= s.x;\n"
      "  col *= 0.94 + 0.06 * sin(10.0 * length(z));\n"
      "\n"
      "  vec3 nor = normalize(vec3(dFdx(s.x), 0.02, dFdy(s.x)));\n"
      "  float dif = dot(nor, vec3(0.7, 0.1, 0.7));\n"
      "  col -= 0.05 * vec3(dif);\n"
      "\n"
      "  col *= 0.3 + 0.7 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y),\n"
      "                         0.2);\n"
      "\n"
      "  gl_FragColor = vec4(col, 1.0);\n"
      "}\n";

  // Voronoi - basic ( https://www.shadertoy.com/view/MslGD8 )
  static constexpr const char* custom8FragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float time;\n"
      "\n"
      "vec2 hash(vec2 p) {\n"
      "  p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n"
      "  return fract(sin(p) * 18.5453);\n"
      "}\n"
      "\n"
      "// return distance, and cell id\n"
      "vec2 voronoi(in vec2 x) {\n"
      "  vec2 n = floor(x);\n"
      "  vec2 f = fract(x);\n"
      "\n"
      "  vec3 m = vec3(8.0);\n"
      "  for (int j = -1; j <= 1; j++)\n"
      "    for (int i = -1; i <= 1; i++) {\n"
      "      vec2 g = vec2(float(i), float(j));\n"
      "      vec2 o = hash(n + g);\n"
      "      // vec2  r = g - f + o;\n"
      "      vec2 r = g - f + (0.5 + 0.5 * sin(time + 6.2831 * o));\n"
      "      float d = dot(r, r);\n"
      "      if (d < m.x)\n"
      "        m = vec3(d, o);\n"
      "    }\n"
      "\n"
      "  return vec2(sqrt(m.x), m.y + m.z);\n"
      "}\n"
      "\n"
      "void main(void) {\n"
      "  vec2 p = -1.0 + 2.0 * vUV.xy;\n"
      "\n"
      "  // computer voronoi patterm\n"
      "  vec2 c = voronoi((14.0 + 6.0 * sin(0.2 * time)) * p);\n"
      "\n"
      "  // colorize\n"
      "  vec3 col = 0.5 + 0.5 * cos(c.y * 6.2831 + vec3(0.0, 1.0, 2.0));\n"
      "  col *= clamp(1.0 - 0.4 * c.x * c.x, 0.0, 1.0);\n"
      "  col -= (1.0 - smoothstep(0.08, 0.09, c.x));\n"
      "\n"
      "  gl_FragColor = vec4(col, 1.0);\n"
      "}\n";

  // Soap bubbles 2D ( https://www.shadertoy.com/view/llsSDf )
  static constexpr const char* custom9FragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float time;\n"
      "\n"
      "vec2 uv;\n"
      "\n"
      "vec2 hash2a(vec2 x, float anim) {\n"
      "  float r = 523.0 * sin(dot(x, vec2(53.3158, 43.6143)));\n"
      "  float xa1 = fract(anim);\n"
      "  float xb1 = anim - xa1;\n"
      "  anim += 0.5;\n"
      "  float xa2 = fract(anim);\n"
      "  float xb2 = anim - xa2;\n"
      "\n"
      "  vec2 z1 = vec2(fract(15.32354 * (r + xb1)),\n"
      "                 fract(17.25865 * (r + xb1)));\n"
      "  r = r + 1.0;\n"
      "  vec2 z2 = vec2(fract(15.32354 * (r + xb1)),\n"
      "                 fract(17.25865 * (r + xb1)));\n"
      "  r = r + 1.0;\n"
      "  vec2 z3 = vec2(fract(15.32354 * (r + xb2)),\n"
      "                 fract(17.25865 * (r + xb2)));\n"
      "  r = r + 1.0;\n"
      "  vec2 z4 = vec2(fract(15.32354 * (r + xb2)),\n"
      "                 fract(17.25865 * (r + xb2)));\n"
      "  return (mix(z1, z2, xa1) + mix(z3, z4, xa2)) * 0.5;\n"
      "}\n"
      "\n"
      "float hashNull(vec2 x) {\n"
      "  float r = fract(523.0 * sin(dot(x, vec2(53.3158, 43.6143))));\n"
      "  return r;\n"
      "}\n"
      "\n"
      "vec4 NC0 = vec4(0.0, 157.0, 113.0, 270.0);\n"
      "vec4 NC1 = vec4(1.0, 158.0, 114.0, 271.0);\n"
      "\n"
      "vec4 hash4(vec4 n) { return fract(sin(n) * 753.5453123); }\n"
      "vec2 hash2(vec2 n) { return fract(sin(n) * 753.5453123); }\n"
      "float noise2(vec2 x) {\n"
      "  vec2 p = floor(x);\n"
      "  vec2 f = fract(x);\n"
      "  f = f * f * (3.0 - 2.0 * f);\n"
      "\n"
      "  float n = p.x + p.y * 157.0;\n"
      "  vec2 s1 = mix(hash2(vec2(n) + NC0.xy), hash2(vec2(n) + NC1.xy),\n"
      "                vec2(f.x));\n"
      "  return mix(s1.x, s1.y, f.y);\n"
      "}\n"
      "\n"
      "float noise3(vec3 x) {\n"
      "  vec3 p = floor(x);\n"
      "  vec3 f = fract(x);\n"
      "  f = f * f * (3.0 - 2.0 * f);\n"
      "\n"
      "  float n = p.x + dot(p.yz, vec2(157.0, 113.0));\n"
      "  vec4 s1 = mix(hash4(vec4(n) + NC0), hash4(vec4(n) + NC1),\n"
      "                vec4(f.x));\n"
      "  return mix(mix(s1.x, s1.y, f.y), mix(s1.z, s1.w, f.y), f.z);\n"
      "}\n"
      "\n"
      "vec4 booble(vec2 te, vec2 pos, float numCells) {\n"
      "  float d = dot(te, te);\n"
      "\n"
      "  vec2 te1 = te + (pos - vec2(0.5, 0.5)) * 0.4 / numCells;\n"
      "  vec2 te2 = -te1;\n"
      "  float zb1 = max(pow(noise2(te2 * 1000.11 * d), 10.0), 0.01);\n"
      "  float zb2 = noise2(te1 * 1000.11 * d);\n"
      "  float zb3 = noise2(te1 * 200.11 * d);\n"
      "  float zb4 = noise2(te1 * 200.11 * d + vec2(20.0));\n"
      "\n"
      "  vec4 colorb = vec4(1.0);\n"
      "  colorb.xyz = colorb.xyz * (0.7 + noise2(te1 * 1000.11 * d) * 0.3);\n"
      "\n"
      "  zb2 = max(pow(zb2, 20.1), 0.01);\n"
      "  colorb.xyz = colorb.xyz * (zb2 * 1.9);\n"
      "\n"
      "  vec4 color = vec4(noise2(te2 * 10.8),\n"
      "                    noise2(te2 * 9.5 + vec2(15.0, 15.0)),\n"
      "                    noise2(te2 * 11.2 + vec2(12.0, 12.0)), 1.0);\n"
      "  color = mix(color, vec4(1.0),\n"
      "              noise2(te2 * 20.5 + vec2(200.0, 200.0)));\n"
      "  color.xyz = color.xyz * (0.7 + noise2(te2 * 1000.11 * d) * 0.3);\n"
      "  color.xyz = color.xyz * (0.2 + zb1 * 1.9);\n"
      "\n"
      "  float r1 =\n"
      "      max(min((0.033 - min(0.04, d)) * 100.0 / sqrt(numCells),\n"
      "               1.0), -1.6);\n"
      "  float d2 = (0.06 - min(0.06, d)) * 10.0;\n"
      "  d = (0.04 - min(0.04, d)) * 10.0;\n"
      "  color.xyz = color.xyz + colorb.xyz * d * 1.5;\n"
      "\n"
      "  float f1 = min(d * 10.0, 0.5 - d) * 2.2;\n"
      "  f1 = pow(f1, 4.0);\n"
      "  float f2 = min(min(d * 4.1, 0.9 - d) * 2.0 * r1, 1.0);\n"
      "\n"
      "  float f3 = min(d2 * 2.0, 0.7 - d2) * 2.2;\n"
      "  f3 = pow(f3, 4.0);\n"
      "\n"
      "  return vec4(color * max(min(f1 + f2, 1.0), -0.5) + vec4(zb3) * f3 -\n"
      "              vec4(zb4) * (f2 * 0.5 + f1) * 0.5);\n"
      "}\n"
      "\n"
      "// base from https://www.shadertoy.com/view/4djGRh\n"
      "vec4 Cells(vec2 p, vec2 move, in float numCells,\n"
      "                              in float count, float blur) {\n"
      "  vec2 inp = p + move;\n"
      "  inp *= numCells;\n"
      "  float d = 1.0;\n"
      "  vec2 te;\n"
      "  vec2 pos;\n"
      "  for (int xo = -1; xo <= 1; xo++) {\n"
      "    for (int yo = -1; yo <= 1; yo++) {\n"
      "      vec2 tp = floor(inp) + vec2(xo, yo);\n"
      "      vec2 rr = mod(tp, numCells);\n"
      "      tp = tp + (hash2a(rr, time * 0.1) +\n"
      "                 hash2a(rr, time * 0.1 + 0.25)) * 0.5;\n"
      "      vec2 l = inp - tp;\n"
      "      float dr = dot(l, l);\n"
      "      if (hashNull(rr) > count)\n"
      "        if (d > dr) {\n"
      "          d = dr;\n"
      "          pos = tp;\n"
      "        }\n"
      "    }\n"
      "  }\n"
      "  if (d >= 0.06)\n"
      "    return vec4(0.0);\n"
      "  te = inp - pos;\n"
      "\n"
      "  if (d < 0.04)\n"
      "    uv = uv + te * (d)*2.0;\n"
      "  if (blur > 0.0001) {\n"
      "    vec4 c = vec4(0.0);\n"
      "    for (float x = -1.0; x < 1.0; x += 0.5) {\n"
      "      for (float y = -1.0; y < 1.0; y += 0.5) {\n"
      "        c += booble(te + vec2(x, y) * blur, p, numCells);\n"
      "      }\n"
      "    }\n"
      "    return c * 0.05;\n"
      "  }\n"
      "\n"
      "  return booble(te, p, numCells);\n"
      "}\n"
      "\n"
      "void main(void) {\n"
      "  uv = vUV.xy;\n"
      "\n"
      "  vec2 l1 = vec2(time * 0.02, time * 0.02);\n"
      "  vec2 l2 = vec2(-time * 0.01, time * 0.007);\n"
      "  vec2 l3 = vec2(0.0, time * 0.01);\n"
      "\n"
      "  vec4 e = vec4(noise3(vec3(uv * 2.0, time * 0.1)),\n"
      "                noise3(vec3(uv * 2.0 + vec2(200.0), time * 0.1)),\n"
      "                noise3(vec3(uv * 2.0 + vec2(50.0), time * 0.1)), 0.0);\n"
      "\n"
      "  vec4 cr1 = Cells(uv, vec2(20.2449, 93.78) + l1, 2.0, 0.5, 0.005);\n"
      "  vec4 cr2 = Cells(uv, vec2(0.0, 0.0), 3.0, 0.5, 0.003);\n"
      "  vec4 cr3 = Cells(uv, vec2(230.79, 193.2) + l2, 4.0, 0.5, 0.0);\n"
      "  vec4 cr4 = Cells(uv, vec2(200.19, 393.2) + l3, 7.0, 0.8, 0.01);\n"
      "  vec4 cr5 = Cells(uv, vec2(10.3245, 233.645) + l3, 9.2, 0.9, 0.02);\n"
      "  vec4 cr6 = Cells(uv, vec2(10.3245, 233.645) + l3, 14.2, 0.95, 0.05);\n"
      "\n"
      "  e = max(e - vec4(dot(cr6, cr6)) * 0.1, 0.0) + cr6 * 1.6;\n"
      "  e = max(e - vec4(dot(cr5, cr5)) * 0.1, 0.0) + cr5 * 1.6;\n"
      "  e = max(e - vec4(dot(cr4, cr4)) * 0.1, 0.0) + cr4 * 1.3;\n"
      "  e = max(e - vec4(dot(cr3, cr3)) * 0.1, 0.0) + cr3 * 1.1;\n"
      "  e = max(e - vec4(dot(cr2, cr2)) * 0.1, 0.0) + cr2 * 1.4;\n"
      "\n"
      "  e = max(e - vec4(dot(cr1, cr1)) * 0.1, 0.0) + cr1 * 1.8;\n"
      "\n"
      "  gl_FragColor = e;\n"
      "}\n";

public:
  ShaderMaterialCylindersScene(ICanvas* iCanvas);
  ~ShaderMaterialCylindersScene() override;

  const char* getName() override;
  void initializeScene(ICanvas* canvas, Scene* scene) override;

private:
  float _time;
  std::array<ShaderMaterial*, 9> _shaderMaterials;

}; // end of class ShaderMaterialCylindersScene

} // end of namespace Samples
} // end of namespace BABYLON

#endif // end of BABYLON_SAMPLES_MATERIALS_SHADER_MATERIAL_CYLINDERS_SCENE_H
