#ifndef BABYLON_SAMPLES_MATERIALS_SHADER_MATERIAL_TILES_SCENE_H
#define BABYLON_SAMPLES_MATERIALS_SHADER_MATERIAL_TILES_SCENE_H

#include <babylon/interfaces/irenderable_scene.h>
#include <babylon/materials/effect_shaders_store.h>
#include <babylon/math/vector2.h>

namespace BABYLON {
namespace Samples {

class ShaderMaterialTilesScene : public IRenderableScene {

public:
  static constexpr const char* customVertexShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Attributes\n"
      "attribute vec3 position;\n"
      "attribute vec3 normal;\n"
      "attribute vec2 uv;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float time;\n"
      "\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "void main(void) {\n"
      "  vec3 v = position;\n"
      "  gl_Position = worldViewProjection * vec4(v, 1.0);\n"
      "  vPosition = position;\n"
      "  vNormal = normal;\n"
      "  vUV = uv;\n"
      "}\n";

  // Procedural Checkerboard ( https://www.shadertoy.com/view/Xss3Dr )
  static constexpr const char* custom1FragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float time;\n"
      "uniform float aspectRatio;\n"
      "uniform vec2 resolution;\n"
      "\n"
      "// by Nikos Papadopoulos, 4rknova / 2013\n"
      "// WTFPL\n"
      "\n"
      "#define S 5. // Scale\n"
      "\n"
      "void main(void) {\n"
      "  vec2 p = -1.0 + 2.0 * vUV;\n"
      "  vec2 uv = floor(S * p.xy * vec2(resolution.x / resolution.y, 1) /\n"
      "                  resolution.xy);\n"
      "  gl_FragColor = vec4(vec3(mod(uv.x + uv.y, 2.)), 1);\n"
      "}\n";

  // Simple procedural brick ( https://www.shadertoy.com/view/lltGDM )
  static constexpr const char* custom2FragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float time;\n"
      "uniform vec2 resolution;\n"
      "\n"
      "float brickH = .08;\n"
      "float brickW = .2;\n"
      "float mortarR = 0.006;\n"
      "float mortarW = 0.005;\n"
      "vec3 brickC = pow(vec3(218, 114, 61) / 255., vec3(2.2));\n"
      "vec3 mortarC = pow(vec3(227, 210, 170) / 255., vec3(2.2));\n"
      "\n"
      "vec3 permute(vec3 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\n"
      "\n"
      "float snoise(vec2 v) {\n"
      "  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n"
      "                      -0.577350269189626, 0.024390243902439);\n"
      "  vec2 i = floor(v + dot(v, C.yy));\n"
      "  vec2 x0 = v - i + dot(i, C.xx);\n"
      "  vec2 i1;\n"
      "  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n"
      "  vec4 x12 = x0.xyxy + C.xxzz;\n"
      "  x12.xy -= i1;\n"
      "  i = mod(i, 289.0);\n"
      "  vec3 p =\n"
      "      permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x +\n"
      "                      vec3(0.0, i1.x, 1.0));\n"
      "  vec3 m = max(\n"
      "      0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),\n"
      "                 dot(x12.zw, x12.zw)), 0.0);\n"
      "  m = m * m;\n"
      "  m = m * m;\n"
      "  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n"
      "  vec3 h = abs(x) - 0.5;\n"
      "  vec3 ox = floor(x + 0.5);\n"
      "  vec3 a0 = x - ox;\n"
      "  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n"
      "  vec3 g;\n"
      "  g.x = a0.x * x0.x + h.x * x0.y;\n"
      "  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n"
      "  return pow((130.0 * dot(m, g) + 1.0) / 2.0, 1.0);\n"
      "}\n"
      "\n"
      "float derez(float a, float b) { return ceil(a / b) * b; }\n"
      "\n"
      "float capSlope(float a, float r, float w) {\n"
      "  float ir = 1.0 - r;\n"
      "  return (max(a + w, ir) - ir) / r;\n"
      "}\n"
      "\n"
      "float peak(float a, float r, float w) {\n"
      "\n"
      "  return pow(max(capSlope(1.0 - a, r, w) + capSlope(a, r, w),\n"
      "                 0.0), 2.0);\n"
      "}\n"
      "\n"
      "float mortar(vec2 uv) {\n"
      "  float isOffset = mod(uv.y, brickH * 2.) < brickH ? 0. : 1.;\n"
      "  return (\n"
      "             // vertical mortar lines\n"
      "             peak(mod(uv.x + isOffset * brickW * .5, brickW) / brickW,\n"
      "                  mortarR / brickW, mortarW / brickW) +\n"
      "             // horizontal mortar lines\n"
      "             peak(mod(uv.y, brickH) / brickH, mortarR / brickH,\n"
      "                  mortarW / brickH)) > 1. ? 1. : 0.;\n"
      "}\n"
      "\n"
      "vec3 lightAjust(vec3 color, float amount) {\n"
      "  return 1.0 - pow(1.0 - color, vec3(amount));\n"
      "}\n"
      "\n"
      "vec3 toneMap(vec3 color) {\n"
      "  float maxColor = max(color.r, max(color.g, color.b));\n"
      "  vec3 foo = lightAjust(color / maxColor, maxColor);\n"
      "\n"
      "  return min(foo, color);\n"
      "}\n"
      "\n"
      "void main(void) {\n"
      "  vec2 uv = vUV;\n"
      "  float pi = 3.14152654;\n"
      "\n"
      "  float brickHNoise = snoise(vec2(1.0, uv.y * 2.0));\n"
      "\n"
      "  brickH += brickHNoise * 0.002;\n"
      "\n"
      "  float brickWNoise = snoise(vec2(uv.x, derez(uv.y, brickH)));\n"
      "\n"
      "  brickW += brickWNoise * .01;\n"
      "\n"
      "  float isOffset = mod(uv.y, brickH * 2.) < brickH ? 0. : 1.;\n"
      "\n"
      "  float brickLNoise =\n"
      "      snoise(vec2(derez((uv.x + isOffset * brickW * .5) * 4.0,\n"
      "                         brickW * 4.0),\n"
      "                  derez(uv.y * 4.0, brickH * 4.0)));\n"
      "  float brickCNoise =\n"
      "      snoise(vec2(derez(((uv.x) + isOffset * brickW * .5) * 5.0,\n"
      "                          brickW * 5.0),\n"
      "                  derez((uv.y) * 5.0, brickH * 5.0)));\n"
      "\n"
      "  brickC *= brickLNoise * .6 + .4;\n"
      "\n"
      "  brickC *= vec3((1. - brickCNoise) * 0.2 + 0.8,\n"
      "                 brickCNoise * 0.2 + 0.8, 1);\n"
      "\n"
      "  vec3 color = mix(brickC, mortarC, mortar(uv));\n"
      "\n"
      "  float highlight = clamp(mortar(uv + vec2(-.005, .005)) - mortar(uv),\n"
      "                          0., 1.);\n"
      "  float shadow = clamp(mortar(uv + vec2(.005, -.005)) - mortar(uv),\n"
      "                       0., 1.);\n"
      "  shadow +=\n"
      "      clamp((1. - mortar(uv + vec2(-.005, .005))) - (1. - mortar(uv)),\n"
      "                         0., 1.);\n"
      "\n"
      "  shadow = clamp(shadow, 0., 1.);\n"
      "\n"
      "  float light = mix(highlight, 1.0 - shadow, 0.5);\n"
      "\n"
      "  float textureHighlight =\n"
      "      clamp(snoise((uv / .01) + vec2(-.1, .1)) - snoise(uv / .01),\n"
      "                    0., 1.);\n"
      "  float textureShadow =\n"
      "      clamp(snoise((uv / .01) + vec2(.1, -.1)) - snoise(uv / .01),\n"
      "                    0., 1.);\n"
      "  float texture = mix(textureHighlight, 1.0 - textureShadow, 0.5);\n"
      "\n"
      "  light = mix(light, texture, 0.5);\n"
      "\n"
      "  vec3 lightColor = mix(vec3(0, 0, 1), vec3(1, 1, 0), light);\n"
      "\n"
      "  gl_FragColor =\n"
      "      pow(vec4(lightAjust(color * lightColor, 2.5), 1),\n"
      "               vec4(1. / 2.2));\n"
      "}\n";

  // Utah Sandstone ( https://www.shadertoy.com/view/MdsSDB )
  static constexpr const char* custom3FragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float time;\n"
      "uniform float aspectRatio;\n"
      "uniform vec2 resolution;\n"
      "\n"
      "// perlin noise function by https://github.com/ashima/webgl-noise\n"
      "\n"
      "vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n"
      "\n"
      "vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n"
      "\n"
      "vec3 permute(vec3 x) { return mod289(((x * 34.0) + 1.0) * x); }\n"
      "\n"
      "float snoise(vec2 v) {\n"
      "  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n"
      "                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n"
      "                      -0.577350269189626, // -1.0 + 2.0 * C.x\n"
      "                      0.024390243902439); // 1.0 / 41.0\n"
      "                                          // First corner\n"
      "  vec2 i = floor(v + dot(v, C.yy));\n"
      "  vec2 x0 = v - i + dot(i, C.xx);\n"
      "\n"
      "  // Other corners\n"
      "  vec2 i1;\n"
      "  // i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n"
      "  // i1.y = 1.0 - i1.x;\n"
      "  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n"
      "  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n"
      "  // x1 = x0 - i1 + 1.0 * C.xx ;\n"
      "  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n"
      "  vec4 x12 = x0.xyxy + C.xxzz;\n"
      "  x12.xy -= i1;\n"
      "\n"
      "  // Permutations\n"
      "  i = mod289(i); // Avoid truncation effects in permutation\n"
      "  vec3 p =\n"
      "      permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x +\n"
      "                      vec3(0.0, i1.x, 1.0));\n"
      "\n"
      "  vec3 m = max(\n"
      "      0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),\n"
      "                 dot(x12.zw, x12.zw)), 0.0);\n"
      "  m = m * m;\n"
      "  m = m * m;\n"
      "\n"
      "  // Gradients: 41 points uniformly over a line,\n"
      "  //            mapped onto a diamond.\n"
      "  // The ring size 17*17 = 289 is close to a multiple of\n"
      "  // 41 (41*7 = 287)\n"
      "\n"
      "  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n"
      "  vec3 h = abs(x) - 0.5;\n"
      "  vec3 ox = floor(x + 0.5);\n"
      "  vec3 a0 = x - ox;\n"
      "\n"
      "  // Normalise gradients implicitly by scaling m\n"
      "  // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n"
      "  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n"
      "\n"
      "  // Compute final noise value at P\n"
      "  vec3 g;\n"
      "  g.x = a0.x * x0.x + h.x * x0.y;\n"
      "  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n"
      "  return 130.0 * dot(m, g);\n"
      "}\n"
      "\n"
      "// fbm function by\n"
      "// "
      "https://code.google.com/p/fractalterraingeneration/wiki/"
      "Fractional_Brownian_Motion\n"
      "float fbm(in vec2 uv) {\n"
      "  float gain = 0.65;\n"
      "  float lacunarity = 2.1042;\n"
      "\n"
      "  float total = 0.0;\n"
      "  float frequency = 0.5;\n"
      "  float amplitude = gain;\n"
      "\n"
      "  uv = uv * 5.0;\n"
      "\n"
      "  total = snoise(uv);\n"
      "\n"
      "  for (int i = 0; i < 10; i++) {\n"
      "    total += snoise(uv * frequency) * amplitude;\n"
      "    frequency *= lacunarity;\n"
      "    amplitude *= gain;\n"
      "  }\n"
      "\n"
      "  total = (total + 2.0) / 4.0;\n"
      "\n"
      "  return total;\n"
      "}\n"
      "\n"
      "float pattern(in vec2 p) { return fbm(p + fbm(p + fbm(p))); }\n"
      "\n"
      "void main(void) {\n"
      "  vec2 uv = -1.0 + 2.0 * vUV;\n"
      "  vec2 ar = vec2(resolution.x / resolution.y, 1.0);\n"
      "\n"
      "#ifdef ANIMATE\n"
      "  float iTime = time / 20.0;\n"
      "#else\n"
      "  float iTime = 5.0;\n"
      "#endif\n"
      "\n"
      "  vec3 col = vec3(0.0);\n"
      "  vec2 p = vec2((uv * ar) / 900.0);\n"
      "\n"
      "  float f = pattern(vec2(p.x + 0.005 * iTime, p.y));\n"
      "\n"
      "  col = vec3(f * 1.9, f * 1.0, f * 0.45);\n"
      "  col = sqrt(col) - 0.2;\n"
      "\n"
      "  gl_FragColor = vec4(col, 1.0);\n"
      "}\n";

  // Warping - procedural 3 ( https://www.shadertoy.com/view/XsfSD4 )
  static constexpr const char* custom4FragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float time;\n"
      "uniform float aspectRatio;\n"
      "uniform vec2 resolution;\n"
      "\n"
      "// Created by inigo quilez - iq/2014\n"
      "// License Creative Commons Attribution-NonCommercial-ShareAlike\n"
      "// 3.0 Unported License.\n"
      "\n"
      "vec2 hash(vec2 p) {\n"
      "  p = vec2(dot(p, vec2(2127.1, 81.17)), dot(p, vec2(1269.5, 283.37)));\n"
      "  return fract(sin(p) * 43758.5453);\n"
      "}\n"
      "\n"
      "float noise(in vec2 p) {\n"
      "  vec2 i = floor(p);\n"
      "  vec2 f = fract(p);\n"
      "\n"
      "  vec2 u = f * f * (3.0 - 2.0 * f);\n"
      "\n"
      "  float n = mix(\n"
      "      mix(dot(-1.0 + 2.0 * hash(i + vec2(0.0, 0.0)),\n"
      "              f - vec2(0.0, 0.0)),\n"
      "          dot(-1.0 + 2.0 * hash(i + vec2(1.0, 0.0)),\n"
      "              f - vec2(1.0, 0.0)), u.x),\n"
      "      mix(dot(-1.0 + 2.0 * hash(i + vec2(0.0, 1.0)),\n"
      "              f - vec2(0.0, 1.0)),\n"
      "          dot(-1.0 + 2.0 * hash(i + vec2(1.0, 1.0)),\n"
      "              f - vec2(1.0, 1.0)), u.x),\n"
      "      u.y);\n"
      "  return 0.5 + 0.5 * n;\n"
      "}\n"
      "\n"
      "float fbm(in vec2 x) {\n"
      "#ifdef ANIMATE\n"
      "  float iTime = time;\n"
      "#else\n"
      "  float iTime = 0.0;\n"
      "#endif\n"
      "  float m = 0.0;\n"
      "  vec2 p = 6.0 * x;\n"
      "\n"
      "  float w = 0.5;\n"
      "  float s = 1.0;\n"
      "  for (int i = 0; i < 8; i++) {\n"
      "    float n = noise(p * s);\n"
      "    m += w * n;\n"
      "\n"
      "    p.y -= 1.25 * (-1.0 + 2.0 * n) - 0.1 * iTime * w; // warp\n"
      "\n"
      "    w *= 0.5;\n"
      "    s *= 2.0;\n"
      "  }\n"
      "\n"
      "  return m;\n"
      "}\n"
      "\n"
      "void main(void) {\n"
      "  vec2 p = -1.0 + 2.0 * vUV;\n"
      "\n"
      "  // pattern\n"
      "  float n = fbm(p);\n"
      "\n"
      "  // normal\n"
      "  vec2 e = vec2(0.03, 0.0);\n"
      "  vec3 nor = normalize(vec3(fbm(p - e.xy) - fbm(p + e.xy), 2.0 * e.x,\n"
      "                            fbm(p - e.yx) - fbm(p + e.yx)));\n"
      "\n"
      "  // color\n"
      "  float c = pow(n, 4.0) * 6.0;\n"
      "  vec3 col = 0.5 + 0.5 * cos(5.0 + n * 12.0 + vec3(0.8, 0.4, 0.0));\n"
      "  col *= 0.4 + 0.6 * c;\n"
      "\n"
      "  // light\n"
      "  vec3 lig = normalize(vec3(1.0, 0.2, 1.0));\n"
      "  col *= vec3(0.6, 0.7, 0.8) +\n"
      "         1.0 * vec3(1.0, 0.7, 0.5) * clamp(0.3 + 0.7 * dot(nor, lig),\n"
      "                    0.0, 1.0);\n"
      "  col += 1.5 * vec3(1.0, 0.5, 0.0) * pow(1.0 - nor.y, 2.0) * c;\n"
      "\n"
      "  // postprocessing\n"
      "  col = sqrt(col) - 0.15;\n"
      "  col *= sqrt(1.0 - 0.5 * abs(p.x - 0.5));\n"
      "\n"
      "  gl_FragColor = vec4(col, 1.0);\n"
      "}\n";

  // Warping - procedural 4 ( https://www.shadertoy.com/view/MdSXzz )
  static constexpr const char* custom5FragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float time;\n"
      "uniform float aspectRatio;\n"
      "uniform vec2 resolution;\n"
      "\n"
      "// Created by inigo quilez - iq/2014\n"
      "// License Creative Commons\n"
      "// Attribution-NonCommercial-ShareAlike 3.0 Unported\n"
      "// License.\n"
      "\n"
      "const mat2 m = mat2(0.80, 0.60, -0.60, 0.80);\n"
      "\n"
      "float hash(vec2 p) {\n"
      "  float h = dot(p, vec2(127.1, 311.7));\n"
      "  return -1.0 + 2.0 * fract(sin(h) * 43758.5453123);\n"
      "}\n"
      "\n"
      "float noise(in vec2 p) {\n"
      "  vec2 i = floor(p);\n"
      "  vec2 f = fract(p);\n"
      "\n"
      "  vec2 u = f * f * (3.0 - 2.0 * f);\n"
      "\n"
      "  return mix(mix(hash(i + vec2(0.0, 0.0)),\n"
      "                 hash(i + vec2(1.0, 0.0)), u.x),\n"
      "             mix(hash(i + vec2(0.0, 1.0)),\n"
      "                 hash(i + vec2(1.0, 1.0)), u.x), u.y);\n"
      "}\n"
      "\n"
      "float fbm(vec2 p) {\n"
      "  float f = 0.0;\n"
      "  f += 0.5000 * noise(p);\n"
      "  p = m * p * 2.02;\n"
      "  f += 0.2500 * noise(p);\n"
      "  p = m * p * 2.03;\n"
      "  f += 0.1250 * noise(p);\n"
      "  p = m * p * 2.01;\n"
      "  f += 0.0625 * noise(p);\n"
      "  return f / 0.9375;\n"
      "}\n"
      "\n"
      "vec2 fbm2(in vec2 p) { return vec2(fbm(p.xy), fbm(p.yx)); }\n"
      "\n"
      "vec3 map(vec2 p) {\n"
      "  p *= 0.7;\n"
      "\n"
      "#ifdef ANIMATE\n"
      "  float iTime = time;\n"
      "#else\n"
      "  float iTime = 7.0;\n"
      "#endif\n"
      "\n"
      "  float f = dot(fbm2(1.0 * (0.05 * iTime + p +\n"
      "                            fbm2(-0.05 * iTime + 2.0 *\n"
      "                                 (p + fbm2(4.0 * p))))),\n"
      "                vec2(1.0, -1.0));\n"
      "\n"
      "  float bl = smoothstep(-0.8, 0.8, f);\n"
      "\n"
      "  float ti = smoothstep(-1.0, 1.0, fbm(p));\n"
      "\n"
      "  return mix(mix(vec3(0.50, 0.00, 0.00), vec3(1.00, 0.75, 0.35), ti),\n"
      "             vec3(0.00, 0.00, 0.02), bl);\n"
      "}\n"
      "\n"
      "void main(void) {\n"
      "  vec2 p = -1.0 + 2.0 * vUV;\n"
      "\n"
      "  float e = 0.0045;\n"
      "\n"
      "  vec3 colc = map(p);\n"
      "  float gc = dot(colc, vec3(0.333));\n"
      "  vec3 cola = map(p + vec2(e, 0.0));\n"
      "  float ga = dot(cola, vec3(0.333));\n"
      "  vec3 colb = map(p + vec2(0.0, e));\n"
      "  float gb = dot(colb, vec3(0.333));\n"
      "\n"
      "  vec3 nor = normalize(vec3(ga - gc, e, gb - gc));\n"
      "\n"
      "  vec3 col = colc;\n"
      "  col += vec3(1.0, 0.7, 0.6) * 8.0 * abs(2.0 * gc - ga - gb);\n"
      "  col *= 1.0 + 0.2 * nor.y * nor.y;\n"
      "  col += 0.05 * nor.y * nor.y * nor.y;\n"
      "\n"
      "  vec2 q = -1.0 + 2.0 * vUV;\n"
      "  col *= pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.1);\n"
      "\n"
      "  gl_FragColor = vec4(col, 1.0);\n"
      "}\n";

  // Warping - procedural 2 ( https://www.shadertoy.com/view/lsl3RH )
  static constexpr const char* custom6FragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float time;\n"
      "uniform float aspectRatio;\n"
      "uniform vec2 resolution;\n"
      "\n"
      "// Created by inigo quilez - iq/2013\n"
      "// License Creative Commons Attribution-NonCommercial-ShareAlike\n"
      "// 3.0 Unported License.\n"
      "\n"
      "// See here for a tutorial on how to make this:\n"
      "// http://www.iquilezles.org/www/articles/warp/warp.htm\n"
      "\n"
      "const mat2 m = mat2(0.80, 0.60, -0.60, 0.80);\n"
      "\n"
      "float noise(in vec2 x) { return sin(1.5 * x.x) * sin(1.5 * x.y); }\n"
      "\n"
      "float fbm4(vec2 p) {\n"
      "  float f = 0.0;\n"
      "  f += 0.5000 * noise(p);\n"
      "  p = m * p * 2.02;\n"
      "  f += 0.2500 * noise(p);\n"
      "  p = m * p * 2.03;\n"
      "  f += 0.1250 * noise(p);\n"
      "  p = m * p * 2.01;\n"
      "  f += 0.0625 * noise(p);\n"
      "  return f / 0.9375;\n"
      "}\n"
      "\n"
      "float fbm6(vec2 p) {\n"
      "  float f = 0.0;\n"
      "  f += 0.500000 * (0.5 + 0.5 * noise(p));\n"
      "  p = m * p * 2.02;\n"
      "  f += 0.250000 * (0.5 + 0.5 * noise(p));\n"
      "  p = m * p * 2.03;\n"
      "  f += 0.125000 * (0.5 + 0.5 * noise(p));\n"
      "  p = m * p * 2.01;\n"
      "  f += 0.062500 * (0.5 + 0.5 * noise(p));\n"
      "  p = m * p * 2.04;\n"
      "  f += 0.031250 * (0.5 + 0.5 * noise(p));\n"
      "  p = m * p * 2.01;\n"
      "  f += 0.015625 * (0.5 + 0.5 * noise(p));\n"
      "  return f / 0.96875;\n"
      "}\n"
      "\n"
      "float func(vec2 q, out vec4 ron) {\n"
      "#ifdef ANIMATE\n"
      "  float iTime = time;\n"
      "#else\n"
      "  float iTime = 0.0;\n"
      "#endif\n"
      "\n"
      "  float ql = length(q);\n"
      "  q.x += 0.05 * sin(0.27 * iTime + ql * 4.1);\n"
      "  q.y += 0.05 * sin(0.23 * iTime + ql * 4.3);\n"
      "  q *= 0.5;\n"
      "\n"
      "  vec2 o = vec2(0.0);\n"
      "  o.x = 0.5 + 0.5 * fbm4(vec2(2.0 * q));\n"
      "  o.y = 0.5 + 0.5 * fbm4(vec2(2.0 * q + vec2(5.2)));\n"
      "\n"
      "  float ol = length(o);\n"
      "  o.x += 0.02 * sin(0.12 * iTime + ol) / ol;\n"
      "  o.y += 0.02 * sin(0.14 * iTime + ol) / ol;\n"
      "\n"
      "  vec2 n;\n"
      "  n.x = fbm6(vec2(4.0 * o + vec2(9.2)));\n"
      "  n.y = fbm6(vec2(4.0 * o + vec2(5.7)));\n"
      "\n"
      "  vec2 p = 4.0 * q + 4.0 * n;\n"
      "\n"
      "  float f = 0.5 + 0.5 * fbm4(p);\n"
      "\n"
      "  f = mix(f, f * f * f * 3.5, f * abs(n.x));\n"
      "\n"
      "  float g = 0.5 + 0.5 * sin(4.0 * p.x) * sin(4.0 * p.y);\n"
      "  f *= 1.0 - 0.5 * pow(g, 8.0);\n"
      "\n"
      "  ron = vec4(o, n);\n"
      "\n"
      "  return f;\n"
      "}\n"
      "\n"
      "vec3 doMagic(vec2 p) {\n"
      "  vec2 q = p * 0.6;\n"
      "\n"
      "  vec4 on = vec4(0.0);\n"
      "  float f = func(q, on);\n"
      "\n"
      "  vec3 col = vec3(0.0);\n"
      "  col = mix(vec3(0.2, 0.1, 0.4), vec3(0.3, 0.05, 0.05), f);\n"
      "  col = mix(col, vec3(0.9, 0.9, 0.9), dot(on.zw, on.zw));\n"
      "  col = mix(col, vec3(0.4, 0.3, 0.3), 0.5 * on.y * on.y);\n"
      "  col = mix(col, vec3(0.0, 0.2, 0.4),\n"
      "            0.5 * smoothstep(1.2, 1.3, abs(on.z) + abs(on.w)));\n"
      "  col = clamp(col * f * 2.0, 0.0, 1.0);\n"
      "\n"
      "  vec3 nor =\n"
      "      normalize(vec3(dFdx(f) * resolution.x, 6.0,\n"
      "                     dFdy(f) * resolution.y));\n"
      "\n"
      "  vec3 lig = normalize(vec3(0.9, -0.2, -0.4));\n"
      "  float dif = clamp(0.3 + 0.7 * dot(nor, lig), 0.0, 1.0);\n"
      "  vec3 bdrf;\n"
      "  bdrf = vec3(0.70, 0.90, 0.95) * (nor.y * 0.5 + 0.5);\n"
      "  bdrf += vec3(0.15, 0.10, 0.05) * dif;\n"
      "  col *= 1.2 * bdrf;\n"
      "  col = 1.0 - col;\n"
      "  return 1.1 * col * col;\n"
      "}\n"
      "void main(void) {\n"
      "  vec2 q = -1.0 + 2.0 * vUV;\n"
      "  vec2 p = -1.0 + 2.0 * q;\n"
      "  p.x *= resolution.x / resolution.y;\n"
      "\n"
      "  gl_FragColor = vec4(doMagic(p), 1.0);\n"
      "}\n";

  // Worley-Perlin noise ( https://www.shadertoy.com/view/MdGSzt )
  static constexpr const char* custom7FragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float time;\n"
      "uniform float aspectRatio;\n"
      "uniform vec2 resolution;\n"
      "\n"
      "// copy from https://www.shadertoy.com/view/4l2GzW\n"
      "float r(float n) { return fract(cos(n * 89.42) * 343.42); }\n"
      "vec2 r(vec2 n) {\n"
      "  return vec2(r(n.x * 23.62 - 300.0 + n.y * 34.35),\n"
      "              r(n.x * 45.13 + 256.0 + n.y * 38.89));\n"
      "}\n"
      "float worley(vec2 n, float s) {\n"
      "  float dis = 2.0;\n"
      "  for (int x = -1; x <= 1; x++) {\n"
      "    for (int y = -1; y <= 1; y++) {\n"
      "      vec2 p = floor(n / s) + vec2(x, y);\n"
      "      float d = length(r(p) + vec2(x, y) - fract(n / s));\n"
      "      if (dis > d) {\n"
      "        dis = d;\n"
      "      }\n"
      "    }\n"
      "  }\n"
      "  return 1.0 - dis;\n"
      "}\n"
      "\n"
      "// copy from https://www.shadertoy.com/view/4sc3z2\n"
      "\n"
      "#define MOD3 vec3(.1031, .11369, .13787)\n"
      "\n"
      "vec3 hash33(vec3 p3) {\n"
      "  p3 = fract(p3 * MOD3);\n"
      "  p3 += dot(p3, p3.yxz + 19.19);\n"
      "  return -1.0 +\n"
      "         2.0 * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y,\n"
      "                          (p3.y + p3.z) * p3.x));\n"
      "}\n"
      "float perlin_noise(vec3 p) {\n"
      "  vec3 pi = floor(p);\n"
      "  vec3 pf = p - pi;\n"
      "\n"
      "  vec3 w = pf * pf * (3.0 - 2.0 * pf);\n"
      "\n"
      "  return mix(mix(mix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, "
      "0))),\n"
      "                     dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, "
      "0))), w.x),\n"
      "                 mix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, "
      "1))),\n"
      "                     dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, "
      "1))), w.x),\n"
      "                 w.z),\n"
      "             mix(mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, "
      "0))),\n"
      "                     dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, "
      "0))), w.x),\n"
      "                 mix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, "
      "1))),\n"
      "                     dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, "
      "1))), w.x),\n"
      "                 w.z),\n"
      "             w.y);\n"
      "}\n"
      "\n"
      "void main(void) {\n"
      "\n"
      "#ifdef ANIMATE\n"
      "  float iTime = time;\n"
      "#else\n"
      "  float iTime = 7.0;\n"
      "#endif\n"
      "\n"
      "  vec2 p = -1.0 + 2.0 * vUV;\n"
      "\n"
      "  float dis =\n"
      "      (1.0 + perlin_noise(vec3(p / resolution.xy, iTime * 0.05) * 8.0)) "
      "*\n"
      "      (1.0 + (worley(p, 32.0) + 0.5 * worley(2.0 * p, 32.0) +\n"
      "              0.25 * worley(4.0 * p, 32.0)));\n"
      "  gl_FragColor = vec4(vec3(dis / 4.0), 1.0);\n"
      "}\n";

  // Worley-Noise ( https://www.shadertoy.com/view/MstGRl )
  static constexpr const char* custom8FragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float time;\n"
      "uniform float aspectRatio;\n"
      "uniform vec2 resolution;\n"
      "\n"
      "// Determines how many cells there are\n"
      "#define NUM_CELLS 16.0\n"
      "\n"
      "// Arbitrary random, can be replaced with a function of your choice\n"
      "float rand(vec2 co) {\n"
      "  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n"
      "}\n"
      "\n"
      "// Returns the point in a given cell\n"
      "vec2 get_cell_point(ivec2 cell) {\n"
      "  vec2 cell_base = vec2(cell) / NUM_CELLS;\n"
      "  float noise_x = rand(vec2(cell));\n"
      "  float noise_y = rand(vec2(cell.yx));\n"
      "  return cell_base + (0.5 + 1.5 * vec2(noise_x, noise_y)) / NUM_CELLS;\n"
      "}\n"
      "\n"
      "// Performs worley noise by checking all adjacent cells\n"
      "// and comparing the distance to their points\n"
      "float worley(vec2 coord) {\n"
      "  ivec2 cell = ivec2(coord * NUM_CELLS);\n"
      "  float dist = 1.0;\n"
      "\n"
      "  // Search in the surrounding 5x5 cell block\n"
      "  for (int x = 0; x < 5; x++) {\n"
      "    for (int y = 0; y < 5; y++) {\n"
      "      vec2 cell_point = get_cell_point(cell + ivec2(x - 2, y - 2));\n"
      "      dist = min(dist, distance(cell_point, coord));\n"
      "    }\n"
      "  }\n"
      "\n"
      "  dist /= length(vec2(1.0 / NUM_CELLS));\n"
      "  dist = 1.0 - dist;\n"
      "  return dist;\n"
      "}\n"
      "\n"
      "void main(void) {\n"
      "  vec2 uv = -1.0 + 2.0 * vUV.xy;\n"
      "  uv.y *= resolution.y / resolution.x;\n"
      "  gl_FragColor = vec4(worley(uv));\n"
      "}\n";

  // Kintsugi ( https://www.shadertoy.com/view/Xt33WX )
  static constexpr const char* custom9FragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float time;\n"
      "uniform float aspectRatio;\n"
      "uniform vec2 resolution;\n"
      "\n"
      "//\n"
      "// Description : Array and textureless GLSL 2D simplex noise function.\n"
      "//      Author : Ian McEwan, Ashima Arts.\n"
      "//  Maintainer : stegu\n"
      "//     Lastmod : 20110822 (ijm)\n"
      "//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n"
      "//               Distributed under the MIT License. See LICENSE file.\n"
      "//               https://github.com/ashima/webgl-noise\n"
      "//               https://github.com/stegu/webgl-noise\n"
      "//\n"
      "\n"
      "vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n"
      "\n"
      "vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n"
      "\n"
      "vec3 permute(vec3 x) { return mod289(((x * 34.0) + 1.0) * x); }\n"
      "\n"
      "float snoise(vec2 v) {\n"
      "  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n"
      "                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n"
      "                      -0.577350269189626, // -1.0 + 2.0 * C.x\n"
      "                      0.024390243902439); // 1.0 / 41.0\n"
      "                                          // First corner\n"
      "  vec2 i = floor(v + dot(v, C.yy));\n"
      "  vec2 x0 = v - i + dot(i, C.xx);\n"
      "\n"
      "  // Other corners\n"
      "  vec2 i1;\n"
      "  // i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n"
      "  // i1.y = 1.0 - i1.x;\n"
      "  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n"
      "  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n"
      "  // x1 = x0 - i1 + 1.0 * C.xx ;\n"
      "  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n"
      "  vec4 x12 = x0.xyxy + C.xxzz;\n"
      "  x12.xy -= i1;\n"
      "\n"
      "  // Permutations\n"
      "  i = mod289(i); // Avoid truncation effects in permutation\n"
      "  vec3 p =\n"
      "      permute(permute(i.y + vec3(0.0, i1.y, 1.0)) +\n"
      "                      i.x + vec3(0.0, i1.x, 1.0));\n"
      "\n"
      "  vec3 m = max(\n"
      "      0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),\n"
      "                 dot(x12.zw, x12.zw)), 0.0);\n"
      "  m = m * m;\n"
      "  m = m * m;\n"
      "\n"
      "  // Gradients: 41 points uniformly over a line,\n"
      "  //            mapped onto a diamond.\n"
      "  // The ring size 17*17 = 289 is close to a multiple of\n"
      "  // 41 (41*7 = 287)\n"
      "\n"
      "  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n"
      "  vec3 h = abs(x) - 0.5;\n"
      "  vec3 ox = floor(x + 0.5);\n"
      "  vec3 a0 = x - ox;\n"
      "\n"
      "  // Normalise gradients implicitly by scaling m\n"
      "  // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n"
      "  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n"
      "\n"
      "  // Compute final noise value at P\n"
      "  vec3 g;\n"
      "  g.x = a0.x * x0.x + h.x * x0.y;\n"
      "  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n"
      "  return 130.0 * dot(m, g);\n"
      "}\n"
      "\n"
      "float turbulence(vec2 P) {\n"
      "  float val = 0.0;\n"
      "  float freq = 0.7;\n"
      "  for (int i = 0; i < 5; i++) {\n"
      "    val += snoise(P * freq);\n"
      "    // freq *= 2.07;\n"
      "    freq *= 1.57;\n"
      "  }\n"
      "  return val;\n"
      "}\n"
      "\n"
      "// Expects -1<x<1\n"
      "vec4 marble_color(float x) {\n"
      "  vec4 col;\n"
      "  x = 0.5 * (x + 1.0);          // transform -1<x<1 to 0<x<1\n"
      "  for (int i = 0; i < 3; i++) { // make x fall of rapidly...\n"
      "    x = sqrt(x);\n"
      "  }\n"
      "\n"
      "  if (x <= 0.45) {\n"
      "    col.r = 1.0;\n"
      "    col.g = 0.84;\n"
      "    col.b = 0.0;\n"
      "    col *= vec4(1.95 - x) * 0.55;\n"
      "    col.a = 1.0;\n"
      "  } else {\n"
      "    col = vec4(x);\n"
      "  }\n"
      "\n"
      "  col.r = min(col.r, 1.0);\n"
      "  col.g = min(col.g, 1.0);\n"
      "  col.b = min(col.b, 1.0);\n"
      "\n"
      "  return col;\n"
      "}\n"
      "\n"
      "void main(void) {\n"
      "  vec2 uv = -1.0 + 2.0 * vUV;\n"
      "  float amplitude = 2.0;\n"
      "\n"
      "#ifdef ANIMATE\n"
      "  float iTime = time;\n"
      "#else\n"
      "  float iTime = 0.0;\n"
      "#endif\n"
      "\n"
      "  float t = uv.x * 10.0;\n"
      "  t += amplitude * turbulence(uv.xy + vec2(iTime / 40.0));\n"
      "  t = sin(t);\n"
      "  gl_FragColor = marble_color(t);\n"
      "}\n";

public:
  ShaderMaterialTilesScene(ICanvas* iCanvas);
  ~ShaderMaterialTilesScene() override;

  const char* getName() override;
  void initializeScene(ICanvas* canvas, Scene* scene) override;

private:
  EffectShadersStore _effectShadersStore;
  float _time;
  std::array<ShaderMaterial*, 9> _shaderMaterials;
  Vector2 _boxTopFaceResolution;
  float _boxTopFaceAspectRatio;

}; // end of class ShaderMaterialTilesScene

} // end of namespace Samples
} // end of namespace BABYLON

#endif // end of BABYLON_SAMPLES_MATERIALS_SHADER_MATERIAL_TILES_SCENE_H
