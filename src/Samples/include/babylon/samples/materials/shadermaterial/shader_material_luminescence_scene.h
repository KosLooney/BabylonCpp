#ifndef BABYLON_SAMPLES_MATERIALS_SHADER_MATERIAL_LUMINESCENCE_SCENE_H
#define BABYLON_SAMPLES_MATERIALS_SHADER_MATERIAL_LUMINESCENCE_SCENE_H

#include <babylon/interfaces/irenderable_scene.h>

namespace BABYLON {
namespace Samples {

class ShaderMaterialLuminescenceScene : public IRenderableScene {

public:
  /** Vertex Shader **/
  static constexpr const char* customVertexShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Attributes\n"
      "attribute vec3 position;\n"
      "attribute vec2 uv;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "\n"
      "// Varying\n"
      "varying vec2 vUV;\n"
      "\n"
      "void main(void) {\n"
      "    gl_Position = worldViewProjection * vec4(position, 1.0);\n"
      "    vUV = uv;\n"
      "}\n";

  /** Pixel (Fragment) Shader **/
  // Luminescence ( https://www.shadertoy.com/view/4sXBRn )
  static constexpr const char* customFragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float iTime;\n"
      "uniform float iAspectRatio;\n"
      "uniform vec2 iMouse;\n"
      "uniform vec2 iResolution;\n"
      "\n"
      "// Luminescence by Martijn Steinrucken aka BigWings - 2017\n"
      "// countfrolic@gmail.com\n"
      "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n"
      "// Unported License.\n"
      "\n"
      "// My entry for the monthly challenge (May 2017) on\n"
      "// r/proceduralgeneration\n"
      "// Use the mouse to look around. Uncomment the SINGLE define to see\n"
      "// one specimen by itself. Code is a bit of a mess, too lazy to clean\n"
      "// up. Hope you like it!\n"
      "\n"
      "// Music by Klaus Lunde\n"
      "// https://soundcloud.com/klauslunde/zebra-tribute\n"
      "\n"
      "// YouTube: The Art of Code ->\n"
      "// https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg Twitter:\n"
      "// @Steinrucken\n"
      "\n"
      "#define INVERTMOUSE -1.\n"
      "\n"
      "#define MAX_STEPS 100.\n"
      "#define VOLUME_STEPS 8.\n"
      "//#define SINGLE\n"
      "#define MIN_DISTANCE 0.1\n"
      "#define MAX_DISTANCE 100.\n"
      "#define HIT_DISTANCE .01\n"
      "\n"
      "#define S(x, y, z) smoothstep(x, y, z)\n"
      "#define B(x, y, z, w) S(x - z, x + z, w) * S(y + z, y - z, w)\n"
      "#define sat(x) clamp(x, 0., 1.)\n"
      "#define SIN(x) sin(x) * .5 + .5\n"
      "\n"
      "const vec3 lf = vec3(1., 0., 0.);\n"
      "const vec3 up = vec3(0., 1., 0.);\n"
      "const vec3 fw = vec3(0., 0., 1.);\n"
      "\n"
      "const float halfpi = 1.570796326794896619;\n"
      "const float pi = 3.141592653589793238;\n"
      "const float twopi = 6.283185307179586;\n"
      "\n"
      "vec3 accentColor1 = vec3(1., .1, .5);\n"
      "vec3 secondColor1 = vec3(.1, .5, 1.);\n"
      "\n"
      "vec3 accentColor2 = vec3(1., .5, .1);\n"
      "vec3 secondColor2 = vec3(.1, .5, .6);\n"
      "\n"
      "vec3 bg;     // global background color\n"
      "vec3 accent; // color of the phosphorecence\n"
      "\n"
      "float N1(float x) { return fract(sin(x) * 5346.1764); }\n"
      "float N2(float x, float y) { return N1(x + y * 23414.324); }\n"
      "\n"
      "float N3(vec3 p) {\n"
      "  p = fract(p * 0.3183099 + .1);\n"
      "  p *= 17.0;\n"
      "  return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n"
      "}\n"
      "\n"
      "struct ray {\n"
      "  vec3 o;\n"
      "  vec3 d;\n"
      "};\n"
      "\n"
      "struct camera {\n"
      "  vec3 p;       // the position of the camera\n"
      "  vec3 forward; // the camera forward vector\n"
      "  vec3 left;    // the camera left vector\n"
      "  vec3 up;      // the camera up vector\n"
      "\n"
      "  vec3 center; // the center of the screen, in world coords\n"
      "  vec3 i;      // where the current ray intersects the screen,\n"
      "               // in world coords\n"
      "  ray ray;     // the current ray: from cam pos, through current uv\n"
      "               // projected on screen\n"
      "  vec3 lookAt; // the lookat point\n"
      "  float zoom;  // the zoom factor\n"
      "};\n"
      "\n"
      "struct de {\n"
      "  // data type used to pass the various bits of information used to\n"
      "  // shade an object\n"
      "  float d; // final distance to field\n"
      "  float m; // material\n"
      "  vec3 uv;\n"
      "  float pump;\n"
      "\n"
      "  vec3 id;\n"
      "  vec3 pos; // the world-space coordinate of the fragment\n"
      "};\n"
      "\n"
      "struct rc {\n"
      "  // data type used to handle a repeated coordinate\n"
      "  vec3 id; // holds the floor'ed coordinate of each cell.\n"
      "           // Used to identify the cell.\n"
      "  vec3 h;  // half of the size of the cell\n"
      "  vec3 p;  // the repeated coordinate\n"
      "           // vec3 c;   // the center of the cell, world coordinates\n"
      "};\n"
      "\n"
      "rc Repeat(vec3 pos, vec3 size) {\n"
      "  rc o;\n"
      "  o.h = size * .5;\n"
      "  o.id = floor(pos / size); // used to give a unique id to each cell\n"
      "  o.p = mod(pos, size) - o.h;\n"
      "  // o.c = o.id*size+o.h;\n"
      "\n"
      "  return o;\n"
      "}\n"
      "\n"
      "camera cam;\n"
      "\n"
      "void CameraSetup(vec2 uv, vec3 position, vec3 lookAt, float zoom) {\n"
      "\n"
      "  cam.p = position;\n"
      "  cam.lookAt = lookAt;\n"
      "  cam.forward = normalize(cam.lookAt - cam.p);\n"
      "  cam.left = cross(up, cam.forward);\n"
      "  cam.up = cross(cam.forward, cam.left);\n"
      "  cam.zoom = zoom;\n"
      "\n"
      "  cam.center = cam.p + cam.forward * cam.zoom;\n"
      "  cam.i = cam.center + cam.left * uv.x + cam.up * uv.y;\n"
      "\n"
      "  cam.ray.o = cam.p;           // ray origin = camera position\n"
      "  cam.ray.d =\n"
      "     normalize(cam.i - cam.p); // ray direction is the vector from the\n"
      "                               // cam pos through the point on the\n"
      "                               // imaginary screen\n"
      "}\n"
      "\n"
      "// ============== Functions I borrowed ;)\n"
      "\n"
      "//  3 out, 1 in... DAVE HOSKINS\n"
      "vec3 N31(float p) {\n"
      "  vec3 p3 = fract(vec3(p) * vec3(.1031, .11369, .13787));\n"
      "  p3 += dot(p3, p3.yzx + 19.19);\n"
      "  return fract(\n"
      "      vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y,\n"
      "           (p3.y + p3.z) * p3.x));\n"
      "}\n"
      "\n"
      "// DE functions from IQ\n"
      "float smin(float a, float b, float k) {\n"
      "  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n"
      "  return mix(b, a, h) - k * h * (1.0 - h);\n"
      "}\n"
      "\n"
      "float smax(float a, float b, float k) {\n"
      "  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n"
      "  return mix(a, b, h) + k * h * (1.0 - h);\n"
      "}\n"
      "\n"
      "float sdSphere(vec3 p, vec3 pos, float s) {\n"
      "  return (length(p - pos) - s);\n"
      "}\n"
      "\n"
      "// From http://mercury.sexy/hg_sdf\n"
      "vec2 pModPolar(inout vec2 p, float repetitions, float fix) {\n"
      "  float angle = twopi / repetitions;\n"
      "  float a = atan(p.y, p.x) + angle / 2.;\n"
      "  float r = length(p);\n"
      "  float c = floor(a / angle);\n"
      "  a = mod(a, angle) - (angle / 2.) * fix;\n"
      "  p = vec2(cos(a), sin(a)) * r;\n"
      "\n"
      "  return p;\n"
      "}\n"
      "\n"
      "// -------------------------\n"
      "\n"
      "float Dist(vec2 P, vec2 P0, vec2 P1) {\n"
      "  // 2d point-line distance\n"
      "\n"
      "  vec2 v = P1 - P0;\n"
      "  vec2 w = P - P0;\n"
      "\n"
      "  float c1 = dot(w, v);\n"
      "  float c2 = dot(v, v);\n"
      "\n"
      "  if (c1 <= 0.) // before P0\n"
      "    return length(P - P0);\n"
      "\n"
      "  float b = c1 / c2;\n"
      "  vec2 Pb = P0 + b * v;\n"
      "  return length(P - Pb);\n"
      "}\n"
      "\n"
      "vec3 ClosestPoint(vec3 ro, vec3 rd, vec3 p) {\n"
      "  // returns the closest point on ray r to point p\n"
      "  return ro + max(0., dot(p - ro, rd)) * rd;\n"
      "}\n"
      "\n"
      "vec2 RayRayTs(vec3 ro1, vec3 rd1, vec3 ro2, vec3 rd2) {\n"
      "  // returns the two t's for the closest point between two rays\n"
      "  // ro+rd*t1 = ro2+rd2*t2\n"
      "\n"
      "  vec3 dO = ro2 - ro1;\n"
      "  vec3 cD = cross(rd1, rd2);\n"
      "  float v = dot(cD, cD);\n"
      "\n"
      "  float t1 = dot(cross(dO, rd2), cD) / v;\n"
      "  float t2 = dot(cross(dO, rd1), cD) / v;\n"
      "  return vec2(t1, t2);\n"
      "}\n"
      "\n"
      "float DistRaySegment(vec3 ro, vec3 rd, vec3 p1, vec3 p2) {\n"
      "  // returns the distance from ray r to line segment p1-p2\n"
      "  vec3 rd2 = p2 - p1;\n"
      "  vec2 t = RayRayTs(ro, rd, p1, rd2);\n"
      "\n"
      "  t.x = max(t.x, 0.);\n"
      "  t.y = clamp(t.y, 0., length(rd2));\n"
      "\n"
      "  vec3 rp = ro + rd * t.x;\n"
      "  vec3 sp = p1 + rd2 * t.y;\n"
      "\n"
      "  return length(rp - sp);\n"
      "}\n"
      "\n"
      "vec2 sph(vec3 ro, vec3 rd, vec3 pos, float radius) {\n"
      "  // does a ray sphere intersection\n"
      "  // returns a vec2 with distance to both intersections\n"
      "  // if both a and b are MAX_DISTANCE then there is no intersection\n"
      "\n"
      "  vec3 oc = pos - ro;\n"
      "  float l = dot(rd, oc);\n"
      "  float det = l * l - dot(oc, oc) + radius * radius;\n"
      "  if (det < 0.0)\n"
      "    return vec2(MAX_DISTANCE);\n"
      "\n"
      "  float d = sqrt(det);\n"
      "  float a = l - d;\n"
      "  float b = l + d;\n"
      "\n"
      "  return vec2(a, b);\n"
      "}\n"
      "\n"
      "vec3 background(vec3 r) {\n"
      "\n"
      "  float x = atan(r.x, r.z);       // from -pi to pi\n"
      "  float y = pi * 0.5 - acos(r.y); // from -1/2pi to 1/2pi\n"
      "\n"
      "  vec3 col = bg * (1. + y);\n"
      "\n"
      "  float t = iTime; // add god rays\n"
      "\n"
      "  float a = sin(r.x);\n"
      "\n"
      "  float beam = sat(sin(10. * x + a * y * 5. + t));\n"
      "  beam *= sat(sin(7. * x + a * y * 3.5 - t));\n"
      "\n"
      "  float beam2 = sat(sin(42. * x + a * y * 21. - t));\n"
      "  beam2 *= sat(sin(34. * x + a * y * 17. + t));\n"
      "\n"
      "  beam += beam2;\n"
      "  col *= 1. + beam * .05;\n"
      "\n"
      "  return col;\n"
      "}\n"
      "\n"
      "float remap(float a, float b, float c, float d, float t) {\n"
      "  return ((t - a) / (b - a)) * (d - c) + c;\n"
      "}\n"
      "\n"
      "de map(vec3 p, vec3 id) {\n"
      "\n"
      "  float t = iTime * 2.;\n"
      "\n"
      "  float N = N3(id);\n"
      "\n"
      "  de o;\n"
      "  o.m = 0.;\n"
      "\n"
      "  float x = (p.y + N * twopi) * 1. + t;\n"
      "  float r = 1.;\n"
      "\n"
      "  float pump = cos(x + cos(x)) + sin(2. * x) * .2 + sin(4. * x) * .02;\n"
      "\n"
      "  x = t + N * twopi;\n"
      "  p.y -= (cos(x + cos(x)) + sin(2. * x) * .2) * .6;\n"
      "  p.xz *= 1. + pump * .2;\n"
      "\n"
      "  float d1 = sdSphere(p, vec3(0., 0., 0.), r);\n"
      "  float d2 = sdSphere(p, vec3(0., -.5, 0.), r);\n"
      "\n"
      "  o.d = smax(d1, -d2, .1);\n"
      "  o.m = 1.;\n"
      "\n"
      "  if (p.y < .5) {\n"
      "    float sway = sin(t + p.y + N * twopi) * S(.5, -3., p.y) * N * .3;\n"
      "    p.x += sway * N; // add some sway to the tentacles\n"
      "    p.z += sway * (1. - N);\n"
      "\n"
      "    vec3 mp = p;\n"
      "    mp.xz = pModPolar(mp.xz, 6., 0.);\n"
      "\n"
      "    float d3 = length(mp.xz - vec2(.2, .1)) -\n"
      "               remap(.5, -3.5, .1, .01, mp.y);\n"
      "    if (d3 < o.d)\n"
      "      o.m = 2.;\n"
      "    d3 += (sin(mp.y * 10.) + sin(mp.y * 23.)) * .03;\n"
      "\n"
      "    float d32 =\n"
      "        length(mp.xz - vec2(.2, .1)) -\n"
      "        remap(.5, -3.5, .1, .04, mp.y) * .5;\n"
      "    d3 = min(d3, d32);\n"
      "    o.d = smin(o.d, d3, .5);\n"
      "\n"
      "    if (p.y < .2) {\n"
      "      vec3 op = p;\n"
      "      op.xz = pModPolar(op.xz, 13., 1.);\n"
      "\n"
      "      float d4 = length(op.xz - vec2(.85, .0)) -\n"
      "                 remap(.5, -3., .04, .0, op.y);\n"
      "      if (d4 < o.d)\n"
      "        o.m = 3.;\n"
      "      o.d = smin(o.d, d4, .15);\n"
      "    }\n"
      "  }\n"
      "  o.pump = pump;\n"
      "  o.uv = p;\n"
      "\n"
      "  o.d *= .8;\n"
      "  return o;\n"
      "}\n"
      "\n"
      "vec3 calcNormal(de o) {\n"
      "  vec3 eps = vec3(0.01, 0.0, 0.0);\n"
      "  vec3 nor = vec3(map(o.pos + eps.xyy, o.id).d -\n"
      "                  map(o.pos - eps.xyy, o.id).d,\n"
      "                  map(o.pos + eps.yxy, o.id).d -\n"
      "                  map(o.pos - eps.yxy, o.id).d,\n"
      "                  map(o.pos + eps.yyx, o.id).d -\n"
      "                  map(o.pos - eps.yyx, o.id).d);\n"
      "  return normalize(nor);\n"
      "}\n"
      "\n"
      "de CastRay(ray r) {\n"
      "  float d = 0.;\n"
      "  float dS = MAX_DISTANCE;\n"
      "\n"
      "  vec3 pos = vec3(0., 0., 0.);\n"
      "  vec3 n = vec3(0.);\n"
      "  de o, s;\n"
      "\n"
      "  float dC = MAX_DISTANCE;\n"
      "  vec3 p;\n"
      "  rc q;\n"
      "  float t = iTime;\n"
      "  vec3 grid = vec3(6., 30., 6.);\n"
      "\n"
      "  for (float i = 0.; i < MAX_STEPS; i++) {\n"
      "    p = r.o + r.d * d;\n"
      "\n"
      "#ifdef SINGLE\n"
      "    s = map(p, vec3(0.));\n"
      "#else\n"
      "    p.y -= t; // make the move up\n"
      "    p.x += t; // make cam fly forward\n"
      "\n"
      "    q = Repeat(p, grid);\n"
      "\n"
      "    vec3 rC =\n"
      "        ((2. * step(0., r.d) - 1.) *\n"
      "          q.h - q.p) / r.d; // ray to cell boundary\n"
      "    // distance to cell just past boundary\n"
      "    dC =\n"
      "        min(min(rC.x, rC.y), rC.z) + .01;\n"
      "\n"
      "    float N = N3(q.id);\n"
      "    q.p += (N31(N) - .5) * grid * vec3(.5, .7, .5);\n"
      "\n"
      "    if (Dist(q.p.xz, r.d.xz, vec2(0.)) < 1.1)\n"
      "      // if(DistRaySegment(q.p, r.d, vec3(0., -6., 0.),\n"
      "      //                   vec3(0., -3.3, 0)) <1.1)\n"
      "      s = map(q.p, q.id);\n"
      "    else\n"
      "      s.d = dC;\n"
      "\n"
      "#endif\n"
      "\n"
      "    if (s.d < HIT_DISTANCE || d > MAX_DISTANCE)\n"
      "      break;\n"
      "    d += min(\n"
      "        s.d,\n"
      "        dC); // move to distance to next cell or surface,"
      "             // whichever is closest\n"
      "  }\n"
      "\n"
      "  if (s.d < HIT_DISTANCE) {\n"
      "    o.m = s.m;\n"
      "    o.d = d;\n"
      "    o.id = q.id;\n"
      "    o.uv = s.uv;\n"
      "    o.pump = s.pump;\n"
      "\n"
      "#ifdef SINGLE\n"
      "    o.pos = p;\n"
      "#else\n"
      "    o.pos = q.p;\n"
      "#endif\n"
      "  }\n"
      "\n"
      "  return o;\n"
      "}\n"
      "\n"
      "float VolTex(vec3 uv, vec3 p, float scale, float pump) {\n"
      "  // uv = the surface pos\n"
      "  // p = the volume shell pos\n"
      "\n"
      "  p.y *= scale;\n"
      "\n"
      "  float s2 = 5. * p.x / twopi;\n"
      "  float id = floor(s2);\n"
      "  s2 = fract(s2);\n"
      "  vec2 ep = vec2(s2 - .5, p.y - .6);\n"
      "  float ed = length(ep);\n"
      "  float e = B(.35, .45, .05, ed);\n"
      "\n"
      "  float s = SIN(s2 * twopi * 15.);\n"
      "  s = s * s;\n"
      "  s = s * s;\n"
      "  s *= S(1.4, -.3, uv.y - cos(s2 * twopi) * .2 + .3) *\n"
      "       S(-.6, -.3, uv.y);\n"
      "\n"
      "  float t = iTime * 5.;\n"
      "  float mask = SIN(p.x * twopi * 2. + t);\n"
      "  s *= mask * mask * 2.;\n"
      "\n"
      "  return s + e * pump * 2.;\n"
      "}\n"
      "\n"
      "vec4 JellyTex(vec3 p) {\n"
      "  vec3 s = vec3(atan(p.x, p.z), length(p.xz), p.y);\n"
      "\n"
      "  float b = .75 + sin(s.x * 6.) * .25;\n"
      "  b = mix(1., b, s.y * s.y);\n"
      "\n"
      "  p.x += sin(s.z * 10.) * .1;\n"
      "  float b2 = cos(s.x * 26.) - s.z - .7;\n"
      "\n"
      "  b2 = S(.1, .6, b2);\n"
      "  return vec4(b + b2);\n"
      "}\n"
      "\n"
      "vec3 render(vec2 uv, ray camRay, float depth) {\n"
      "  // outputs a color\n"
      "\n"
      "  bg = background(cam.ray.d);\n"
      "\n"
      "  vec3 col = bg;\n"
      "  de o = CastRay(camRay);\n"
      "\n"
      "  float t = iTime;\n"
      "  vec3 L = up;\n"
      "\n"
      "  if (o.m > 0.) {\n"
      "    vec3 n = calcNormal(o);\n"
      "    float lambert = sat(dot(n, L));\n"
      "    vec3 R = reflect(camRay.d, n);\n"
      "    float fresnel = sat(1. + dot(camRay.d, n));\n"
      "    float trans = (1. - fresnel) * .5;\n"
      "    vec3 ref = background(R);\n"
      "    float fade = 0.;\n"
      "\n"
      "    if (o.m == 1.) { // hood color\n"
      "      float density = 0.;\n"
      "      for (float i = 0.; i < VOLUME_STEPS; i++) {\n"
      "        float sd = sph(o.uv, camRay.d, vec3(0.), .8 + i * .015).x;\n"
      "        if (sd != MAX_DISTANCE) {\n"
      "          vec2 intersect = o.uv.xz + camRay.d.xz * sd;\n"
      "\n"
      "          vec3 uv = vec3(atan(intersect.x, intersect.y),\n"
      "                         length(intersect.xy),\n"
      "                         o.uv.z);\n"
      "          density += VolTex(o.uv, uv, 1.4 + i * .03, o.pump);\n"
      "        }\n"
      "      }\n"
      "      vec4 volTex = vec4(accent, density / VOLUME_STEPS);\n"
      "\n"
      "      vec3 dif = JellyTex(o.uv).rgb;\n"
      "      dif *= max(.2, lambert);\n"
      "\n"
      "      col = mix(col, volTex.rgb, volTex.a);\n"
      "      col = mix(col, vec3(dif), .25);\n"
      "\n"
      "      col += fresnel * ref * sat(dot(up, n));\n"
      "\n"
      "      // fade\n"
      "      fade = max(fade, S(.0, 1., fresnel));\n"
      "    } else if (o.m == 2.) { // inside tentacles\n"
      "      vec3 dif = accent;\n"
      "      col = mix(bg, dif, fresnel);\n"
      "\n"
      "      col *= mix(.6, 1., S(0., -1.5, o.uv.y));\n"
      "\n"
      "      float prop = o.pump + .25;\n"
      "      prop *= prop * prop;\n"
      "      col += pow(1. - fresnel, 20.) * dif * prop;\n"
      "\n"
      "      fade = fresnel;\n"
      "    } else if (o.m == 3.) { // outside tentacles\n"
      "      vec3 dif = accent;\n"
      "      float d = S(100., 13., o.d);\n"
      "      col = mix(bg, dif, pow(1. - fresnel, 5.) * d);\n"
      "    }\n"
      "\n"
      "    fade = max(fade, S(0., 100., o.d));\n"
      "    col = mix(col, bg, fade);\n"
      "\n"
      "    if (o.m == 4.)\n"
      "      col = vec3(1., 0., 0.);\n"
      "  } else\n"
      "    col = bg;\n"
      "\n"
      "  return col;\n"
      "}\n"
      "\n"
      "void main(void) {\n"
      "  float t = iTime * .04;\n"
      "\n"
      "  vec2 uv = vUV.xy;\n"
      "  uv -= .5;\n"
      "  uv.y *= iResolution.y / iResolution.x;\n"
      "\n"
      "  vec2 m = iMouse.xy / iResolution.xy;\n"
      "\n"
      "  if (m.x < 0.05 ||\n"
      "      m.x > .95) { // move cam automatically when mouse is not used\n"
      "    m = vec2(t * .25, SIN(t * pi) * .5 + .5);\n"
      "  }\n"
      "\n"
      "  accent = mix(accentColor1, accentColor2, SIN(t * 15.456));\n"
      "  bg = mix(secondColor1, secondColor2, SIN(t * 7.345231));\n"
      "\n"
      "  float turn = (.1 - m.x) * twopi;\n"
      "  float s = sin(turn);\n"
      "  float c = cos(turn);\n"
      "  mat3 rotX = mat3(c, 0., s, 0., 1., 0., s, 0., -c);\n"
      "\n"
      "#ifdef SINGLE\n"
      "  float camDist = -10.;\n"
      "#else\n"
      "  float camDist = -.1;\n"
      "#endif\n"
      "\n"
      "  vec3 lookAt = vec3(0., -1., 0.);\n"
      "\n"
      "  vec3 camPos =\n"
      "      vec3(0., INVERTMOUSE * camDist * cos((m.y) * pi),\n"
      "           camDist) * rotX;\n"
      "\n"
      "  CameraSetup(uv, camPos + lookAt, lookAt, 1.);\n"
      "\n"
      "  vec3 col = render(uv, cam.ray, 0.);\n"
      "\n"
      "  col = pow(col, vec3(mix(1.5, 2.6, SIN(t + pi)))); // post-processing\n"
      "  float d = 1. - dot(uv, uv);                       // vignette\n"
      "  col *= (d * d * d) + .1;\n"
      "\n"
      "  gl_FragColor = vec4(col, 1.);\n"
      "}\n";

public:
  ShaderMaterialLuminescenceScene(ICanvas* iCanvas);
  ~ShaderMaterialLuminescenceScene() override;

  const char* getName() override;
  void initializeScene(ICanvas* canvas, Scene* scene) override;

private:
  float _time;
  ShaderMaterialPtr _shaderMaterial;

}; // end of class ShaderMaterialLuminescenceScene

} // end of namespace Samples
} // end of namespace BABYLON

#endif // end of
       // BABYLON_SAMPLES_MATERIALS_SHADER_MATERIAL_LUMINESCENCE_SCENE_H
