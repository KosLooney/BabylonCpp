#include <babylon/cameras/free_camera.h>
#include <babylon/engines/engine.h>
#include <babylon/engines/scene.h>
#include <babylon/interfaces/irenderable_scene.h>
#include <babylon/lights/hemispheric_light.h>
#include <babylon/materials/effect.h>
#include <babylon/materials/effect_shaders_store.h>
#include <babylon/materials/shader_material.h>
#include <babylon/meshes/builders/mesh_builder_options.h>
#include <babylon/meshes/mesh.h>
#include <babylon/meshes/mesh_builder.h>
#include <babylon/samples/samples_index.h>

namespace BABYLON {
namespace Samples {

class ShaderMaterialVoronoianWaterwayScene : public IRenderableScene {

public:
  /** Vertex Shader **/
  static constexpr const char* customVertexShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Attributes\n"
      "attribute vec3 position;\n"
      "attribute vec2 uv;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "\n"
      "// Varying\n"
      "varying vec2 vUV;\n"
      "\n"
      "void main(void) {\n"
      "    gl_Position = worldViewProjection * vec4(position, 1.0);\n"
      "    vUV = uv;\n"
      "}\n";

  /** Pixel (Fragment) Shader **/
  // Voronoian Waterway ( https://www.shadertoy.com/view/MlyXDV )
  static constexpr const char* customFragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float iTime;\n"
      "uniform float iAspectRatio;\n"
      "uniform vec2 iMouse;\n"
      "uniform vec2 iResolution;\n"
      "\n"
      "// 'Voronoian Waterway' by dr2 - 2017\n"
      "// License: Creative Commons\n"
      "// Attribution-NonCommercial-ShareAlike 3.0 Unported\n"
      "// License\n"
      "\n"
      "// Balloon flight in Voronoia.\n"
      "\n"
      "float PrSphDf(vec3 p, float s);\n"
      "float PrCylDf(vec3 p, float r, float h);\n"
      "vec2 Hashv2v2(vec2 p);\n"
      "float Noisefv2(vec2 p);\n"
      "float Noisefv3(vec3 p);\n"
      "float Fbm2(vec2 p);\n"
      "vec3 VaryNf(vec3 p, vec3 n, float f);\n"
      "vec2 Rot2D(vec2 q, float a);\n"
      "vec3 HsvToRgb(vec3 c);\n"
      "\n"
      "#define N_BAL 5\n"
      "\n"
      "mat3 vuMat;\n"
      "vec3 balPos[N_BAL], qHit, qHitFlm, vuPos, sunDir;\n"
      "float balRad = 0.0, flmCylRad = 0.0, flmCylLen = 0.0, tCur = 0.0,\n"
      "      dstFar = 0.0;\n"
      "int idObj, idGrp;\n"
      "bool balFlm[N_BAL], balFlmCur;\n"
      "const float pi = 3.14159;\n"
      "\n"
      "float VorDist(vec2 p) {\n"
      "  vec3 dv;\n"
      "  vec2 ip, fp, g, b;\n"
      "  ip = floor(p);\n"
      "  fp = fract(p);\n"
      "  dv = vec3(8.);\n"
      "  b.x = 0.;\n"
      "  for (float gy = -1.; gy <= 1.; gy++) {\n"
      "    for (float gx = -1.; gx <= 1.; gx++) {\n"
      "      g = vec2(gx, gy);\n"
      "      dv.z = length(g + 0.9 * Hashv2v2(ip + g) - fp);\n"
      "      b.y = step(dv.z, dv.y) * (dv.z - dv.y);\n"
      "      dv.xy += b + step(dv.z, dv.x) * (dv.zx - dv.xy - b);\n"
      "    }\n"
      "  }\n"
      "  return dv.y - dv.x;\n"
      "}\n"
      "\n"
      "float GrndHt(vec2 p) {\n"
      "  float s;\n"
      "  s = Noisefv2(0.7 * p.yx);\n"
      "  p += 0.2 * sin(2. * pi * s) +\n"
      "       0.1 * sin(2. * pi * Noisefv2(2. * p.xy));\n"
      "  return 5. * smoothstep(0.05, 0.6 + 0.2 * s, VorDist(0.07 * p));\n"
      "}\n"
      "\n"
      "float GrndRay(vec3 ro, vec3 rd) {\n"
      "  vec3 p;\n"
      "  float dHit, h, s, sLo, sHi;\n"
      "  s = 0.;\n"
      "  sLo = 0.;\n"
      "  dHit = dstFar;\n"
      "  for (int j = 0; j < 200; j++) {\n"
      "    p = ro + s * rd;\n"
      "    h = p.y - GrndHt(p.xz);\n"
      "    if (h < 0.)\n"
      "      break;\n"
      "    sLo = s;\n"
      "    s += max(0.2, 0.4 * h);\n"
      "    if (s > dstFar)\n"
      "      break;\n"
      "  }\n"
      "  if (h < 0.) {\n"
      "    sHi = s;\n"
      "    for (int j = 0; j < 5; j++) {\n"
      "      s = 0.5 * (sLo + sHi);\n"
      "      p = ro + s * rd;\n"
      "      if (p.y > GrndHt(p.xz))\n"
      "        sLo = s;\n"
      "      else\n"
      "        sHi = s;\n"
      "    }\n"
      "    dHit = 0.5 * (sLo + sHi);\n"
      "  }\n"
      "  return dHit;\n"
      "}\n"
      "\n"
      "vec3 GrndNf(vec3 p) {\n"
      "  float h;\n"
      "  h = GrndHt(p.xz);\n"
      "  vec2 e = vec2(0.01, 0.);\n"
      "  return normalize(vec3(h - GrndHt(p.xz + e.xy), e.x,\n"
      "                        h - GrndHt(p.xz + e.yx)));\n"
      "}\n"
      "\n"
      "float FlmDf(vec3 p) {\n"
      "  vec3 q;\n"
      "  float d, dMin;\n"
      "  dMin = dstFar;\n"
      "  for (int k = 0; k < N_BAL; k++) {\n"
      "    if (balFlm[k]) {\n"
      "      q = p - (balPos[k] - vec3(0., 0.8 * balRad, 0.));\n"
      "      d = PrCylDf(q.xzy, flmCylRad + 0.3 * q.y /\n"
      "                         flmCylLen, flmCylLen);\n"
      "      d = max(d, -q.y - 0.5 * flmCylLen);\n"
      "      if (d < dMin) {\n"
      "        dMin = d;\n"
      "        qHitFlm = q;\n"
      "      }\n"
      "    }\n"
      "  }\n"
      "  return dMin;\n"
      "}\n"
      "\n"
      "float FlmRay(vec3 ro, vec3 rd) {\n"
      "  float dHit, d;\n"
      "  dHit = 0.;\n"
      "  for (int j = 0; j < 100; j++) {\n"
      "    d = FlmDf(ro + dHit * rd);\n"
      "    dHit += d;\n"
      "    if (d < 0.001 || dHit > dstFar)\n"
      "      break;\n"
      "  }\n"
      "  if (d >= 0.001)\n"
      "    dHit = dstFar;\n"
      "  return dHit;\n"
      "}\n"
      "\n"
      "float BalDf(vec3 p, float dMin) {\n"
      "  vec3 q;\n"
      "  float d;\n"
      "  q = p;\n"
      "  d = max(PrSphDf(q, balRad), -PrSphDf(q, 0.98 * balRad));\n"
      "  q.y -= -balRad;\n"
      "  d = max(d, -PrCylDf(q.xzy, 0.3 * balRad, 0.1 * balRad));\n"
      "  if (d < dMin) {\n"
      "    dMin = d;\n"
      "    idObj = 1;\n"
      "    qHit = p;\n"
      "  }\n"
      "  q = p;\n"
      "  q.y -= -1.42 * balRad;\n"
      "  d = PrCylDf(q.xzy, 0.05 * balRad, 0.13 * balRad);\n"
      "  q.y -= 0.02 * balRad;\n"
      "  d = max(d, -PrCylDf(q.xzy, 0.03 * balRad, 0.13 * balRad));\n"
      "  if (d < dMin) {\n"
      "    dMin = d;\n"
      "    idObj = 2;\n"
      "    qHit = p;\n"
      "  }\n"
      "  q = p;\n"
      "  q.y -= -1.5 * balRad;\n"
      "  d = PrCylDf(q.xzy, 0.2 * balRad, 0.07 * balRad);\n"
      "  q.y -= 0.02 * balRad;\n"
      "  d = max(d, -PrCylDf(q.xzy, 0.18 * balRad, 0.07 * balRad));\n"
      "  if (d < dMin) {\n"
      "    dMin = d;\n"
      "    idObj = 3;\n"
      "    qHit = p;\n"
      "  }\n"
      "  q = p;\n"
      "  q.xz = abs(q.xz) - 0.25 * balRad;\n"
      "  q.y -= -1.15 * balRad;\n"
      "  q.yz = Rot2D(q.yz, -0.35);\n"
      "  q.xy = Rot2D(q.xy, 0.35);\n"
      "  d = PrCylDf(q.xzy, 0.005 * balRad, 0.35 * balRad);\n"
      "  if (d < dMin) {\n"
      "    dMin = d;\n"
      "    idObj = 4;\n"
      "    qHit = p;\n"
      "  }\n"
      "  return dMin;\n"
      "}\n"
      "\n"
      "float ObjDf(vec3 p) {\n"
      "  float dMin, d;\n"
      "  dMin = dstFar;\n"
      "  for (int k = 0; k < N_BAL; k++) {\n"
      "    d = BalDf(p - balPos[k], dMin);\n"
      "    if (d < dMin) {\n"
      "      dMin = d;\n"
      "      idGrp = k;\n"
      "      balFlmCur = balFlm[k];\n"
      "    }\n"
      "  }\n"
      "  return dMin;\n"
      "}\n"
      "\n"
      "float ObjRay(vec3 ro, vec3 rd) {\n"
      "  float dHit, d;\n"
      "  dHit = 0.;\n"
      "  for (int j = 0; j < 100; j++) {\n"
      "    d = ObjDf(ro + dHit * rd);\n"
      "    dHit += d;\n"
      "    if (d < 0.001 || dHit > dstFar)\n"
      "      break;\n"
      "  }\n"
      "  return dHit;\n"
      "}\n"
      "\n"
      "vec3 ObjNf(vec3 p) {\n"
      "  vec4 v;\n"
      "  vec3 e = vec3(0.001, -0.001, 0.);\n"
      "  v = vec4(ObjDf(p + e.xxx), ObjDf(p + e.xyy), ObjDf(p + e.yxy),\n"
      "           ObjDf(p + e.yyx));\n"
      "  return normalize(vec3(v.x - v.y - v.z - v.w) + 2. * v.yzw);\n"
      "}\n"
      "\n"
      "vec3 SkyBg(vec3 rd) {\n"
      "  return vec3(0.2, 0.3, 0.5) + 0.1 * pow(1. - max(rd.y, 0.), 4.);\n"
      "}\n"
      "\n"
      "vec3 SkyCol(vec3 ro, vec3 rd) {\n"
      "  vec3 col;\n"
      "  float sd, f;\n"
      "  ro.x += 0.5 * tCur;\n"
      "  f = Fbm2(0.05 * (rd.xz * (100. - ro.y) / rd.y + ro.xz));\n"
      "  sd = pow(max(dot(rd, sunDir), 0.), 64.);\n"
      "  col = SkyBg(rd) +\n"
      "        (0.35 * sd + 0.65 * min(pow(sd, 4.), 0.3)) *\n"
      "        vec3(1., 1., 0.3);\n"
      "  return mix(col, vec3(0.85), clamp(f * rd.y + 0.1, 0., 1.));\n"
      "}\n"
      "\n"
      "vec3 FlmCol(vec3 p, vec3 rd) {\n"
      "  vec3 q, qq;\n"
      "  float a, f, dr;\n"
      "  a = 0.;\n"
      "  p.y -= -flmCylLen;\n"
      "  dr = 0.05 / flmCylRad;\n"
      "  for (int j = 0; j < 20; j++) {\n"
      "    p += dr * rd;\n"
      "    q = 15. * p / flmCylLen;\n"
      "    q.y -= 40. * tCur;\n"
      "    qq.y = Noisefv3(q + 0.1 * vec3(sin(tCur)));\n"
      "    qq.x = Noisefv3(q + vec3(qq.y));\n"
      "    qq.z = Noisefv3(q + vec3(qq.x));\n"
      "    q = p + 0.25 * (1. - 3. * p.y / flmCylLen) * (qq - 0.5);\n"
      "    f = 0.45 * q.y - 2.5 * length(q.xz);\n"
      "    f = clamp(sign(f) * f * f, 0., 1.) * (3. - 0.9 * q.y);\n"
      "    a += f;\n"
      "  }\n"
      "  return clamp(a * vec3(1., 0.5, 0.3), 0., 1.);\n"
      "}\n"
      "\n"
      "vec3 ShowScene(vec3 ro, vec3 rd) {\n"
      "  vec3 vn, col, colFlm;\n"
      "  float dstObj, dstFlm, dstGrnd, f, a;\n"
      "  bool inSun, inFlm;\n"
      "  dstGrnd = GrndRay(ro, rd);\n"
      "  dstFlm = FlmRay(ro, rd);\n"
      "  dstObj = ObjRay(ro, rd);\n"
      "  inSun = true;\n"
      "  inFlm = false;\n"
      "  if (dstObj < min(dstGrnd, dstFar)) {\n"
      "    ro += rd * dstObj;\n"
      "    vn = ObjNf(ro);\n"
      "    if (idObj == 1) {\n"
      "      col = HsvToRgb(vec3(float(idGrp) / float(N_BAL), 0.9, 0.8));\n"
      "      inFlm = balFlmCur;\n"
      "      if (length(qHit) < 0.99 * balRad) {\n"
      "        col *= 0.2;\n"
      "        if (inFlm)\n"
      "          col += 0.1 * vec3(1., 0.5, 0.);\n"
      "        inSun = false;\n"
      "      } else {\n"
      "        if (length(qHit) > 0.99 * balRad) {\n"
      "          a = atan(qHit.x, qHit.z) / (2. * pi) + 0.5;\n"
      "          vn.xz = Rot2D(vn.xz, 0.1 * pi * sin(pi *\n"
      "                       (0.5 - mod(24. * a, 1.))));\n"
      "        }\n"
      "      }\n"
      "    } else if (idObj == 2) {\n"
      "      a = atan(qHit.x, qHit.z) / (2. * pi) + 0.5;\n"
      "      vn.xz = Rot2D(vn.xz, 0.1 * pi * sin(pi *\n"
      "                    (0.5 - mod(12. * a, 1.))));\n"
      "      col = vec3(0.6);\n"
      "    } else if (idObj == 3) {\n"
      "      a = atan(qHit.x, qHit.z) / (2. * pi) + 0.5;\n"
      "      vn.xz = Rot2D(vn.xz, 0.1 * pi * sin(pi *\n"
      "                   (0.5 - mod(32. * a, 1.))));\n"
      "      col = vec3(0.6, 0.3, 0.);\n"
      "    } else if (idObj == 4) {\n"
      "      col = vec3(0.3);\n"
      "    }\n"
      "    if (inSun)\n"
      "      col = col * (0.2 +\n"
      "                   0.2 * max(dot(vn, -normalize(vec3(sunDir.x, 0.,\n"
      "                                                     sunDir.z))),\n"
      "                             0.) +\n"
      "                   0.6 * max(dot(vn, sunDir), 0.)) +\n"
      "            0.1 * pow(max(0., dot(sunDir, reflect(rd, vn))), 64.);\n"
      "  } else if (dstGrnd < dstFar) {\n"
      "    ro += dstGrnd * rd;\n"
      "    if (ro.y > 0.1) {\n"
      "      vn = VaryNf(1.3 * ro, GrndNf(ro), 5.);\n"
      "      f = clamp(0.7 * Noisefv2(ro.xz) - 0.3, 0., 1.);\n"
      "      col = mix(mix(vec3(0.4, 0.3, 0.), vec3(0.5, 0.4, 0.1), f),\n"
      "                mix(vec3(0.3, 0.7, 0.3), vec3(0.5, 0.6, 0.1), f),\n"
      "                (0.1 + 0.9 * smoothstep(0.1, 0.2, ro.y)) *\n"
      "                    clamp(1.2 * vn.y - 0.2, 0.2, 1.)) *\n"
      "                (0.3 + 0.7 * max(0., max(dot(vn, sunDir), 0.))) +\n"
      "            0.1 * pow(max(0., dot(sunDir, reflect(rd, vn))), 64.);\n"
      "    } else {\n"
      "      vn = VaryNf(5.1 * ro, vec3(0., 1., 0.), 0.2);\n"
      "      rd = reflect(rd, vn);\n"
      "      col = mix(vec3(0.15, 0.2, 0.15), vec3(0.1, 0.1, 0.2),\n"
      "                Fbm2(ro.xz));\n"
      "      col = mix(col, 0.8 * SkyCol(ro, rd),\n"
      "                smoothstep(0.8, 0.95, 1. - pow(dot(rd, vn), 3.)));\n"
      "    }\n"
      "    col = mix(col, SkyBg(rd),\n"
      "              max(pow(dstGrnd / dstFar, 4.) - 0.1, 0.));\n"
      "  } else\n"
      "    col = SkyCol(ro, rd);\n"
      "  if (dstFlm < min(min(dstGrnd, dstObj), dstFar)) {\n"
      "    colFlm = FlmCol(qHitFlm, rd);\n"
      "    col = mix(col, colFlm, 0.6 * length(colFlm));\n"
      "  }\n"
      "  if (inFlm)\n"
      "    col = mix(col, vec3(1., 0.5, 0.),\n"
      "              0.3 * pow(clamp(dot(normalize(qHit), -rd), 0., 1.),\n"
      "              4.));\n"
      "  return pow(clamp(col, 0., 1.), vec3(0.8));\n"
      "}\n"
      "\n"
      "vec3 TrackPath(float t) {\n"
      "  return vec3(30. * sin(0.35 * t) * sin(0.12 * t) * cos(0.1 * t) +\n"
      "                  26. * sin(0.032 * t),\n"
      "              1. + 3. * sin(0.21 * t) * sin(1. + 0.23 * t), 10. * t);\n"
      "}\n"
      "\n"
      "void VuPM(float t) {\n"
      "  vec3 fpF, fpB, vel, acc, va, ort, cr, sr;\n"
      "  float dt;\n"
      "  dt = 1.;\n"
      "  vuPos = TrackPath(t);\n"
      "  fpF = TrackPath(t + dt);\n"
      "  fpB = TrackPath(t - dt);\n"
      "  vel = (fpF - fpB) / (2. * dt);\n"
      "  vel.y = 0.;\n"
      "  acc = (fpF - 2. * vuPos + fpB) / (dt * dt);\n"
      "  acc.y = 0.;\n"
      "  va = cross(acc, vel) / length(vel);\n"
      "  ort =\n"
      "      vec3(0.2, atan(vel.z, vel.x) - 0.5 * pi,\n"
      "           0.02 * length(va) * sign(va.y));\n"
      "  cr = cos(ort);\n"
      "  sr = sin(ort);\n"
      "  vuMat = mat3(cr.z, -sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n"
      "          mat3(1., 0., 0., 0., cr.x, -sr.x, 0., sr.x, cr.x) *\n"
      "          mat3(cr.y, 0., -sr.y, 0., 1., 0., sr.y, 0., cr.y);\n"
      "}\n"
      "\n"
      "void main(void) {\n"
      "  mat3 vuMat2;\n"
      "  vec4 mPtr;\n"
      "  vec3 ro, rd;\n"
      "  vec2 canvas, uv, ori, ca, sa;\n"
      "  float az, el, s, a;\n"
      "  canvas = iResolution.xy;\n"
      "  uv = 2. * (-1.0 + 2.0 * vUV.xy);\n"
      "  uv.x *= canvas.x / canvas.y;\n"
      "  tCur = iTime;\n"
      "  mPtr = vec4(iMouse, 0., 0.);\n"
      "  mPtr.xy = mPtr.xy / canvas - 0.5;\n"
      "  sunDir = normalize(vec3(1., 0.5, 0.5));\n"
      "  dstFar = 200.;\n"
      "  balRad = 2.;\n"
      "  for (int k = 0; k < N_BAL; k++) {\n"
      "    s = float(k - 1) / float(N_BAL);\n"
      "    balPos[k] = TrackPath(0.5 * tCur + 3. + 7. * s);\n"
      "    a = 2. * pi * fract(0.037 * tCur + s);\n"
      "    balPos[k].y = 6.5 * balRad + 2. * balRad * sin(a);\n"
      "    balFlm[k] = (a > pi);\n"
      "  }\n"
      "  el = 0.;\n"
      "  az = 0.;\n"
      "  if (mPtr.z > 0.) {\n"
      "    el = clamp(el - 1.3 * pi * mPtr.y, -0.49 * pi, 0.49 * pi);\n"
      "    az = clamp(az - 1.8 * pi * mPtr.x, -pi, pi);\n"
      "  }\n"
      "  ori = vec2(el, az);\n"
      "  ca = cos(ori);\n"
      "  sa = sin(ori);\n"
      "  vuMat2 = mat3(1., 0., 0., 0., ca.x, -sa.x, 0., sa.x, ca.x) *\n"
      "           mat3(ca.y, 0., -sa.y, 0., 1., 0., sa.y, 0., ca.y);\n"
      "  VuPM(0.5 * tCur);\n"
      "  ro = vuPos;\n"
      "  ro.y += 6.5 * balRad + 2. * balRad * sin(2. * pi *\n"
      "         fract(0.07 * tCur));\n"
      "  rd = normalize(vec3(uv, 2.)) * vuMat2 * vuMat;\n"
      "  flmCylRad = 0.4;\n"
      "  flmCylLen = 2.;\n"
      "  gl_FragColor = vec4(ShowScene(ro, rd), 1.);\n"
      "}\n"
      "\n"
      "float PrSphDf(vec3 p, float s) { return length(p) - s; }\n"
      "\n"
      "float PrCylDf(vec3 p, float r, float h) {\n"
      "  return max(length(p.xy) - r, abs(p.z) - h);\n"
      "}\n"
      "\n"
      "vec2 Rot2D(vec2 q, float a) {\n"
      "  return q * cos(a) + q.yx * sin(a) * vec2(-1., 1.);\n"
      "}\n"
      "\n"
      "vec3 HsvToRgb(vec3 c) {\n"
      "  vec3 p = abs(fract(c.xxx + vec3(1., 2. / 3., 1. / 3.)) * 6. - 3.);\n"
      "  return c.z * mix(vec3(1.), clamp(p - 1., 0., 1.), c.y);\n"
      "}\n"
      "\n"
      "const vec4 cHashA4 = vec4(0., 1., 57., 58.);\n"
      "const vec3 cHashA3 = vec3(1., 57., 113.);\n"
      "const float cHashM = 43758.54;\n"
      "\n"
      "vec4 Hashv4f(float p) { return fract(sin(p + cHashA4) * cHashM); }\n"
      "\n"
      "vec2 Hashv2v2(vec2 p) {\n"
      "  const vec2 cHashVA2 = vec2(37.1, 61.7);\n"
      "  const vec2 e = vec2(1., 0.);\n"
      "  return fract(sin(vec2(dot(p + e.yy, cHashVA2),\n"
      "               dot(p + e.xy, cHashVA2))) * cHashM);\n"
      "}\n"
      "\n"
      "vec4 Hashv4v3(vec3 p) {\n"
      "  const vec3 cHashVA3 = vec3(37.1, 61.7, 12.4);\n"
      "  const vec3 e = vec3(1., 0., 0.);\n"
      "  return fract(sin(vec4(dot(p + e.yyy, cHashVA3),\n"
      "                        dot(p + e.xyy, cHashVA3),\n"
      "                        dot(p + e.yxy, cHashVA3),\n"
      "                        dot(p + e.xxy, cHashVA3))) *\n"
      "               cHashM);\n"
      "}\n"
      "\n"
      "float Noisefv2(vec2 p) {\n"
      "  vec2 i = floor(p);\n"
      "  vec2 f = fract(p);\n"
      "  f = f * f * (3. - 2. * f);\n"
      "  vec4 t = Hashv4f(dot(i, cHashA3.xy));\n"
      "  return mix(mix(t.x, t.y, f.x), mix(t.z, t.w, f.x), f.y);\n"
      "}\n"
      "\n"
      "float Noisefv3(vec3 p) {\n"
      "  vec4 t1, t2;\n"
      "  vec3 ip, fp;\n"
      "  float q;\n"
      "  ip = floor(p);\n"
      "  fp = fract(p);\n"
      "  fp = fp * fp * (3. - 2. * fp);\n"
      "  q = dot(ip, cHashA3);\n"
      "  t1 = Hashv4f(q);\n"
      "  t2 = Hashv4f(q + cHashA3.z);\n"
      "  return mix(mix(mix(t1.x, t1.y, fp.x), mix(t1.z, t1.w, fp.x), fp.y),\n"
      "             mix(mix(t2.x, t2.y, fp.x), mix(t2.z, t2.w, fp.x), fp.y),\n"
      "             fp.z);\n"
      "}\n"
      "float Fbm2(vec2 p) {\n"
      "  float f, a;\n"
      "  f = 0.;\n"
      "  a = 1.;\n"
      "  for (int i = 0; i < 5; i++) {\n"
      "    f += a * Noisefv2(p);\n"
      "    a *= 0.5;\n"
      "    p *= 2.;\n"
      "  }\n"
      "  return f * (1. / 1.9375);\n"
      "}\n"
      "\n"
      "float Fbmn(vec3 p, vec3 n) {\n"
      "  vec3 s;\n"
      "  float a;\n"
      "  s = vec3(0.);\n"
      "  a = 1.;\n"
      "  for (int i = 0; i < 5; i++) {\n"
      "    s += a * vec3(Noisefv2(p.yz), Noisefv2(p.zx), Noisefv2(p.xy));\n"
      "    a *= 0.5;\n"
      "    p *= 2.;\n"
      "  }\n"
      "  return dot(s, abs(n)) * (1. / 1.9375);\n"
      "}\n"
      "\n"
      "vec3 VaryNf(vec3 p, vec3 n, float f) {\n"
      "  vec3 g;\n"
      "  float s;\n"
      "  const vec3 e = vec3(0.1, 0., 0.);\n"
      "  s = Fbmn(p, n);\n"
      "  g = vec3(Fbmn(p + e.xyy, n) - s, Fbmn(p + e.yxy, n) - s,\n"
      "           Fbmn(p + e.yyx, n) - s);\n"
      "  return normalize(n + f * (g - n * dot(n, g)));\n"
      "}\n";

public:
  ShaderMaterialVoronoianWaterwayScene(ICanvas* iCanvas)
      : IRenderableScene(iCanvas), _time{0.f}, _shaderMaterial{nullptr}
  {
    // Vertex shader
    Effect::ShadersStore()["customVertexShader"] = customVertexShader;

    // Fragment shader
    Effect::ShadersStore()["customFragmentShader"] = customFragmentShader;
  }

  ~ShaderMaterialVoronoianWaterwayScene() override = default;

  const char* getName() override
  {
    return "Shader Material Voronoian Waterway Scene";
  }

  void initializeScene(ICanvas* canvas, Scene* scene) override
  {
    // Create a FreeCamera, and set its position to (x:0, y:0, z:-8)
    auto camera = FreeCamera::New("camera1", Vector3(0.f, 0.f, -8.f), scene);

    // Target the camera to scene origin
    camera->setTarget(Vector3::Zero());

    // Attach the camera to the canvas
    camera->attachControl(canvas, true);

    // Create a basic light, aiming 0,1,0 - meaning, to the sky
    HemisphericLight::New("light1", Vector3(0.f, 1.f, 0.f), scene);

    // Create a built-in "box" shape
    const float ratio = static_cast<float>(getEngine()->getRenderWidth())
                        / static_cast<float>(getEngine()->getRenderHeight());
    BoxOptions options;
    options.size            = 5.f;
    options.sideOrientation = Mesh::DEFAULTSIDE;
    options.updatable       = false;
    options.width           = *options.size * ratio;
    auto skybox             = MeshBuilder::CreateBox("skybox", options, scene);

    // Create shader material
    IShaderMaterialOptions shaderMaterialOptions;
    shaderMaterialOptions.attributes = {"position", "uv"};
    shaderMaterialOptions.uniforms
      = {"iTime", "worldViewProjection", "iAspectRatio", "iResolution", "iMouse"};
    _shaderMaterial = ShaderMaterial::New("boxShader", scene, "custom", shaderMaterialOptions);

    // box + sky = skybox !
    skybox->material = _shaderMaterial;

    // Animation
    scene->onAfterCameraRenderObservable.add([this](Camera*, EventState&) {
      const Vector2 resolution{static_cast<float>(_engine->getRenderWidth()),
                               static_cast<float>(_engine->getRenderHeight())};
      const Vector2 mouse{0.f, 0.f};
      const float aspectRatio = resolution.x / resolution.y;
      _shaderMaterial->setFloat("iTime", _time);
      _shaderMaterial->setFloat("iAspectRatio", aspectRatio);
      _shaderMaterial->setVector2("iResolution", resolution);
      _shaderMaterial->setVector2("iMouse", mouse);
      _time += 0.01f * getScene()->getAnimationRatio();
    });
  }

private:
  float _time;
  ShaderMaterialPtr _shaderMaterial;

}; // end of class ShaderMaterialVoronoianWaterwayScene

BABYLON_REGISTER_SAMPLE("Shader Materials", ShaderMaterialVoronoianWaterwayScene)

} // end of namespace Samples
} // end of namespace BABYLON
