#include <babylon/cameras/free_camera.h>
#include <babylon/engines/engine.h>
#include <babylon/engines/scene.h>
#include <babylon/interfaces/irenderable_scene.h>
#include <babylon/lights/hemispheric_light.h>
#include <babylon/materials/effect.h>
#include <babylon/materials/effect_shaders_store.h>
#include <babylon/materials/shader_material.h>
#include <babylon/meshes/builders/mesh_builder_options.h>
#include <babylon/meshes/mesh.h>
#include <babylon/meshes/mesh_builder.h>
#include <babylon/samples/samples_index.h>

namespace BABYLON {
namespace Samples {

class ShaderMaterialChainsAndGearsScene : public IRenderableScene {

public:
  /** Vertex Shader **/
  static constexpr const char* customVertexShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Attributes\n"
      "attribute vec3 position;\n"
      "attribute vec2 uv;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "\n"
      "// Varying\n"
      "varying vec2 vUV;\n"
      "\n"
      "void main(void) {\n"
      "    gl_Position = worldViewProjection * vec4(position, 1.0);\n"
      "    vUV = uv;\n"
      "}\n";

  /** Pixel (Fragment) Shader **/
  // Chains and Gears ( https://www.shadertoy.com/view/Msl3Rn )
  static constexpr const char* customFragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float iTime;\n"
      "uniform float iAspectRatio;\n"
      "uniform vec2 iMouse;\n"
      "uniform vec2 iResolution;\n"
      "\n"
      "\n"
      "// chains and gears - @P_Malin\n"
      "\n"
      "#define ENABLE_AMBIENT_OCCLUSION\n"
      "#define ENABLE_SPECULAR\n"
      "#define ENABLE_REFLECTIONS\n"
      "#define ENABLE_SHADOWS\n"
      "#define ENABLE_FOG\n"
      "\n"
      "//#define ENABLE_DIRECTIONAL_LIGHT\n"
      "//#define ENABLE_DIRECTIONAL_LIGHT_FLARE\n"
      "\n"
      "#define ENABLE_POINT_LIGHT\n"
      "//#define ENABLE_POINT_LIGHT_FLARE\n"
      "\n"
      "#define kRaymarchMaxIter 28\n"
      "\n"
      "const float kPI = 3.141592654;\n"
      "const float kTwoPI = kPI * 2.0;\n"
      "\n"
      "struct C_Ray {\n"
      "  vec3 vOrigin;\n"
      "  vec3 vDir;\n"
      "  float fStartDistance;\n"
      "  float fLength;\n"
      "};\n"
      "\n"
      "struct C_HitInfo {\n"
      "  vec3 vPos;\n"
      "  float fDistance;\n"
      "  vec3 vObjectId;\n"
      "};\n"
      "\n"
      "struct C_Surface {\n"
      "  vec3 vNormal;\n"
      "  vec3 cReflection;\n"
      "  vec3 cTransmission;\n"
      "};\n"
      "\n"
      "struct C_Material {\n"
      "  vec3 cAlbedo;\n"
      "  float fR0;\n"
      "  float fSmoothness;\n"
      "  vec2 vParam;\n"
      "};\n"
      "\n"
      "struct C_Shading {\n"
      "  vec3 cDiffuse;\n"
      "  vec3 cSpecular;\n"
      "};\n"
      "\n"
      "struct C_PointLight {\n"
      "  vec3 vPos;\n"
      "  vec3 cColour;\n"
      "};\n"
      "\n"
      "struct C_DirectionalLight {\n"
      "  vec3 vDir;\n"
      "  vec3 cColour;\n"
      "};\n"
      "\n"
      "vec3 RotateX(const in vec3 vPos, const in float fAngle) {\n"
      "  float s = sin(fAngle);\n"
      "  float c = cos(fAngle);\n"
      "\n"
      "  vec3 vResult =\n"
      "      vec3(vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n"
      "\n"
      "  return vResult;\n"
      "}\n"
      "\n"
      "vec3 RotateY(const in vec3 vPos, const in float fAngle) {\n"
      "  float s = sin(fAngle);\n"
      "  float c = cos(fAngle);\n"
      "\n"
      "  vec3 vResult =\n"
      "      vec3(c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n"
      "\n"
      "  return vResult;\n"
      "}\n"
      "\n"
      "vec3 RotateZ(const in vec3 vPos, const in float fAngle) {\n"
      "  float s = sin(fAngle);\n"
      "  float c = cos(fAngle);\n"
      "\n"
      "  vec3 vResult =\n"
      "      vec3(c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n"
      "\n"
      "  return vResult;\n"
      "}\n"
      "\n"
      "/////////////////////////////////////\n"
      "// Distance Field CSG\n"
      "// These carry with them the material parameters in yzw\n"
      "\n"
      "vec4 DistCombineUnion(const in vec4 v1, const in vec4 v2) {\n"
      "  // if(v1.x < v2.x) return v1; else return v2;\n"
      "  return mix(v1, v2, step(v2.x, v1.x));\n"
      "}\n"
      "\n"
      "vec4 DistCombineUnionConditional(const in vec4 v1, const in vec4 v2,\n"
      "                                 const in float fCondition) {\n"
      "  // if( fCondition < 0.0 )\n"
      "  //            return v1;\n"
      "\n"
      "  return mix(v1, v2, step(v2.x, v1.x) * step(0.0, fCondition));\n"
      "}\n"
      "\n"
      "vec4 DistCombineIntersect(const in vec4 v1, const in vec4 v2) {\n"
      "  return mix(v2, v1, step(v2.x, v1.x));\n"
      "}\n"
      "\n"
      "vec4 DistCombineSubtract(const in vec4 v1, const in vec4 v2) {\n"
      "  return DistCombineIntersect(v1, vec4(-v2.x, v2.yzw));\n"
      "}\n"
      "\n"
      "vec3 DomainRepeatXZGetTile(const in vec3 vPos, const in vec2 vRepeat,\n"
      "                           out vec2 vTile) {\n"
      "  vec3 vResult = vPos;\n"
      "  vec2 vTilePos = (vPos.xz / vRepeat) + 0.5;\n"
      "  vTile = floor(vTilePos + 1000.0);\n"
      "  vResult.xz = (fract(vTilePos) - 0.5) * vRepeat;\n"
      "  return vResult;\n"
      "}\n"
      "\n"
      "vec3 DomainRepeatXZ(const in vec3 vPos, const in vec2 vRepeat) {\n"
      "  vec3 vResult = vPos;\n"
      "  vec2 vTilePos = (vPos.xz / vRepeat) + 0.5;\n"
      "  vResult.xz = (fract(vTilePos) - 0.5) * vRepeat;\n"
      "  return vResult;\n"
      "}\n"
      "\n"
      "vec3 DomainRepeatY(const in vec3 vPos, const in float fSize) {\n"
      "  vec3 vResult = vPos;\n"
      "  vResult.y = (fract(vPos.y / fSize + 0.5) - 0.5) * fSize;\n"
      "  return vResult;\n"
      "}\n"
      "\n"
      "vec3 DomainRotateSymmetry(const in vec3 vPos, const in float fSteps) {\n"
      "  float angle = atan(vPos.x, vPos.z);\n"
      "\n"
      "  float fScale = fSteps / (kPI * 2.0);\n"
      "  float steppedAngle = (floor(angle * fScale + 0.5)) / fScale;\n"
      "\n"
      "  float s = sin(-steppedAngle);\n"
      "  float c = cos(-steppedAngle);\n"
      "\n"
      "  vec3 vResult =\n"
      "      vec3(c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n"
      "\n"
      "  return vResult;\n"
      "}\n"
      "\n"
      "float GetDistanceXYTorus(const in vec3 p, const in float r1,\n"
      "                         const in float r2) {\n"
      "  vec2 q = vec2(length(p.xy) - r1, p.z);\n"
      "  return length(q) - r2;\n"
      "}\n"
      "\n"
      "float GetDistanceYZTorus(const in vec3 p, const in float r1,\n"
      "                         const in float r2) {\n"
      "  vec2 q = vec2(length(p.yz) - r1, p.x);\n"
      "  return length(q) - r2;\n"
      "}\n"
      "\n"
      "float GetDistanceCylinderY(const in vec3 vPos, const in float r) {\n"
      "  return length(vPos.xz) - r;\n"
      "}\n"
      "\n"
      "float GetDistanceChain(const in vec3 vPos) {\n"
      "  float fOuterCylinder = length(vPos.xz) - 1.05;\n"
      "  if (fOuterCylinder > 0.5) {\n"
      "    return fOuterCylinder;\n"
      "  }\n"
      "\n"
      "  vec3 vChainDomain = vPos;\n"
      "\n"
      "  vChainDomain.y = fract(vChainDomain.y + 0.5) - 0.5;\n"
      "  float fDistTorus1 = GetDistanceXYTorus(vChainDomain, 0.35, 0.1);\n"
      "\n"
      "  vChainDomain.y = fract(vChainDomain.y + 1.0) - 0.5;\n"
      "  float fDistTorus2 = GetDistanceYZTorus(vChainDomain, 0.35, 0.1);\n"
      "\n"
      "  float fDist = min(fDistTorus1, fDistTorus2);\n"
      "\n"
      "  return fDist;\n"
      "}\n"
      "\n"
      "float GetDistanceGear(const in vec3 vPos) {\n"
      "  float fOuterCylinder = length(vPos.xz) - 1.05;\n"
      "  if (fOuterCylinder > 0.5) {\n"
      "    return fOuterCylinder;\n"
      "  }\n"
      "\n"
      "  vec3 vToothDomain = DomainRotateSymmetry(vPos, 16.0);\n"
      "  vToothDomain.xz = abs(vToothDomain.xz);\n"
      "  float fGearDist = dot(vToothDomain.xz, normalize(vec2(1.0, 0.55))) -\n"
      "                    0.55;\n"
      "  float fSlabDist = abs(vPos.y + 0.1) - 0.15;\n"
      "\n"
      "  vec3 vHoleDomain = abs(vPos);\n"
      "  vHoleDomain -= 0.35;\n"
      "  float fHoleDist = length(vHoleDomain.xz) - 0.2;\n"
      "\n"
      "  float fBarDist = vToothDomain.z - 0.15;\n"
      "  fBarDist = max(vPos.y - 0.1, fBarDist);\n"
      "\n"
      "  float fResult = fGearDist;\n"
      "  fResult = max(fResult, fSlabDist);\n"
      "  fResult = max(fResult, fOuterCylinder);\n"
      "  fResult = max(fResult, -fHoleDist);\n"
      "  fResult = min(fResult, fBarDist);\n"
      "  return fResult;\n"
      "}\n"
      "\n"
      "vec4 GetDistanceScene(const in vec3 vPos) {\n"
      "  vec2 vChainTile;\n"
      "  vec2 vRepeat = vec2(4.0, 8.0);\n"
      "  vec3 vRepeatDomain = DomainRepeatXZGetTile(vPos, vRepeat,\n"
      "                                             vChainTile);\n"
      "\n"
      "  vec4 vDistFloor = vec4(vPos.y + 0.5, 1.0, vec2(0.0));\n"
      "  vec4 vResult = vDistFloor;\n"
      "  {\n"
      "    vec3 vGearDomain1 = DomainRepeatXZ(vPos + vec3(0.0, 0.0, 4.0),\n"
      "                                       vRepeat);\n"
      "    vGearDomain1 = RotateY(vGearDomain1, iTime);\n"
      "    vec4 vDistGear = vec4(GetDistanceGear(vGearDomain1), 3.0,\n"
      "                          vec2(0.0));\n"
      "    vResult = DistCombineUnion(vResult, vDistGear);\n"
      "\n"
      "    vec3 vGearDomain2 = DomainRepeatXZ(vPos + vec3(2.0, 0.0, 4.0),\n"
      "                                       vRepeat);\n"
      "    vGearDomain2 = RotateY(vGearDomain2, -iTime + (2.0 * kPI / 32.0));\n"
      "    vec4 vDistGear2 = vec4(GetDistanceGear(vGearDomain2), 3.0,\n"
      "                           vec2(0.0));\n"
      "    vResult = DistCombineUnion(vResult, vDistGear2);\n"
      "  }\n"
      "\n"
      "  {\n"
      "    vec4 vDistChainHole =\n"
      "        vec4(GetDistanceCylinderY(vRepeatDomain, 0.7), 2.0,\n"
      "             vec2(0.0));\n"
      "    vResult = DistCombineSubtract(vResult, vDistChainHole);\n"
      "\n"
      "    vec3 vChainDomain = vRepeatDomain;\n"
      "    float fSpeed = (sin(vChainTile.y + vChainTile.x) + 1.1) * 0.5;\n"
      "    vChainDomain.y += sin(iTime * fSpeed);\n"
      "    vec4 vDistChain = vec4(GetDistanceChain(vChainDomain), 4.0,\n"
      "                          vec2(0.0));\n"
      "    vResult = DistCombineUnion(vResult, vDistChain);\n"
      "  }\n"
      "  return vResult;\n"
      "}\n"
      "\n"
      "C_Material GetObjectMaterial(const in C_HitInfo hitInfo) {\n"
      "  C_Material mat;\n"
      "\n"
      "  if (hitInfo.vObjectId.x < 1.5) {\n"
      "    // floor\n"
      "    mat.fR0 = 0.02;\n"
      "    mat.fSmoothness = 0.8;\n"
      "    mat.cAlbedo = vec3(0.7, 0.8, 0.3);\n"
      "  } else if (hitInfo.vObjectId.x < 2.5) {\n"
      "    // hole interior\n"
      "    mat.fR0 = 0.0;\n"
      "    mat.fSmoothness = 0.0;\n"
      "    mat.cAlbedo = vec3(0.7, 0.8, 0.3);\n"
      "  } else if (hitInfo.vObjectId.x < 3.5) {\n"
      "    // gear\n"
      "    mat.fR0 = 0.4;\n"
      "    mat.fSmoothness = 0.7;\n"
      "    mat.cAlbedo = vec3(0.5, 0.6, 0.6);\n"
      "  } else {\n"
      "    // chain\n"
      "    mat.fR0 = 0.2;\n"
      "    mat.fSmoothness = 0.1;\n"
      "    mat.cAlbedo = vec3(0.15, 0.125, 0.1);\n"
      "  }\n"
      "\n"
      "  return mat;\n"
      "}\n"
      "\n"
      "float GetRayFirstStep(const in C_Ray ray) {\n"
      "  return ray.fStartDistance;\n"
      "}\n"
      "\n"
      "vec3 GetSkyGradient(const in vec3 vDir) {\n"
      "  const vec3 cColourTop = vec3(0.7, 0.9, 1.0);\n"
      "  const vec3 cColourHorizon = vec3(0.2, 0.3, 0.4);\n"
      "\n"
      "  float fBlend = clamp(vDir.y, 0.0, 1.0);\n"
      "  return mix(cColourHorizon, cColourTop, fBlend);\n"
      "}\n"
      "\n"
      "C_PointLight GetPointLight() {\n"
      "  C_PointLight result;\n"
      "\n"
      "  result.vPos = vec3(sin(iTime), 2.0 + cos(iTime * 1.231),\n"
      "                     cos(iTime));\n"
      "  result.cColour = vec3(32.0, 6.0, 1.0);\n"
      "\n"
      "  return result;\n"
      "}\n"
      "\n"
      "C_DirectionalLight GetDirectionalLight() {\n"
      "  C_DirectionalLight result;\n"
      "\n"
      "  result.vDir = normalize(vec3(-0.2, -0.3, 0.5));\n"
      "  result.cColour = vec3(8.0, 7.5, 7.0);\n"
      "\n"
      "  return result;\n"
      "}\n"
      "\n"
      "vec3 GetAmbientLight(const in vec3 vNormal) {\n"
      "    return GetSkyGradient(vNormal);\n"
      "}\n"
      "\n"
      "/////////////////////////////////////\n"
      "// Raymarching\n"
      "\n"
      "vec3 GetSceneNormal(const in vec3 vPos) {\n"
      "  // tetrahedron normal\n"
      "  const float fDelta = 0.01;\n"
      "\n"
      "  vec3 vOffset1 = vec3(fDelta, -fDelta, -fDelta);\n"
      "  vec3 vOffset2 = vec3(-fDelta, -fDelta, fDelta);\n"
      "  vec3 vOffset3 = vec3(-fDelta, fDelta, -fDelta);\n"
      "  vec3 vOffset4 = vec3(fDelta, fDelta, fDelta);\n"
      "\n"
      "  float f1 = GetDistanceScene(vPos + vOffset1).x;\n"
      "  float f2 = GetDistanceScene(vPos + vOffset2).x;\n"
      "  float f3 = GetDistanceScene(vPos + vOffset3).x;\n"
      "  float f4 = GetDistanceScene(vPos + vOffset4).x;\n"
      "\n"
      "  vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 +\n"
      "                 vOffset3 * f3 + vOffset4 * f4;\n"
      "\n"
      "  return normalize(vNormal);\n"
      "}\n"
      "\n"
      "#define kRaymarchEpsilon 0.01\n"
      "// This is an excellent resource on ray marching ->\n"
      "// "
      "http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n"
      "void Raymarch(const in C_Ray ray, out C_HitInfo result,\n"
      "              const int maxIter) {\n"
      "  result.fDistance = GetRayFirstStep(ray);\n"
      "  result.vObjectId.x = 0.0;\n"
      "\n"
      "  for (int i = 0; i <= kRaymarchMaxIter; i++) {\n"
      "    result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n"
      "    vec4 vSceneDist = GetDistanceScene(result.vPos);\n"
      "    result.vObjectId = vSceneDist.yzw;\n"
      "\n"
      "    // abs allows backward stepping - should only be necessary for non\n"
      "    // uniform distance functions\n"
      "    if ((abs(vSceneDist.x) <= kRaymarchEpsilon) ||\n"
      "        (result.fDistance >= ray.fLength) || (i > maxIter)) {\n"
      "      break;\n"
      "    }\n"
      "\n"
      "    result.fDistance = result.fDistance + vSceneDist.x;\n"
      "  }\n"
      "\n"
      "  if (result.fDistance >= ray.fLength) {\n"
      "    result.fDistance = 1000.0;\n"
      "    result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n"
      "    result.vObjectId.x = 0.0;\n"
      "  }\n"
      "}\n"
      "\n"
      "float GetShadow(const in vec3 vPos, const in vec3 vNormal,\n"
      "                const in vec3 vLightDir,\n"
      "                const in float fLightDistance){\n"
      "#ifdef ENABLE_SHADOWS\n"
      "  C_Ray shadowRay;\n"
      "  shadowRay.vDir = vLightDir;\n"
      "  shadowRay.vOrigin = vPos;\n"
      "  const float fShadowBias = 0.05;\n"
      "  shadowRay.fStartDistance = fShadowBias /\n"
      "                             abs(dot(vLightDir, vNormal));\n"
      "  shadowRay.fLength = fLightDistance - shadowRay.fStartDistance;\n"
      "\n"
      "  C_HitInfo shadowIntersect;\n"
      "  Raymarch(shadowRay, shadowIntersect, 32);\n"
      "\n"
      "  float fShadow = step(0.0, shadowIntersect.fDistance) *\n"
      "                  step(fLightDistance, shadowIntersect.fDistance);\n"
      "\n"
      "  return fShadow;\n"
      "#else\n"
      "  return 1.0;\n"
      "#endif\n"
      "}\n"
      "\n"
      "// use distance field to evaluate ambient occlusion\n"
      "float GetAmbientOcclusion(const in C_HitInfo intersection,\n"
      "                          const in C_Surface surface) {\n"
      "#ifdef ENABLE_AMBIENT_OCCLUSION\n"
      "  vec3 vPos = intersection.vPos;\n"
      "  vec3 vNormal = surface.vNormal;\n"
      "\n"
      "  float fAmbientOcclusion = 1.0;\n"
      "\n"
      "  float fDist = 0.0;\n"
      "  for (int i = 0; i <= 5; i++) {\n"
      "    fDist += 0.1;\n"
      "\n"
      "    vec4 vSceneDist = GetDistanceScene(vPos + vNormal * fDist);\n"
      "\n"
      "    fAmbientOcclusion *= 1.0 - max(0.0, (fDist - vSceneDist.x) *\n"
      "                                   0.2 / fDist);\n"
      "  }\n"
      "\n"
      "  return fAmbientOcclusion;\n"
      "#else\n"
      "  return 1.0;\n"
      "#endif\n"
      "}\n"
      "\n"
      "  /////////////////////////////////////\n"
      "  // Lighting and Shading\n"
      "\n"
      "#define kFogDensity 0.1\n"
      "\n"
      "void ApplyAtmosphere(inout vec3 col, const in C_Ray ray,\n"
      "                     const in C_HitInfo hitInfo) {\n"
      "#ifdef ENABLE_FOG\n"
      "  // fog\n"
      "  float fFogAmount = exp(hitInfo.fDistance * -kFogDensity);\n"
      "  vec3 cFog = GetSkyGradient(ray.vDir);\n"
      "\n"
      "#ifdef ENABLE_DIRECTIONAL_LIGHT_FLARE\n"
      "  C_DirectionalLight directionalLight = GetDirectionalLight();\n"
      "  float fDirDot = clamp(dot(-directionalLight.vDir, ray.vDir), 0.0,\n"
      "                        1.0);\n"
      "  cFog += directionalLight.cColour * pow(fDirDot, 10.0);\n"
      "#endif\n"
      "\n"
      "  col = mix(cFog, col, fFogAmount);\n"
      "#endif\n"
      "\n"
      "// glare from light (a bit hacky - use length of closest approach from\n"
      "// ray to light)\n"
      "#ifdef ENABLE_POINT_LIGHT_FLARE\n"
      "  C_PointLight pointLight = GetPointLight();\n"
      "\n"
      "  vec3 vToLight = pointLight.vPos - ray.vOrigin;\n"
      "  float fPointDot = dot(vToLight, ray.vDir);\n"
      "  fPointDot = clamp(fPointDot, 0.0, hitInfo.fDistance);\n"
      "\n"
      "  vec3 vClosestPoint = ray.vOrigin + ray.vDir * fPointDot;\n"
      "  float fDist = length(vClosestPoint - pointLight.vPos);\n"
      "  col += pointLight.cColour * 0.01 / (fDist * fDist);\n"
      "#endif\n"
      "}\n"
      "\n"
      "// http://en.wikipedia.org/wiki/Schlick's_approximation\n"
      "float Schlick(const in vec3 vNormal, const in vec3 vView,\n"
      "              const in float fR0,\n"
      "              const in float fSmoothFactor) {\n"
      "  float fDot = dot(vNormal, -vView);\n"
      "  fDot = clamp((1.0 - fDot), 0.0, 1.0);\n"
      "  float fDotPow = pow(fDot, 5.0);\n"
      "  return fR0 + (1.0 - fR0) * fDotPow * fSmoothFactor;\n"
      "}\n"
      "\n"
      "vec3 ApplyFresnel(const in vec3 vDiffuse, const in vec3 vSpecular,\n"
      "                  const in vec3 vNormal, const in vec3 vView,\n"
      "                  const in C_Material material) {\n"
      "  float fFresnel =\n"
      "      Schlick(vNormal, vView, material.fR0,\n"
      "              material.fSmoothness * 0.9 + 0.1);\n"
      "  return mix(vDiffuse, vSpecular, fFresnel);\n"
      "}\n"
      "\n"
      "float GetBlinnPhongIntensity(const in vec3 vIncidentDir,\n"
      "                             const in vec3 vLightDir,\n"
      "                             const in vec3 vNormal,\n"
      "                             const in float fSmoothness) {\n"
      "  vec3 vHalf = normalize(vLightDir - vIncidentDir);\n"
      "  float fNdotH = max(0.0, dot(vHalf, vNormal));\n"
      "\n"
      "  float fSpecPower = exp2(4.0 + 6.0 * fSmoothness);\n"
      "  float fSpecIntensity = (fSpecPower + 2.0) * 0.125;\n"
      "\n"
      "  return pow(fNdotH, fSpecPower) * fSpecIntensity;\n"
      "}\n"
      "\n"
      "C_Shading ApplyPointLight(const in C_PointLight light,\n"
      "                          const in vec3 vSurfacePos,\n"
      "                          const in vec3 vIncidentDir,\n"
      "                          const in vec3 vNormal,\n"
      "                          const in C_Material material) {\n"
      "  C_Shading shading;\n"
      "\n"
      "  vec3 vToLight = light.vPos - vSurfacePos;\n"
      "  vec3 vLightDir = normalize(vToLight);\n"
      "  float fLightDistance = length(vToLight);\n"
      "\n"
      "  float fAttenuation = 1.0 / (fLightDistance * fLightDistance);\n"
      "\n"
      "  float fShadowFactor =\n"
      "      GetShadow(vSurfacePos, vNormal, vLightDir, fLightDistance);\n"
      "  vec3 vIncidentLight = light.cColour * fShadowFactor * fAttenuation *\n"
      "                        max(0.0, dot(vLightDir, vNormal));\n"
      "\n"
      "  shading.cDiffuse = vIncidentLight;\n"
      "  shading.cSpecular = GetBlinnPhongIntensity(vIncidentDir, vLightDir,\n"
      "                                             vNormal,\n"
      "                                             material.fSmoothness) *\n"
      "                      vIncidentLight;\n"
      "\n"
      "  return shading;\n"
      "}\n"
      "\n"
      "C_Shading ApplyDirectionalLight(const in C_DirectionalLight light,\n"
      "                                const in vec3 vSurfacePos,\n"
      "                                const in vec3 vIncidentDir,\n"
      "                                const in vec3 vNormal,\n"
      "                                const in C_Material material) {\n"
      "  C_Shading shading;\n"
      "\n"
      "  const float kShadowRayLength = 10.0;\n"
      "  vec3 vLightDir = -light.vDir;\n"
      "  float fShadowFactor =\n"
      "      GetShadow(vSurfacePos, vNormal, vLightDir, kShadowRayLength);\n"
      "  vec3 vIncidentLight =\n"
      "      light.cColour * fShadowFactor *\n"
      "      max(0.0, dot(vLightDir, vNormal));\n"
      "\n"
      "  shading.cDiffuse = vIncidentLight;\n"
      "  shading.cSpecular = GetBlinnPhongIntensity(vIncidentDir, vLightDir,\n"
      "                                             vNormal,\n"
      "                                             material.fSmoothness) *\n"
      "                      vIncidentLight;\n"
      "\n"
      "  return shading;\n"
      "}\n"
      "\n"
      "vec3 ShadeSurface(const in C_Ray ray, const in C_HitInfo hitInfo,\n"
      "                  const in C_Surface surface,\n"
      "                  const in C_Material material) {\n"
      "  vec3 cScene;\n"
      "\n"
      "  C_Shading shading;\n"
      "\n"
      "  shading.cDiffuse = vec3(0.0);\n"
      "  shading.cSpecular = vec3(0.0);\n"
      "\n"
      "  float fAmbientOcclusion = GetAmbientOcclusion(hitInfo, surface);\n"
      "  vec3 vAmbientLight = GetAmbientLight(surface.vNormal) *\n"
      "                       fAmbientOcclusion;\n"
      "\n"
      "  shading.cDiffuse += vAmbientLight;\n"
      "  shading.cSpecular += surface.cReflection;\n"
      "\n"
      "#ifdef ENABLE_POINT_LIGHT\n"
      "  C_PointLight pointLight = GetPointLight();\n"
      "  C_Shading pointLighting = ApplyPointLight(pointLight, hitInfo.vPos,\n"
      "                                            ray.vDir,\n"
      "                                            surface.vNormal, "
      "material);\n"
      "  shading.cDiffuse += pointLighting.cDiffuse;\n"
      "  shading.cSpecular += pointLighting.cSpecular;\n"
      "#endif\n"
      "\n"
      "#ifdef ENABLE_DIRECTIONAL_LIGHT\n"
      "  C_DirectionalLight directionalLight = GetDirectionalLight();\n"
      "  C_Shading directionLighting = ApplyDirectionalLight(\n"
      "      directionalLight, hitInfo.vPos, ray.vDir,\n"
      "      surface.vNormal, material);\n"
      "  shading.cDiffuse += directionLighting.cDiffuse;\n"
      "  shading.cSpecular += directionLighting.cSpecular;\n"
      "#endif\n"
      "\n"
      "  // fire in the hole\n"
      "  shading.cDiffuse +=\n"
      "      clamp(-hitInfo.vPos.y - 0.5, 0.0, 1.0) * vec3(5.0, 0.25, 0.05);\n"
      "\n"
      "  vec3 vDiffuseReflection = shading.cDiffuse * material.cAlbedo;\n"
      "\n"
      "#ifdef ENABLE_SPECULAR\n"
      "  cScene = ApplyFresnel(vDiffuseReflection, shading.cSpecular,\n"
      "                        surface.vNormal,\n"
      "                        ray.vDir, material);\n"
      "#else\n"
      "  cScene = vDiffuseReflection;\n"
      "#endif\n"
      "\n"
      "  return cScene;\n"
      "}\n"
      "\n"
      "vec3 GetSceneColourSecondary(const in C_Ray ray);\n"
      "\n"
      "vec3 GetReflection(const in C_Ray ray, const in C_HitInfo hitInfo,\n"
      "                   const in C_Surface surface) {\n"
      "#ifdef ENABLE_REFLECTIONS\n"
      "  {\n"
      "    // get colour from reflected ray\n"
      "    const float fSeparation = 0.1;\n"
      "\n"
      "    C_Ray reflectRay;\n"
      "    reflectRay.vDir = reflect(ray.vDir, surface.vNormal);\n"
      "    reflectRay.vOrigin = hitInfo.vPos;\n"
      "    reflectRay.fLength = 16.0;\n"
      "    reflectRay.fStartDistance =\n"
      "        fSeparation / abs(dot(reflectRay.vDir, surface.vNormal));\n"
      "\n"
      "    return GetSceneColourSecondary(reflectRay);\n"
      "  }\n"
      "#else\n"
      "  return GetSkyGradient(reflect(ray.vDir, surface.vNormal));\n"
      "#endif\n"
      "}\n"
      "\n"
      "// no reflections, no transparency, used for secondary rays\n"
      "vec3 GetSceneColourSecondary(const in C_Ray ray) {\n"
      "  C_HitInfo hitInfo;\n"
      "  Raymarch(ray, hitInfo, 32);\n"
      "\n"
      "  vec3 cScene;\n"
      "\n"
      "  if (hitInfo.vObjectId.x < 0.5) {\n"
      "    cScene = GetSkyGradient(ray.vDir);\n"
      "  } else {\n"
      "    C_Surface surface;\n"
      "    surface.vNormal = GetSceneNormal(hitInfo.vPos);\n"
      "\n"
      "    C_Material material = GetObjectMaterial(hitInfo);\n"
      "\n"
      "    // use sky gradient instead of reflection\n"
      "    surface.cReflection = GetSkyGradient(reflect(ray.vDir,\n"
      "                                                 surface.vNormal));\n"
      "\n"
      "    // apply lighting\n"
      "    cScene = ShadeSurface(ray, hitInfo, surface, material);\n"
      "  }\n"
      "\n"
      "  ApplyAtmosphere(cScene, ray, hitInfo);\n"
      "\n"
      "  return cScene;\n"
      "}\n"
      "\n"
      "vec3 GetSceneColourPrimary(const in C_Ray ray) {\n"
      "  C_HitInfo intersection;\n"
      "  Raymarch(ray, intersection, 256);\n"
      "\n"
      "  vec3 cScene;\n"
      "\n"
      "  if (intersection.vObjectId.x < 0.5) {\n"
      "    cScene = GetSkyGradient(ray.vDir);\n"
      "  } else {\n"
      "    C_Surface surface;\n"
      "\n"
      "    surface.vNormal = GetSceneNormal(intersection.vPos);\n"
      "\n"
      "    C_Material material = GetObjectMaterial(intersection);\n"
      "\n"
      "    surface.cReflection = GetReflection(ray, intersection, surface);\n"
      "\n"
      "    // apply lighting\n"
      "    cScene = ShadeSurface(ray, intersection, surface, material);\n"
      "  }\n"
      "\n"
      "  ApplyAtmosphere(cScene, ray, intersection);\n"
      "\n"
      "  return cScene;\n"
      "}\n"
      "\n"
      "float kFarClip = 30.0;\n"
      "\n"
      "void GetCameraRay(const in vec3 vPos, const in vec3 vForwards,\n"
      "                  const in vec3 vWorldUp, const in vec2 fragCoord,\n"
      "                  out C_Ray ray) {\n"
      "  vec2 vUV = vUV.xy;\n"
      "  vec2 vViewCoord = vUV * 2.0 - 1.0;\n"
      "\n"
      "  float fRatio = iResolution.x / iResolution.y;\n"
      "  vViewCoord.y /= fRatio;\n"
      "\n"
      "  ray.vOrigin = vPos;\n"
      "\n"
      "  vec3 vRight = normalize(cross(vForwards, vWorldUp));\n"
      "  vec3 vUp = cross(vRight, vForwards);\n"
      "\n"
      "  ray.vDir = normalize(vRight * vViewCoord.x + vUp * vViewCoord.y +\n"
      "                       vForwards);\n"
      "  ray.fStartDistance = 0.0;\n"
      "  ray.fLength = kFarClip;\n"
      "}\n"
      "\n"
      "void GetCameraRayLookat(const in vec3 vPos, const in vec3 vInterest,\n"
      "                        const in vec2 fragCoord, out C_Ray ray) {\n"
      "  vec3 vForwards = normalize(vInterest - vPos);\n"
      "  vec3 vUp = vec3(0.0, 1.0, 0.0);\n"
      "\n"
      "  GetCameraRay(vPos, vForwards, vUp, fragCoord, ray);\n"
      "}\n"
      "\n"
      "vec3 OrbitPoint(const in float fHeading, const in float fElevation) {\n"
      "  return vec3(sin(fHeading) * cos(fElevation), sin(fElevation),\n"
      "              cos(fHeading) * cos(fElevation));\n"
      "}\n"
      "\n"
      "vec3 Gamma(const in vec3 cCol) { return sqrt(cCol); }\n"
      "\n"
      "vec3 Tonemap(const in vec3 cCol) {\n"
      "  vec3 vResult = 1.0 - exp2(-cCol);\n"
      "\n"
      "  return vResult;\n"
      "}\n"
      "\n"
      "void main(void) {\n"
      "  C_Ray ray;\n"
      "\n"
      "  GetCameraRayLookat(OrbitPoint(iTime * 0.3,\n"
      "                                cos(iTime * 0.2) * 0.3 + 0.4) *\n"
      "                         7.0,\n"
      "                     vec3(0.0, 0.0, 0.0), gl_FragCoord.xy, ray);\n"
      "\n"
      "  vec3 cScene = GetSceneColourPrimary(ray);\n"
      "\n"
      "  const float fExposure = 1.5;\n"
      "  gl_FragColor = vec4(Tonemap(cScene * fExposure), 1.0);\n"
      "}\n";

public:
  ShaderMaterialChainsAndGearsScene(ICanvas* iCanvas)
      : IRenderableScene(iCanvas), _time{0.f}, _shaderMaterial{nullptr}
  {
    // Vertex shader
    Effect::ShadersStore()["customVertexShader"] = customVertexShader;

    // Fragment shader
    Effect::ShadersStore()["customFragmentShader"] = customFragmentShader;
  }

  ~ShaderMaterialChainsAndGearsScene() override = default;

  const char* getName() override
  {
    return "Shader Material Chains and Gears Scene";
  }
  void initializeScene(ICanvas* canvas, Scene* scene)
  {
    // Create a FreeCamera, and set its position to (x:0, y:0, z:-8)
    auto camera = FreeCamera::New("camera1", Vector3(0.f, 0.f, -8.f), scene);

    // Target the camera to scene origin
    camera->setTarget(Vector3::Zero());

    // Attach the camera to the canvas
    camera->attachControl(canvas, true);

    // Create a basic light, aiming 0,1,0 - meaning, to the sky
    HemisphericLight::New("light1", Vector3(0.f, 1.f, 0.f), scene);

    // Create a built-in "box" shape
    const float ratio = static_cast<float>(getEngine()->getRenderWidth())
                        / static_cast<float>(getEngine()->getRenderHeight());
    BoxOptions options;
    options.size            = 5.f;
    options.sideOrientation = Mesh::DEFAULTSIDE;
    options.updatable       = false;
    options.width           = *options.size * ratio;
    auto skybox             = MeshBuilder::CreateBox("skybox", options, scene);

    // Create shader material
    IShaderMaterialOptions shaderMaterialOptions;
    shaderMaterialOptions.attributes = {"position", "uv"};
    shaderMaterialOptions.uniforms
      = {"iTime", "worldViewProjection", "iAspectRatio", "iResolution", "iMouse"};
    _shaderMaterial = ShaderMaterial::New("boxShader", scene, "custom", shaderMaterialOptions);

    // box + sky = skybox !
    skybox->material = _shaderMaterial;

    // Animation
    scene->onAfterCameraRenderObservable.add([this](Camera*, EventState&) {
      const Vector2 resolution{static_cast<float>(_engine->getRenderWidth()),
                               static_cast<float>(_engine->getRenderHeight())};
      const Vector2 mouse{0.f, 0.f};
      const float aspectRatio = resolution.x / resolution.y;
      _shaderMaterial->setFloat("iTime", _time);
      _shaderMaterial->setFloat("iAspectRatio", aspectRatio);
      _shaderMaterial->setVector2("iResolution", resolution);
      _shaderMaterial->setVector2("iMouse", mouse);
      _time += 0.01f * getScene()->getAnimationRatio();
    });
  }

private:
  float _time;
  ShaderMaterialPtr _shaderMaterial;

}; // end of class ShaderMaterialChainsAndGearsScene

BABYLON_REGISTER_SAMPLE("Shader Materials", ShaderMaterialChainsAndGearsScene)

} // end of namespace Samples
} // end of namespace BABYLON
