#include <babylon/cameras/free_camera.h>
#include <babylon/engines/engine.h>
#include <babylon/engines/scene.h>
#include <babylon/interfaces/irenderable_scene.h>
#include <babylon/lights/hemispheric_light.h>
#include <babylon/materials/effect.h>
#include <babylon/materials/effect_shaders_store.h>
#include <babylon/materials/shader_material.h>
#include <babylon/meshes/builders/mesh_builder_options.h>
#include <babylon/meshes/mesh.h>
#include <babylon/meshes/mesh_builder.h>
#include <babylon/samples/samples_index.h>

namespace BABYLON {
namespace Samples {

class ShaderMaterialPlanetShadertoyScene : public IRenderableScene {

public:
  /** Vertex Shader **/
  static constexpr const char* customVertexShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Attributes\n"
      "attribute vec3 position;\n"
      "attribute vec2 uv;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "\n"
      "// Varying\n"
      "varying vec2 vUV;\n"
      "\n"
      "void main(void) {\n"
      "    gl_Position = worldViewProjection * vec4(position, 1.0);\n"
      "    vUV = uv;\n"
      "}\n";

  /** Pixel (Fragment) Shader **/
  // Planet Shadertoy ( https://www.shadertoy.com/view/4tjGRh )
  static constexpr const char* customFragmentShader
    = "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "\n"
      "// Varying\n"
      "varying vec3 vPosition;\n"
      "varying vec3 vNormal;\n"
      "varying vec2 vUV;\n"
      "\n"
      "// Uniforms\n"
      "uniform mat4 worldViewProjection;\n"
      "uniform float iTime;\n"
      "uniform float aspectRatio;\n"
      "uniform vec2 resolution;\n"
      "\n"
      "// Planet Shadertoy. Created by Reinder Nijhoff 2015\n"
      "// @reindernijhoff\n"
      "//\n"
      "// https://www.shadertoy.com/view/4tjGRh\n"
      "//\n"
      "\n"
      "//#define HIGH_QUALITY\n"
      "//#define MED_QUALITY\n"
      "//#define LOW_QUALITY\n"
      "#define VERY_LOW_QUALITY\n"
      "\n"
      "const float PI         = 3.14159265359;\n"
      "const float DEG_TO_RAD = (PI / 180.0);\n"
      "const float MAX        = 10000.0;\n"
      "\n"
      "const float EARTH_RADIUS     = 1000.;\n"
      "const float EARTH_ATMOSPHERE = 5.;\n"
      "const float EARTH_CLOUDS     = 1.;\n"
      "\n"
      "const float RING_INNER_RADIUS = 1500.;\n"
      "const float RING_OUTER_RADIUS = 2300.;\n"
      "const float RING_HEIGHT       = 2.;\n"
      "\n"
      "#ifdef HIGH_QUALITY\n"
      "const int SEA_NUM_STEPS              = 7;\n"
      "const int TERRAIN_NUM_STEPS          = 140;\n"
      "const int ASTEROID_NUM_STEPS         = 11;\n"
      "const int ASTEROID_NUM_BOOL_SUB      = 7;\n"
      "const int RING_VOXEL_STEPS           = 25;\n"
      "const float ASTEROID_MAX_DISTANCE    = 1.1;\n"
      "const int FBM_STEPS                  = 4;\n"
      "const int ATMOSPHERE_NUM_OUT_SCATTER = 5;\n"
      "const int ATMOSPHERE_NUM_IN_SCATTER  = 7;\n"
      "\n"
      "#define DISPLAY_LLAMEL\n"
      "#define DISPLAY_CLOUDS\n"
      "#define DISPLAY_CLOUDS_DETAIL\n"
      "#define DISPLAY_TERRAIN_DETAIL\n"
      "#endif\n"
      "\n"
      "#ifdef MED_QUALITY\n"
      "const int SEA_NUM_STEPS              = 6;\n"
      "const int TERRAIN_NUM_STEPS          = 100;\n"
      "const int ASTEROID_NUM_STEPS         = 10;\n"
      "const int ASTEROID_NUM_BOOL_SUB      = 6;\n"
      "const int RING_VOXEL_STEPS           = 24;\n"
      "const float ASTEROID_MAX_DISTANCE    = 1.;\n"
      "const int FBM_STEPS                  = 4;\n"
      "const int ATMOSPHERE_NUM_OUT_SCATTER = 4;\n"
      "const int ATMOSPHERE_NUM_IN_SCATTER  = 6;\n"
      "#define DISPLAY_CLOUDS\n"
      "#define DISPLAY_TERRAIN_DETAIL\n"
      "#define DISPLAY_CLOUDS_DETAIL\n"
      "#endif\n"
      "\n"
      "#ifdef LOW_QUALITY\n"
      "const int SEA_NUM_STEPS              = 5;\n"
      "const int TERRAIN_NUM_STEPS          = 75;\n"
      "const int ASTEROID_NUM_STEPS         = 9;\n"
      "const int ASTEROID_NUM_BOOL_SUB      = 5;\n"
      "const int RING_VOXEL_STEPS           = 20;\n"
      "const float ASTEROID_MAX_DISTANCE    = .85;\n"
      "const int FBM_STEPS                  = 3;\n"
      "const int ATMOSPHERE_NUM_OUT_SCATTER = 3;\n"
      "const int ATMOSPHERE_NUM_IN_SCATTER  = 5;\n"
      "#endif\n"
      "\n"
      "#ifdef VERY_LOW_QUALITY\n"
      "const int SEA_NUM_STEPS              = 4;\n"
      "const int TERRAIN_NUM_STEPS          = 60;\n"
      "const int ASTEROID_NUM_STEPS         = 7;\n"
      "const int ASTEROID_NUM_BOOL_SUB      = 4;\n"
      "const int RING_VOXEL_STEPS           = 16;\n"
      "const float ASTEROID_MAX_DISTANCE    = .67;\n"
      "const int FBM_STEPS                  = 3;\n"
      "const int ATMOSPHERE_NUM_OUT_SCATTER = 2;\n"
      "const int ATMOSPHERE_NUM_IN_SCATTER  = 4;\n"
      "#define HIDE_TERRAIN\n"
      "#endif\n"
      "\n"
      "const vec3 SUN_DIRECTION = vec3(.940721, .28221626, .18814417);\n"
      "const vec3 SUN_COLOR     = vec3(.3, .21, .165);\n"
      "\n"
      "float time;\n"
      "\n"
      "//-----------------------------------------------------\n"
      "// Noise functions\n"
      "//-----------------------------------------------------\n"
      "\n"
      "float hash(const in float n)\n"
      "{\n"
      "  return fract(sin(n) * 43758.5453123);\n"
      "}\n"
      "float hash(const in vec2 p)\n"
      "{\n"
      "  float h = dot(p, vec2(127.1, 311.7));\n"
      "  return fract(sin(h) * 43758.5453123);\n"
      "}\n"
      "float hash(const in vec3 p)\n"
      "{\n"
      "  float h = dot(p, vec3(127.1, 311.7, 758.5453123));\n"
      "  return fract(sin(h) * 43758.5453123);\n"
      "}\n"
      "vec3 hash31(const in float p)\n"
      "{\n"
      "  vec3 h = vec3(1275.231, 4461.7, 7182.423) * p;\n"
      "  return fract(sin(h) * 43758.543123);\n"
      "}\n"
      "vec3 hash33(const in vec3 p)\n"
      "{\n"
      "  return vec3(hash(p), hash(p.zyx), hash(p.yxz));\n"
      "}\n"
      "\n"
      "float noise(const in float p)\n"
      "{\n"
      "  float i = floor(p);\n"
      "  float f = fract(p);\n"
      "  float u = f * f * (3.0 - 2.0 * f);\n"
      "  return -1.0 + 2.0 * mix(hash(i + 0.), hash(i + 1.), u);\n"
      "}\n"
      "\n"
      "float noise(const in vec2 p)\n"
      "{\n"
      "  vec2 i = floor(p);\n"
      "  vec2 f = fract(p);\n"
      "  vec2 u = f * f * (3.0 - 2.0 * f);\n"
      "  return -1.0\n"
      "         + 2.0 * mix(mix(hash(i + vec2(0.0, 0.0)),\n"
      "                         hash(i + vec2(1.0, 0.0)), u.x),\n"
      "                     mix(hash(i + vec2(0.0, 1.0)),\n"
      "                         hash(i + vec2(1.0, 1.0)), u.x),\n"
      "                     u.y);\n"
      "}\n"
      "float noise(const in vec3 x)\n"
      "{\n"
      "  vec3 p  = floor(x);\n"
      "  vec3 f  = fract(x);\n"
      "  f       = f * f * (3.0 - 2.0 * f);\n"
      "  float n = p.x + p.y * 157.0 + 113.0 * p.z;\n"
      "  return mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n"
      "                 mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n"
      "             mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n"
      "                 mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y),\n"
      "             f.z);\n"
      "}\n"
      "\n"
      "float tri(const in vec2 p)\n"
      "{\n"
      "  return 0.5 * (cos(6.2831 * p.x) + cos(6.2831 * p.y));\n"
      "}\n"
      "\n"
      "const mat2 m2 = mat2(0.80, -0.60, 0.60, 0.80);\n"
      "\n"
      "float fbm(in vec2 p)\n"
      "{\n"
      "  float f = 0.0;\n"
      "  f += 0.5000 * noise(p);\n"
      "  p = m2 * p * 2.02;\n"
      "  f += 0.2500 * noise(p);\n"
      "  p = m2 * p * 2.03;\n"
      "  f += 0.1250 * noise(p);\n"
      "\n"
      "#ifndef LOW_QUALITY\n"
      "#ifndef VERY_LOW_QUALITY\n"
      "  p = m2 * p * 2.01;\n"
      "  f += 0.0625 * noise(p);\n"
      "#endif\n"
      "#endif\n"
      "  return f / 0.9375;\n"
      "}\n"
      "\n"
      "float fbm(const in vec3 p, const in float a, const in float f)\n"
      "{\n"
      "  float ret = 0.0;\n"
      "  float amp = 1.0;\n"
      "  float frq = 1.0;\n"
      "  for (int i = 0; i < FBM_STEPS; i++) {\n"
      "    float n = pow(noise(p * frq), 2.0);\n"
      "    ret += n * amp;\n"
      "    frq *= f;\n"
      "    amp *= a * (pow(n, 0.2));\n"
      "  }\n"
      "  return ret;\n"
      "}\n"
      "\n"
      "//-----------------------------------------------------\n"
      "// Lightning functions\n"
      "//-----------------------------------------------------\n"
      "\n"
      "float diffuse(const in vec3 n, const in vec3 l)\n"
      "{\n"
      "  return clamp(dot(n, l), 0., 1.);\n"
      "}\n"
      "\n"
      "float specular(const in vec3 n, const in vec3 l, const in vec3 e,\n"
      "               const in float s)\n"
      "{\n"
      "  float nrm = (s + 8.0) / (3.1415 * 8.0);\n"
      "  return pow(max(dot(reflect(e, n), l), 0.0), s) * nrm;\n"
      "}\n"
      "\n"
      "float fresnel(const in vec3 n, const in vec3 e, float s)\n"
      "{\n"
      "  return pow(clamp(1. - dot(n, e), 0., 1.), s);\n"
      "}\n"
      "\n"
      "//-----------------------------------------------------\n"
      "// Math functions\n"
      "//-----------------------------------------------------\n"
      "\n"
      "vec2 rotate(float angle, vec2 v)\n"
      "{\n"
      "  return vec2(cos(angle) * v.x + sin(angle) * v.y,\n"
      "              cos(angle) * v.y - sin(angle) * v.x);\n"
      "}\n"
      "\n"
      "float boolSub(float a, float b)\n"
      "{\n"
      "  return max(a, -b);\n"
      "}\n"
      "float sphere(vec3 p, float r)\n"
      "{\n"
      "  return length(p) - r;\n"
      "}\n"
      "\n"
      "//-----------------------------------------------------\n"
      "// Intersection functions (by iq)\n"
      "//-----------------------------------------------------\n"
      "\n"
      "vec3 nSphere(in vec3 pos, in vec4 sph)\n"
      "{\n"
      "  return (pos - sph.xyz) / sph.w;\n"
      "}\n"
      "\n"
      "float iSphere(in vec3 ro, in vec3 rd, in vec4 sph)\n"
      "{\n"
      "  vec3 oc = ro - sph.xyz;\n"
      "  float b = dot(oc, rd);\n"
      "  float c = dot(oc, oc) - sph.w * sph.w;\n"
      "  float h = b * b - c;\n"
      "  if (h < 0.0)\n"
      "    return -1.0;\n"
      "  return -b - sqrt(h);\n"
      "}\n"
      "\n"
      "float iCSphereF(vec3 p, vec3 dir, float r)\n"
      "{\n"
      "  float b = dot(p, dir);\n"
      "  float c = dot(p, p) - r * r;\n"
      "  float d = b * b - c;\n"
      "  if (d < 0.0)\n"
      "    return -MAX;\n"
      "  return -b + sqrt(d);\n"
      "}\n"
      "\n"
      "vec2 iCSphere2(vec3 p, vec3 dir, float r)\n"
      "{\n"
      "  float b = dot(p, dir);\n"
      "  float c = dot(p, p) - r * r;\n"
      "  float d = b * b - c;\n"
      "  if (d < 0.0)\n"
      "    return vec2(MAX, -MAX);\n"
      "  d = sqrt(d);\n"
      "  return vec2(-b - d, -b + d);\n"
      "}\n"
      "\n"
      "vec3 nPlane(in vec3 ro, in vec4 obj)\n"
      "{\n"
      "  return obj.xyz;\n"
      "}\n"
      "\n"
      "float iPlane(in vec3 ro, in vec3 rd, in vec4 pla)\n"
      "{\n"
      "  return (-pla.w - dot(pla.xyz, ro)) / dot(pla.xyz, rd);\n"
      "}\n"
      "\n"
      "//-----------------------------------------------------\n"
      "// Wet stone by TDM\n"
      "//\n"
      "// https://www.shadertoy.com/view/ldSSzV\n"
      "//-----------------------------------------------------\n"
      "\n"
      "const float ASTEROID_TRESHOLD     = 0.001;\n"
      "const float ASTEROID_EPSILON      = 1e-6;\n"
      "const float ASTEROID_DISPLACEMENT = 0.1;\n"
      "const float ASTEROID_RADIUS       = 0.13;\n"
      "\n"
      "const vec3 RING_COLOR_1 = vec3(0.42, 0.3, 0.2);\n"
      "const vec3 RING_COLOR_2 = vec3(0.51, 0.41, 0.32) * 0.2;\n"
      "\n"
      "float asteroidRock(const in vec3 p, const in vec3 id)\n"
      "{\n"
      "  float d = sphere(p, ASTEROID_RADIUS);\n"
      "  for (int i = 0; i < ASTEROID_NUM_BOOL_SUB; i++) {\n"
      "    float ii = float(i) + id.x;\n"
      "    float r  = (ASTEROID_RADIUS * 2.5) + ASTEROID_RADIUS * hash(ii);\n"
      "    vec3 v   = normalize(hash31(ii) * 2.0 - 1.0);\n"
      "    d        = boolSub(d, sphere(p + v * r, r * 0.8));\n"
      "  }\n"
      "  return d;\n"
      "}\n"
      "\n"
      "float asteroidMap(const in vec3 p, const in vec3 id)\n"
      "{\n"
      "  float d\n"
      "    = asteroidRock(p, id) + noise(p * 4.0) * ASTEROID_DISPLACEMENT;\n"
      "  return d;\n"
      "}\n"
      "\n"
      "float asteroidMapDetailed(const in vec3 p, const in vec3 id)\n"
      "{\n"
      "  float d = asteroidRock(p, id)\n"
      "            + fbm(p * 4.0, 0.4, 2.96) * ASTEROID_DISPLACEMENT;\n"
      "  return d;\n"
      "}\n"
      "\n"
      "void asteroidTransForm(inout vec3 ro, const in vec3 id)\n"
      "{\n"
      "  float xyangle = (id.x - .5) * time * 2.;\n"
      "  ro.xy         = rotate(xyangle, ro.xy);\n"
      "\n"
      "  float yzangle = (id.y - .5) * time * 2.;\n"
      "  ro.yz         = rotate(yzangle, ro.yz);\n"
      "}\n"
      "\n"
      "void asteroidUnTransForm(inout vec3 ro, const in vec3 id)\n"
      "{\n"
      "  float yzangle = (id.y - .5) * time * 2.;\n"
      "  ro.yz         = rotate(-yzangle, ro.yz);\n"
      "\n"
      "  float xyangle = (id.x - .5) * time * 2.;\n"
      "  ro.xy         = rotate(-xyangle, ro.xy);\n"
      "}\n"
      "\n"
      "vec3 asteroidGetNormal(vec3 p, vec3 id)\n"
      "{\n"
      "  asteroidTransForm(p, id);\n"
      "\n"
      "  vec3 n;\n"
      "  n.x = asteroidMapDetailed(vec3(p.x + ASTEROID_EPSILON, p.y, p.z), "
      "id);\n"
      "  n.y = asteroidMapDetailed(vec3(p.x, p.y + ASTEROID_EPSILON, p.z), "
      "id);\n"
      "  n.z = asteroidMapDetailed(vec3(p.x, p.y, p.z + ASTEROID_EPSILON), "
      "id);\n"
      "  n   = normalize(n - asteroidMapDetailed(p, id));\n"
      "\n"
      "  asteroidUnTransForm(n, id);\n"
      "  return n;\n"
      "}\n"
      "\n"
      "vec2 asteroidSpheretracing(vec3 ori, vec3 dir, vec3 id)\n"
      "{\n"
      "  asteroidTransForm(ori, id);\n"
      "  asteroidTransForm(dir, id);\n"
      "\n"
      "  vec2 td = vec2(0.0);\n"
      "  for (int i = 0; i < ASTEROID_NUM_STEPS; i++) {\n"
      "    vec3 p = ori + dir * td.x;\n"
      "    td.y   = asteroidMap(p, id);\n"
      "    if (td.y < ASTEROID_TRESHOLD)\n"
      "      break;\n"
      "    td.x += (td.y - ASTEROID_TRESHOLD) * 0.9;\n"
      "  }\n"
      "  return td;\n"
      "}\n"
      "\n"
      "vec3 asteroidGetStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e)\n"
      "{\n"
      "  return mix(diffuse(n, l) * RING_COLOR_1 * SUN_COLOR,\n"
      "             SUN_COLOR * specular(n, l, e, 3.0),\n"
      "             .5 * fresnel(n, e, 5.));\n"
      "}\n"
      "\n"
      "//-----------------------------------------------------\n"
      "// Ring (by me ;))\n"
      "//-----------------------------------------------------\n"
      "\n"
      "const float RING_DETAIL_DISTANCE = 40.;\n"
      "const float RING_VOXEL_STEP_SIZE = .03;\n"
      "\n"
      "vec3 ringShadowColor(const in vec3 ro)\n"
      "{\n"
      "  if (iSphere(ro, SUN_DIRECTION, vec4(0., 0., 0., EARTH_RADIUS)) > 0.) "
      "{\n"
      "    return vec3(0.);\n"
      "  }\n"
      "  return vec3(1.);\n"
      "}\n"
      "\n"
      "bool ringMap(const in vec3 ro)\n"
      "{\n"
      "  return ro.z < RING_HEIGHT / RING_VOXEL_STEP_SIZE && hash(ro) < .5;\n"
      "}\n"
      "\n"
      "vec4 renderRingNear(const in vec3 ro, const in vec3 rd)\n"
      "{\n"
      "  // find startpoint\n"
      "  float d1 = iPlane(ro, rd, vec4(0., 0., 1., RING_HEIGHT));\n"
      "  float d2 = iPlane(ro, rd, vec4(0., 0., 1., -RING_HEIGHT));\n"
      "\n"
      "  if (d1 < 0. && d2 < 0.)\n"
      "    return vec4(0.);\n"
      "\n"
      "  float d = min(max(d1, 0.), max(d2, 0.));\n"
      "\n"
      "  if (d > ASTEROID_MAX_DISTANCE)\n"
      "    return vec4(0.);\n"
      "\n"
      "  vec3 ros = ro + rd * d;\n"
      "\n"
      "  // avoid precision problems..\n"
      "  vec2 mroxy = mod(ros.xy, vec2(10.));\n"
      "  vec2 roxy  = ros.xy - mroxy;\n"
      "  ros.xy -= roxy;\n"
      "  ros /= RING_VOXEL_STEP_SIZE;\n"
      "  ros.xy -= vec2(.013, .112) * time * .5;\n"
      "\n"
      "  vec3 pos = floor(ros);\n"
      "  vec3 ri  = 1.0 / rd;\n"
      "  vec3 rs  = sign(rd);\n"
      "  vec3 dis = (pos - ros + 0.5 + rs * 0.5) * ri;\n"
      "\n"
      "  float alpha = 0., dint;\n"
      "  vec3 offset = vec3(0.), id, asteroidro;\n"
      "  vec2 asteroid;\n"
      "\n"
      "  for (int i = 0; i < RING_VOXEL_STEPS; i++) {\n"
      "    if (ringMap(pos)) {\n"
      "      id     = hash33(pos);\n"
      "      offset = id * (1. - 2. * ASTEROID_RADIUS) + ASTEROID_RADIUS;\n"
      "      dint   = iSphere(ros, rd, vec4(pos + offset, ASTEROID_RADIUS));\n"
      "\n"
      "      if (dint > 0.) {\n"
      "        asteroidro = ros + rd * dint - (pos + offset);\n"
      "        asteroid   = asteroidSpheretracing(asteroidro, rd, id);\n"
      "\n"
      "        if (asteroid.y < .1) {\n"
      "          alpha = 1.;\n"
      "          break;\n"
      "        }\n"
      "      }\n"
      "    }\n"
      "    vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n"
      "    dis += mm * rs * ri;\n"
      "    pos += mm * rs;\n"
      "  }\n"
      "\n"
      "  if (alpha > 0.) {\n"
      "    vec3 intersection = ros + rd * (asteroid.x + dint);\n"
      "    vec3 n = asteroidGetNormal(asteroidro + rd * asteroid.x, id);\n"
      "\n"
      "    vec3 col\n"
      "      = asteroidGetStoneColor(intersection, .1, SUN_DIRECTION, n, rd);\n"
      "\n"
      "    intersection *= RING_VOXEL_STEP_SIZE;\n"
      "    intersection.xy += roxy;\n"
      "    col *= ringShadowColor(intersection);\n"
      "\n"
      "    return vec4(col,\n"
      "                1. - smoothstep(0.4 * ASTEROID_MAX_DISTANCE,\n"
      "                                0.5 * ASTEROID_MAX_DISTANCE,\n"
      "                                distance(intersection, ro)));\n"
      "  }\n"
      "\n"
      "  return vec4(0.);\n"
      "}\n"
      "\n"
      "//-----------------------------------------------------\n"
      "// Ring (by me ;))\n"
      "//-----------------------------------------------------\n"
      "\n"
      "float renderRingFarShadow(const in vec3 ro, const in vec3 rd)\n"
      "{\n"
      "  // intersect plane\n"
      "  float d = iPlane(ro, rd, vec4(0., 0., 1., 0.));\n"
      "\n"
      "  if (d > 0.) {\n"
      "    vec3 intersection = ro + rd * d;\n"
      "    float l           = length(intersection.xy);\n"
      "\n"
      "    if (l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS) {\n"
      "      return .5\n"
      "             + .5 * (.2 + .8 * noise(l * .07))\n"
      "                 * (.5 + .5 * noise(intersection.xy));\n"
      "    }\n"
      "  }\n"
      "  return 0.;\n"
      "}\n"
      "\n"
      "vec4 renderRingFar(const in vec3 ro, const in vec3 rd, inout float "
      "maxd)\n"
      "{\n"
      "  // intersect plane\n"
      "  float d = iPlane(ro, rd, vec4(0., 0., 1., 0.));\n"
      "\n"
      "  if (d > 0. && d < maxd) {\n"
      "    maxd              = d;\n"
      "    vec3 intersection = ro + rd * d;\n"
      "    float l           = length(intersection.xy);\n"
      "\n"
      "    if (l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS) {\n"
      "      float dens = .5\n"
      "                   + .5 * (.2 + .8 * noise(l * .07))\n"
      "                       * (.5 + .5 * noise(intersection.xy));\n"
      "      vec3 col = mix(RING_COLOR_1, RING_COLOR_2, abs(noise(l * 0.2)))\n"
      "                 * abs(dens) * 1.5;\n"
      "\n"
      "      col *= ringShadowColor(intersection);\n"
      "      col *= .8 + .3 * diffuse(vec3(0, 0, 1), SUN_DIRECTION);\n"
      "      col *= SUN_COLOR;\n"
      "      return vec4(col, dens);\n"
      "    }\n"
      "    else {\n"
      "      return vec4(0.);\n"
      "    }\n"
      "  }\n"
      "  else {\n"
      "    return vec4(0.);\n"
      "  }\n"
      "}\n"
      "\n"
      "vec4 renderRing(const in vec3 ro, const in vec3 rd, inout float maxd)\n"
      "{\n"
      "  vec4 far = renderRingFar(ro, rd, maxd);\n"
      "  float l  = length(ro.xy);\n"
      "\n"
      "  if (abs(ro.z) < RING_HEIGHT + RING_DETAIL_DISTANCE\n"
      "      && l < RING_OUTER_RADIUS + RING_DETAIL_DISTANCE\n"
      "      && l > RING_INNER_RADIUS - RING_DETAIL_DISTANCE) {\n"
      "\n"
      "    float d = iPlane(ro, rd, vec4(0., 0., 1., 0.));\n"
      "    float detail\n"
      "      = mix(.5 * noise(fract(ro.xy + rd.xy * d) * 92.1) + .25, 1.,\n"
      "            smoothstep(0., RING_DETAIL_DISTANCE, d));\n"
      "    far.xyz *= detail;\n"
      "  }\n"
      "\n"
      "  // are asteroids neaded ?\n"
      "  if (abs(ro.z) < RING_HEIGHT + ASTEROID_MAX_DISTANCE\n"
      "      && l < RING_OUTER_RADIUS + ASTEROID_MAX_DISTANCE\n"
      "      && l > RING_INNER_RADIUS - ASTEROID_MAX_DISTANCE) {\n"
      "\n"
      "    vec4 near = renderRingNear(ro, rd);\n"
      "    far       = mix(far, near, near.w);\n"
      "    maxd      = 0.;\n"
      "  }\n"
      "\n"
      "  return far;\n"
      "}\n"
      "\n"
      "//-----------------------------------------------------\n"
      "// Stars (by me ;))\n"
      "//-----------------------------------------------------\n"
      "\n"
      "vec4 renderStars(const in vec3 rd)\n"
      "{\n"
      "  vec3 rds = rd;\n"
      "  vec3 col = vec3(0);\n"
      "  float v  = 1.0 / (2. * (1. + rds.z));\n"
      "\n"
      "  vec2 xy = vec2(rds.y * v, rds.x * v);\n"
      "  float s = noise(rds * 134.);\n"
      "\n"
      "  s += noise(rds * 470.);\n"
      "  s = pow(s, 19.0) * 0.00001;\n"
      "  if (s > 0.5) {\n"
      "    vec3 backStars = vec3(s) * .5 * vec3(0.95, 0.8, 0.9);\n"
      "    col += backStars;\n"
      "  }\n"
      "  return vec4(col, 1);\n"
      "}\n"
      "\n"
      "//-----------------------------------------------------\n"
      "// Atmospheric Scattering by GLtracy\n"
      "//\n"
      "// https://www.shadertoy.com/view/lslXDr\n"
      "//-----------------------------------------------------\n"
      "\n"
      "const float ATMOSPHERE_K_R = 0.166;\n"
      "const float ATMOSPHERE_K_M = 0.0025;\n"
      "const float ATMOSPHERE_E   = 12.3;\n"
      "const vec3 ATMOSPHERE_C_R  = vec3(0.3, 0.7, 1.0);\n"
      "const float ATMOSPHERE_G_M = -0.85;\n"
      "\n"
      "const float ATMOSPHERE_SCALE_H = 4.0 / (EARTH_ATMOSPHERE);\n"
      "const float ATMOSPHERE_SCALE_L = 1.0 / (EARTH_ATMOSPHERE);\n"
      "\n"
      "const float ATMOSPHERE_FNUM_OUT_SCATTER\n"
      "  = float(ATMOSPHERE_NUM_OUT_SCATTER);\n"
      "const float ATMOSPHERE_FNUM_IN_SCATTER\n"
      "  = float(ATMOSPHERE_NUM_IN_SCATTER);\n"
      "\n"
      "const int ATMOSPHERE_NUM_OUT_SCATTER_LOW = 2;\n"
      "const int ATMOSPHERE_NUM_IN_SCATTER_LOW  = 4;\n"
      "const float ATMOSPHERE_FNUM_OUT_SCATTER_LOW\n"
      "  = float(ATMOSPHERE_NUM_OUT_SCATTER_LOW);\n"
      "const float ATMOSPHERE_FNUM_IN_SCATTER_LOW\n"
      "  = float(ATMOSPHERE_NUM_IN_SCATTER_LOW);\n"
      "\n"
      "float atmosphericPhaseMie(float g, float c, float cc)\n"
      "{\n"
      "  float gg = g * g;\n"
      "  float a  = (1.0 - gg) * (1.0 + cc);\n"
      "  float b  = 1.0 + gg - 2.0 * g * c;\n"
      "\n"
      "  b *= sqrt(b);\n"
      "  b *= 2.0 + gg;\n"
      "\n"
      "  return 1.5 * a / b;\n"
      "}\n"
      "\n"
      "float atmosphericPhaseReyleigh(float cc)\n"
      "{\n"
      "  return 0.75 * (1.0 + cc);\n"
      "}\n"
      "\n"
      "float atmosphericDensity(vec3 p)\n"
      "{\n"
      "  return exp(-(length(p) - EARTH_RADIUS) * ATMOSPHERE_SCALE_H);\n"
      "}\n"
      "\n"
      "float atmosphericOptic(vec3 p, vec3 q)\n"
      "{\n"
      "  vec3 step = (q - p) / ATMOSPHERE_FNUM_OUT_SCATTER;\n"
      "  vec3 v    = p + step * 0.5;\n"
      "\n"
      "  float sum = 0.0;\n"
      "  for (int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER; i++) {\n"
      "    sum += atmosphericDensity(v);\n"
      "    v += step;\n"
      "  }\n"
      "  sum *= length(step) * ATMOSPHERE_SCALE_L;\n"
      "\n"
      "  return sum;\n"
      "}\n"
      "\n"
      "vec4 atmosphericInScatter(vec3 o, vec3 dir, vec2 e, vec3 l)\n"
      "{\n"
      "  float len = (e.y - e.x) / ATMOSPHERE_FNUM_IN_SCATTER;\n"
      "  vec3 step = dir * len;\n"
      "  vec3 p    = o + dir * e.x;\n"
      "  vec3 v    = p + dir * (len * 0.5);\n"
      "\n"
      "  float sumdensity = 0.;\n"
      "  vec3 sum         = vec3(0.0);\n"
      "\n"
      "  for (int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER; i++) {\n"
      "    vec3 u = v + l * iCSphereF(v, l, EARTH_RADIUS + EARTH_ATMOSPHERE);\n"
      "    float n\n"
      "      = (atmosphericOptic(p, v) + atmosphericOptic(v, u)) * (PI * "
      "4.0);\n"
      "    float dens = atmosphericDensity(v);\n"
      "\n"
      "    float m = MAX;\n"
      "    sum\n"
      "      += dens\n"
      "         * exp(-n * (ATMOSPHERE_K_R * ATMOSPHERE_C_R + "
      "ATMOSPHERE_K_M))\n"
      "         * (1. - renderRingFarShadow(u, SUN_DIRECTION));\n"
      "    sumdensity += dens;\n"
      "\n"
      "    v += step;\n"
      "  }\n"
      "  sum *= len * ATMOSPHERE_SCALE_L;\n"
      "\n"
      "  float c  = dot(dir, -l);\n"
      "  float cc = c * c;\n"
      "\n"
      "  return vec4(\n"
      "    sum\n"
      "      * (ATMOSPHERE_K_R * ATMOSPHERE_C_R * "
      "atmosphericPhaseReyleigh(cc)\n"
      "         + ATMOSPHERE_K_M * atmosphericPhaseMie(ATMOSPHERE_G_M, c, "
      "cc))\n"
      "      * ATMOSPHERE_E,\n"
      "    clamp(sumdensity * len * ATMOSPHERE_SCALE_L, 0., 1.));\n"
      "}\n"
      "\n"
      "float atmosphericOpticLow(vec3 p, vec3 q)\n"
      "{\n"
      "  vec3 step = (q - p) / ATMOSPHERE_FNUM_OUT_SCATTER_LOW;\n"
      "  vec3 v    = p + step * 0.5;\n"
      "\n"
      "  float sum = 0.0;\n"
      "  for (int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER_LOW; i++) {\n"
      "    sum += atmosphericDensity(v);\n"
      "    v += step;\n"
      "  }\n"
      "  sum *= length(step) * ATMOSPHERE_SCALE_L;\n"
      "\n"
      "  return sum;\n"
      "}\n"
      "\n"
      "vec3 atmosphericInScatterLow(vec3 o, vec3 dir, vec2 e, vec3 l)\n"
      "{\n"
      "  float len = (e.y - e.x) / ATMOSPHERE_FNUM_IN_SCATTER_LOW;\n"
      "  vec3 step = dir * len;\n"
      "  vec3 p    = o + dir * e.x;\n"
      "  vec3 v    = p + dir * (len * 0.5);\n"
      "\n"
      "  vec3 sum = vec3(0.0);\n"
      "\n"
      "  for (int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER_LOW; i++) {\n"
      "    vec3 u  = v + l * iCSphereF(v, l, EARTH_RADIUS + "
      "EARTH_ATMOSPHERE);\n"
      "    float n = (atmosphericOpticLow(p, v) + atmosphericOpticLow(v, u))\n"
      "              * (PI * 4.0);\n"
      "    float m = MAX;\n"
      "    sum\n"
      "      += atmosphericDensity(v)\n"
      "         * exp(-n * (ATMOSPHERE_K_R * ATMOSPHERE_C_R + "
      "ATMOSPHERE_K_M));\n"
      "    v += step;\n"
      "  }\n"
      "  sum *= len * ATMOSPHERE_SCALE_L;\n"
      "\n"
      "  float c  = dot(dir, -l);\n"
      "  float cc = c * c;\n"
      "\n"
      "  return sum * (ATMOSPHERE_K_R * ATMOSPHERE_C_R\n"
      "                  * atmosphericPhaseReyleigh(cc)\n"
      "                + ATMOSPHERE_K_M\n"
      "                    * atmosphericPhaseMie(ATMOSPHERE_G_M, c, cc))\n"
      "         * ATMOSPHERE_E;\n"
      "}\n"
      "\n"
      "vec4 renderAtmospheric(const in vec3 ro, const in vec3 rd,\n"
      "                       inout float d)\n"
      "{\n"
      "  // inside or outside atmosphere?\n"
      "  vec2 e = iCSphere2(ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE);\n"
      "  vec2 f = iCSphere2(ro, rd, EARTH_RADIUS);\n"
      "\n"
      "  if (length(ro) <= EARTH_RADIUS + EARTH_ATMOSPHERE) {\n"
      "    if (d < e.y) {\n"
      "      e.y = d;\n"
      "    }\n"
      "    d   = e.y;\n"
      "    e.x = 0.;\n"
      "\n"
      "    if (iSphere(ro, rd, vec4(0, 0, 0, EARTH_RADIUS)) > 0.) {\n"
      "      d = iSphere(ro, rd, vec4(0, 0, 0, EARTH_RADIUS));\n"
      "    }\n"
      "  }\n"
      "  else {\n"
      "    if (iSphere(ro, rd, vec4(0, 0, 0, EARTH_RADIUS + "
      "EARTH_ATMOSPHERE))\n"
      "        < 0.)\n"
      "      return vec4(0.);\n"
      "\n"
      "    if (e.x > e.y) {\n"
      "      d = MAX;\n"
      "      return vec4(0.);\n"
      "    }\n"
      "    d = e.y = min(e.y, f.x);\n"
      "  }\n"
      "  return atmosphericInScatter(ro, rd, e, SUN_DIRECTION);\n"
      "}\n"
      "\n"
      "vec3 renderAtmosphericLow(const in vec3 ro, const in vec3 rd)\n"
      "{\n"
      "  vec2 e = iCSphere2(ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE);\n"
      "  e.x    = 0.;\n"
      "  return atmosphericInScatterLow(ro, rd, e, SUN_DIRECTION);\n"
      "}\n"
      "\n"
      "//-----------------------------------------------------\n"
      "// Seascape by TDM\n"
      "//\n"
      "// https://www.shadertoy.com/view/Ms2SD1\n"
      "//-----------------------------------------------------\n"
      "\n"
      "const int SEA_ITER_GEOMETRY = 3;\n"
      "const int SEA_ITER_FRAGMENT = 5;\n"
      "\n"
      "const float SEA_EPSILON = 1e-3;\n"
      "#define SEA_EPSILON_NRM (0.1 / resolution.x)\n"
      "const float SEA_HEIGHT     = 0.6;\n"
      "const float SEA_CHOPPY     = 4.0;\n"
      "const float SEA_SPEED      = 0.8;\n"
      "const float SEA_FREQ       = 0.16;\n"
      "const vec3 SEA_BASE        = vec3(0.1, 0.19, 0.22);\n"
      "const vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\n"
      "float SEA_TIME;\n"
      "const mat2 sea_octave_m = mat2(1.6, 1.2, -1.2, 1.6);\n"
      "\n"
      "float seaOctave(in vec2 uv, const in float choppy)\n"
      "{\n"
      "  uv += noise(uv);\n"
      "  vec2 wv  = 1.0 - abs(sin(uv));\n"
      "  vec2 swv = abs(cos(uv));\n"
      "  wv       = mix(wv, swv, wv);\n"
      "  return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);\n"
      "}\n"
      "\n"
      "float seaMap(const in vec3 p)\n"
      "{\n"
      "  float freq   = SEA_FREQ;\n"
      "  float amp    = SEA_HEIGHT;\n"
      "  float choppy = SEA_CHOPPY;\n"
      "  vec2 uv      = p.xz;\n"
      "  uv.x *= 0.75;\n"
      "\n"
      "  float d, h = 0.0;\n"
      "  for (int i = 0; i < SEA_ITER_GEOMETRY; i++) {\n"
      "    d = seaOctave((uv + SEA_TIME) * freq, choppy);\n"
      "    d += seaOctave((uv - SEA_TIME) * freq, choppy);\n"
      "    h += d * amp;\n"
      "    uv *= sea_octave_m;\n"
      "    freq *= 1.9;\n"
      "    amp *= 0.22;\n"
      "    choppy = mix(choppy, 1.0, 0.2);\n"
      "  }\n"
      "  return p.y - h;\n"
      "}\n"
      "\n"
      "float seaMapHigh(const in vec3 p)\n"
      "{\n"
      "  float freq   = SEA_FREQ;\n"
      "  float amp    = SEA_HEIGHT;\n"
      "  float choppy = SEA_CHOPPY;\n"
      "  vec2 uv      = p.xz;\n"
      "  uv.x *= 0.75;\n"
      "\n"
      "  float d, h = 0.0;\n"
      "  for (int i = 0; i < SEA_ITER_FRAGMENT; i++) {\n"
      "    d = seaOctave((uv + SEA_TIME) * freq, choppy);\n"
      "    d += seaOctave((uv - SEA_TIME) * freq, choppy);\n"
      "    h += d * amp;\n"
      "    uv *= sea_octave_m;\n"
      "    freq *= 1.9;\n"
      "    amp *= 0.22;\n"
      "    choppy = mix(choppy, 1.0, 0.2);\n"
      "  }\n"
      "  return p.y - h;\n"
      "}\n"
      "\n"
      "vec3 seaGetColor(const in vec3 n, vec3 eye, const in vec3 l,\n"
      "                 const in float att, const in vec3 sunc,\n"
      "                 const in vec3 upc, const in vec3 reflected)\n"
      "{\n"
      "  vec3 refracted\n"
      "    = SEA_BASE * upc + diffuse(n, l) * SEA_WATER_COLOR * 0.12 * sunc;\n"
      "  vec3 color = mix(refracted, reflected, fresnel(n, -eye, 3.) * .65);\n"
      "\n"
      "  color += upc * SEA_WATER_COLOR * (att * 0.18);\n"
      "  color += sunc * vec3(specular(n, l, eye, 60.0));\n"
      "\n"
      "  return color;\n"
      "}\n"
      "\n"
      "vec3 seaGetNormal(const in vec3 p, const in float eps)\n"
      "{\n"
      "  vec3 n;\n"
      "  n.y = seaMapHigh(p);\n"
      "  n.x = seaMapHigh(vec3(p.x + eps, p.y, p.z)) - n.y;\n"
      "  n.z = seaMapHigh(vec3(p.x, p.y, p.z + eps)) - n.y;\n"
      "  n.y = eps;\n"
      "  return normalize(n);\n"
      "}\n"
      "\n"
      "float seaHeightMapTracing(const in vec3 ori, const in vec3 dir,\n"
      "                          out vec3 p)\n"
      "{\n"
      "  float tm = 0.0;\n"
      "  float tx = 1000.0;\n"
      "  float hx = seaMap(ori + dir * tx);\n"
      "  if (hx > 0.0)\n"
      "    return tx;\n"
      "  float hm   = seaMap(ori + dir * tm);\n"
      "  float tmid = 0.0;\n"
      "  for (int i = 0; i < SEA_NUM_STEPS; i++) {\n"
      "    tmid       = mix(tm, tx, hm / (hm - hx));\n"
      "    p          = ori + dir * tmid;\n"
      "    float hmid = seaMap(p);\n"
      "    if (hmid < 0.0) {\n"
      "      tx = tmid;\n"
      "      hx = hmid;\n"
      "    }\n"
      "    else {\n"
      "      tm = tmid;\n"
      "      hm = hmid;\n"
      "    }\n"
      "  }\n"
      "  return tmid;\n"
      "}\n"
      "\n"
      "vec3 seaTransform(in vec3 x)\n"
      "{\n"
      "  x.yz = rotate(0.8, x.yz);\n"
      "  return x;\n"
      "}\n"
      "\n"
      "vec3 seaUntransform(in vec3 x)\n"
      "{\n"
      "  x.yz = rotate(-0.8, x.yz);\n"
      "  return x;\n"
      "}\n"
      "\n"
      "void renderSea(const in vec3 ro, const in vec3 rd, inout vec3 n,\n"
      "               inout float att)\n"
      "{\n"
      "  vec3 p, rom = seaTransform(ro), rdm = seaTransform(rd);\n"
      "\n"
      "  rom.y -= EARTH_RADIUS;\n"
      "  rom *= 1000.;\n"
      "  rom.xz += vec2(3.1, .2) * time;\n"
      "\n"
      "  SEA_TIME = time * SEA_SPEED;\n"
      "\n"
      "  seaHeightMapTracing(rom, rdm, p);\n"
      "  float squareddist = dot(p - rom, p - rom);\n"
      "  n                 = seaGetNormal(p, squareddist * SEA_EPSILON_NRM);\n"
      "\n"
      "  n = seaUntransform(n);\n"
      "\n"
      "  att = clamp(SEA_HEIGHT + p.y, 0., 1.);\n"
      "}\n"
      "\n"
      "//-----------------------------------------------------\n"
      "// Terrain based on Elevated and Terrain Tubes by IQ\n"
      "//\n"
      "// https://www.shadertoy.com/view/MdX3Rr\n"
      "// https://www.shadertoy.com/view/4sjXzG\n"
      "//-----------------------------------------------------\n"
      "\n"
      "#ifndef HIDE_TERRAIN\n"
      "\n"
      "const mat2 terrainM2 = mat2(1.6, -1.2, 1.2, 1.6);\n"
      "\n"
      "float terrainLow(vec2 p)\n"
      "{\n"
      "  p *= 0.0013;\n"
      "\n"
      "  float s = 1.0;\n"
      "  float t = 0.0;\n"
      "  for (int i = 0; i < 2; i++) {\n"
      "    t += s * tri(p);\n"
      "    s *= 0.5 + 0.1 * t;\n"
      "    p = 0.97 * terrainM2 * p + (t - 0.5) * 0.12;\n"
      "  }\n"
      "  return t * 33.0;\n"
      "}\n"
      "\n"
      "float terrainMed(vec2 p)\n"
      "{\n"
      "  p *= 0.0013;\n"
      "\n"
      "  float s = 1.0;\n"
      "  float t = 0.0;\n"
      "  for (int i = 0; i < 6; i++) {\n"
      "    t += s * tri(p);\n"
      "    s *= 0.5 + 0.1 * t;\n"
      "    p = 0.97 * terrainM2 * p + (t - 0.5) * 0.12;\n"
      "  }\n"
      "\n"
      "  return t * 33.0;\n"
      "}\n"
      "\n"
      "float terrainHigh(vec2 p)\n"
      "{\n"
      "  vec2 q = p;\n"
      "  p *= 0.0013;\n"
      "\n"
      "  float s = 1.0;\n"
      "  float t = 0.0;\n"
      "  for (int i = 0; i < 7; i++) {\n"
      "    t += s * tri(p);\n"
      "    s *= 0.5 + 0.1 * t;\n"
      "    p = 0.97 * terrainM2 * p + (t - 0.5) * 0.12;\n"
      "  }\n"
      "\n"
      "  t += t * 0.015 * fbm(q);\n"
      "  return t * 33.0;\n"
      "}\n"
      "\n"
      "float terrainMap(const in vec3 pos)\n"
      "{\n"
      "  return pos.y - terrainMed(pos.xz);\n"
      "}\n"
      "\n"
      "float terrainMapH(const in vec3 pos)\n"
      "{\n"
      "  float y = terrainHigh(pos.xz);\n"
      "  float h = pos.y - y;\n"
      "  return h;\n"
      "}\n"
      "\n"
      "float terrainIntersect(in vec3 ro, in vec3 rd, in float tmin,\n"
      "                       in float tmax)\n"
      "{\n"
      "  float t = tmin;\n"
      "  for (int i = 0; i < TERRAIN_NUM_STEPS; i++) {\n"
      "    vec3 pos  = ro + t * rd;\n"
      "    float res = terrainMap(pos);\n"
      "    if (res < (0.001 * t) || t > tmax)\n"
      "      break;\n"
      "    t += res * .9;\n"
      "  }\n"
      "\n"
      "  return t;\n"
      "}\n"
      "\n"
      "float terrainCalcShadow(in vec3 ro, in vec3 rd)\n"
      "{\n"
      "  vec2 eps = vec2(150.0, 0.0);\n"
      "  float h1 = terrainMed(ro.xz);\n"
      "  float h2 = terrainLow(ro.xz);\n"
      "\n"
      "  float d1 = 10.0;\n"
      "  float d2 = 80.0;\n"
      "  float d3 = 200.0;\n"
      "  float s1 = clamp(\n"
      "    1.0 * (h1 + rd.y * d1 - terrainMed(ro.xz + d1 * rd.xz)), 0.0, "
      "1.0);\n"
      "  float s2 = clamp(\n"
      "    0.5 * (h1 + rd.y * d2 - terrainMed(ro.xz + d2 * rd.xz)), 0.0, "
      "1.0);\n"
      "  float s3 = clamp(\n"
      "    0.2 * (h2 + rd.y * d3 - terrainLow(ro.xz + d3 * rd.xz)), 0.0, "
      "1.0);\n"
      "\n"
      "  return min(min(s1, s2), s3);\n"
      "}\n"
      "vec3 terrainCalcNormalHigh(in vec3 pos, float t)\n"
      "{\n"
      "  vec2 e = vec2(1.0, -1.0) * 0.001 * t;\n"
      "\n"
      "  return normalize(e.xyy * terrainMapH(pos + e.xyy)\n"
      "                   + e.yyx * terrainMapH(pos + e.yyx)\n"
      "                   + e.yxy * terrainMapH(pos + e.yxy)\n"
      "                   + e.xxx * terrainMapH(pos + e.xxx));\n"
      "}\n"
      "\n"
      "vec3 terrainCalcNormalMed(in vec3 pos, float t)\n"
      "{\n"
      "  float e  = 0.005 * t;\n"
      "  vec2 eps = vec2(e, 0.0);\n"
      "  float h  = terrainMed(pos.xz);\n"
      "  return normalize(vec3(terrainMed(pos.xz - eps.xy) - h, e,\n"
      "                        terrainMed(pos.xz - eps.yx) - h));\n"
      "}\n"
      "\n"
      "vec3 terrainTransform(in vec3 x)\n"
      "{\n"
      "  x.zy = rotate(-.83, x.zy);\n"
      "  return x;\n"
      "}\n"
      "\n"
      "vec3 terrainUntransform(in vec3 x)\n"
      "{\n"
      "  x.zy = rotate(.83, x.zy);\n"
      "  return x;\n"
      "}\n"
      "\n"
      "float llamelTime;\n"
      "const float llamelScale = 5.;\n"
      "\n"
      "vec3 llamelPosition()\n"
      "{\n"
      "  llamelTime = time * 2.5;\n"
      "  vec2 pos   = vec2(-400., 135. - llamelTime * 0.075 * llamelScale);\n"
      "  return vec3(pos.x, terrainMed(pos), pos.y);\n"
      "}\n"
      "\n"
      "vec3 terrainShade(const in vec3 col, const in vec3 pos,\n"
      "                  const in vec3 rd, const in vec3 n,\n"
      "                  const in float spec, const in vec3 sunc,\n"
      "                  const in vec3 upc, const in vec3 reflc)\n"
      "{\n"
      "  vec3 sunDirection = terrainTransform(SUN_DIRECTION);\n"
      "  float dif         = diffuse(n, sunDirection);\n"
      "  float bac         = diffuse(\n"
      "    n, vec3(-sunDirection.x, sunDirection.y, -sunDirection.z));\n"
      "  float sha = terrainCalcShadow(pos, sunDirection);\n"
      "  float amb = clamp(n.y, 0.0, 1.0);\n"
      "\n"
      "  vec3 lin = vec3(0.0);\n"
      "  lin += 2. * dif * sunc * vec3(sha, sha * sha * 0.1 + 0.9 * sha,\n"
      "                                sha * sha * 0.2 + 0.8 * sha);\n"
      "  lin += 0.2 * amb * upc;\n"
      "  lin += 0.08 * bac * clamp(vec3(1.) - sunc, vec3(0.), vec3(1.));\n"
      "  return mix(col * lin * 3., reflc,\n"
      "             spec * fresnel(n, -terrainTransform(rd), 5.0));\n"
      "}\n"
      "\n"
      "vec3 terrainGetColor(const in vec3 pos, const in vec3 rd,\n"
      "                     const in float t, const in vec3 sunc,\n"
      "                     const in vec3 upc, const in vec3 reflc)\n"
      "{\n"
      "  vec3 nor = terrainCalcNormalHigh(pos, t);\n"
      "  vec3 sor = terrainCalcNormalMed(pos, t);\n"
      "\n"
      "  float spec = 0.005;\n"
      "\n"
      "#ifdef DISPLAY_TERRAIN_DETAIL\n"
      "  float no = noise(5. * fbm(1.11 * pos.xz));\n"
      "#else\n"
      "  const float no = 0.;\n"
      "#endif\n"
      "  float r = .5 + .5 * fbm(.95 * pos.xz);\n"
      "  vec3 col\n"
      "    = (r * 0.25 + 0.75) * 0.9\n"
      "      * mix(vec3(0.08, 0.07, 0.07), vec3(0.10, 0.09, 0.08),\n"
      "            noise(0.4267 * vec2(pos.x * 2., pos.y * 9.8)) + .01 * no);\n"
      "  col = mix(col, 0.20 * vec3(0.45, .30, 0.15) * (0.50 + 0.50 * r),\n"
      "            smoothstep(0.825, 0.925, nor.y + .025 * no));\n"
      "  col = mix(col, 0.15 * vec3(0.30, .30, 0.10) * (0.25 + 0.75 * r),\n"
      "            smoothstep(0.95, 1.0, nor.y + .025 * no));\n"
      "  col *= .88 + .12 * no;\n"
      "\n"
      "  float s  = nor.y + 0.03 * pos.y + 0.35 * fbm(0.05 * pos.xz) - .35;\n"
      "  float sf = fwidth(s) * 1.5;\n"
      "  s        = smoothstep(0.84 - sf, 0.84 + sf, s);\n"
      "  col      = mix(col, 0.29 * vec3(0.62, 0.65, 0.7), s);\n"
      "  nor      = mix(nor, sor, 0.7 * smoothstep(0.9, 0.95, s));\n"
      "  spec     = mix(spec, 0.45, smoothstep(0.9, 0.95, s));\n"
      "\n"
      "  col = terrainShade(col, pos, rd, nor, spec, sunc, upc, reflc);\n"
      "\n"
      "#ifdef DISPLAY_LLAMEL\n"
      "  col *= clamp(distance(pos.xz, llamelPosition().xz) * 0.4, 0.4, 1.);\n"
      "#endif\n"
      "\n"
      "  return col;\n"
      "}\n"
      "\n"
      "vec3 terrainTransformRo(const in vec3 ro)\n"
      "{\n"
      "  vec3 rom = terrainTransform(ro);\n"
      "  rom.y -= EARTH_RADIUS - 100.;\n"
      "  rom.xz *= 5.;\n"
      "  rom.xz += vec2(-170., 50.) + vec2(-4., .4) * time;\n"
      "  rom.y += (terrainLow(rom.xz) - 86.)\n"
      "           * clamp(1. - 1. * (length(ro) - EARTH_RADIUS), 0., 1.);\n"
      "  return rom;\n"
      "}\n"
      "\n"
      "vec4 renderTerrain(const in vec3 ro, const in vec3 rd,\n"
      "                   inout vec3 intersection, inout vec3 n)\n"
      "{\n"
      "  vec3 p, rom = terrainTransformRo(ro), rdm = terrainTransform(rd);\n"
      "\n"
      "  float tmin = 10.0;\n"
      "  float tmax = 3200.0;\n"
      "\n"
      "  float res = terrainIntersect(rom, rdm, tmin, tmax);\n"
      "\n"
      "  if (res > tmax) {\n"
      "    res = -1.;\n"
      "  }\n"
      "  else {\n"
      "    vec3 pos = rom + rdm * res;\n"
      "    n        = terrainCalcNormalMed(pos, res);\n"
      "    n        = terrainUntransform(n);\n"
      "\n"
      "    intersection = ro + rd * res / 100.;\n"
      "  }\n"
      "  return vec4(res, rom + rdm * res);\n"
      "}\n"
      "\n"
      "#endif\n"
      "\n"
      "//-----------------------------------------------------\n"
      "// LLamels by Eiffie\n"
      "//\n"
      "// https://www.shadertoy.com/view/ltsGz4\n"
      "//-----------------------------------------------------\n"
      "#ifdef DISPLAY_LLAMEL\n"
      "float llamelMapSMin(const in float a, const in float b,\n"
      "                    const in float k)\n"
      "{\n"
      "  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n"
      "  return b + h * (a - b - k + k * h);\n"
      "}\n"
      "\n"
      "float llamelMapLeg(vec3 p, vec3 j0, vec3 j3, vec3 l, vec4 r, vec3 rt)\n"
      "{ // z joint with tapered legs\n"
      "  float lx2z = l.x / (l.x + l.z), h = l.y * lx2z;\n"
      "  vec3 u = (j3 - j0) * lx2z,\n"
      "       q = u * (0.5 + 0.5 * (l.x * l.x - h * h) / dot(u, u));\n"
      "  q += sqrt(max(0.0, l.x * l.x - dot(q, q))) * normalize(cross(u, "
      "rt));\n"
      "  vec3 j1 = j0 + q, j2 = j3 - q * (1.0 - lx2z) / lx2z;\n"
      "  u       = p - j0;\n"
      "  q       = j1 - j0;\n"
      "  h       = clamp(dot(u, q) / dot(q, q), 0.0, 1.0);\n"
      "  float d = length(u - q * h) - r.x - (r.y - r.x) * h;\n"
      "  u       = p - j1;\n"
      "  q       = j2 - j1;\n"
      "  h       = clamp(dot(u, q) / dot(q, q), 0.0, 1.0);\n"
      "  d       = min(d, length(u - q * h) - r.y - (r.z - r.y) * h);\n"
      "  u       = p - j2;\n"
      "  q       = j3 - j2;\n"
      "  h       = clamp(dot(u, q) / dot(q, q), 0.0, 1.0);\n"
      "  return min(d, length(u - q * h) - r.z - (r.w - r.z) * h);\n"
      "}\n"
      "\n"
      "float llamelMap(in vec3 p)\n"
      "{\n"
      "  const vec3 rt = vec3(0.0, 0.0, 1.0);\n"
      "  p.y += 0.25 * llamelScale;\n"
      "  p.xz -= 0.5 * llamelScale;\n"
      "  p.xz      = vec2(-p.z, p.x);\n"
      "  vec3 pori = p;\n"
      "\n"
      "  p /= llamelScale;\n"
      "\n"
      "  vec2 c = floor(p.xz);\n"
      "  p.xz   = fract(p.xz) - vec2(0.5);\n"
      "  p.y -= p.x * .04 * llamelScale;\n"
      "  float sa = sin(c.x * 2.0 + c.y * 4.5 + llamelTime * 0.05) * 0.15;\n"
      "\n"
      "  float b = 0.83 - abs(p.z);\n"
      "  float a = c.x + 117.0 * c.y + sign(p.x) * 1.57 + sign(p.z) * 1.57\n"
      "            + llamelTime,\n"
      "        ca = cos(a);\n"
      "  vec3 j0  = vec3(sign(p.x) * 0.125, ca * 0.01, sign(p.z) * 0.05),\n"
      "       j3\n"
      "       = vec3(j0.x + sin(a) * 0.1, max(-0.25 + ca * 0.1, -0.25), "
      "j0.z);\n"
      "  float dL\n"
      "    = llamelMapLeg(p, j0, j3, vec3(0.08, 0.075, 0.12),\n"
      "                   vec4(0.03, 0.02, 0.015, 0.01), rt * sign(p.x));\n"
      "  p.y -= 0.03;\n"
      "  float dB = (length(p.xyz * vec3(1.0, 1.75, 1.75)) - 0.14) * 0.75;\n"
      "  a        = c.x + 117.0 * c.y + llamelTime;\n"
      "  ca       = cos(a);\n"
      "  sa *= 0.4;\n"
      "  j0       = vec3(0.125, 0.03 + abs(ca) * 0.03, ca * 0.01),\n"
      "  j3       = vec3(0.3, 0.07 + ca * sa, sa);\n"
      "  float dH = llamelMapLeg(p, j0, j3, vec3(0.075, 0.075, 0.06),\n"
      "                          vec4(0.03, 0.035, 0.03, 0.01), rt);\n"
      "  dB = llamelMapSMin(min(dL, dH), dB, clamp(0.04 + p.y, 0.0, 1.0));\n"
      "  a  = max(abs(p.z), p.y) + 0.05;\n"
      "  return max(min(dB, min(a, b)),\n"
      "             length(pori.xz - vec2(0.5) * llamelScale)\n"
      "               - .5 * llamelScale);\n"
      "}\n"
      "\n"
      "vec3 llamelGetNormal(in vec3 ro)\n"
      "{\n"
      "  vec2 e = vec2(1.0, -1.0) * 0.001;\n"
      "\n"
      "  return normalize(\n"
      "    e.xyy * llamelMap(ro + e.xyy) + e.yyx * llamelMap(ro + e.yyx)\n"
      "    + e.yxy * llamelMap(ro + e.yxy) + e.xxx * llamelMap(ro + e.xxx));\n"
      "}\n"
      "\n"
      "vec4 renderLlamel(in vec3 ro, const in vec3 rd, const in vec3 sunc,\n"
      "                  const in vec3 upc, const in vec3 reflc)\n"
      "{\n"
      "  ro -= llamelPosition();\n"
      "  float t = .1 * hash(rd.xy), d, dm = 10.0, tm;\n"
      "  for (int i = 0; i < 36; i++) {\n"
      "    t += d = llamelMap(ro + rd * t);\n"
      "    if (d < dm) {\n"
      "      dm = d;\n"
      "      tm = t;\n"
      "    }\n"
      "    if (t > 1000.0 || d < 0.00001)\n"
      "      break;\n"
      "  }\n"
      "  dm = max(0.0, dm);\n"
      "  if (dm < .02) {\n"
      "    vec3 col = vec3(0.45, .30, 0.15) * .2;\n"
      "    vec3 pos = ro + rd * tm;\n"
      "    vec3 nor = llamelGetNormal(pos);\n"
      "    col      = terrainShade(col, pos, rd, nor, .01, sunc, upc, reflc);\n"
      "    return vec4(col, clamp(1. - (dm - 0.01) / 0.01, 0., 1.));\n"
      "  }\n"
      "\n"
      "  return vec4(0.);\n"
      "}\n"
      "#endif\n"
      "\n"
      "//-----------------------------------------------------\n"
      "// Clouds (by me ;))\n"
      "//-----------------------------------------------------\n"
      "\n"
      "vec4 renderClouds(const in vec3 ro, const in vec3 rd, const in float "
      "d,\n"
      "                  const in vec3 n, const in float land,\n"
      "                  const in vec3 sunColor, const in vec3 upColor,\n"
      "                  inout float shadow)\n"
      "{\n"
      "  vec3 intersection = ro + rd * d;\n"
      "  vec3 cint         = intersection * 0.009;\n"
      "  float rot = -.2 * length(cint.xy) + .6 * fbm(cint * .4, 0.5, 2.96)\n"
      "              + .05 * land;\n"
      "\n"
      "  cint.xy = rotate(rot, cint.xy);\n"
      "\n"
      "  vec3 cdetail = mod(intersection * 3.23, vec3(50.));\n"
      "  cdetail.xy   = rotate(.25 * rot, cdetail.xy);\n"
      "\n"
      "  float clouds\n"
      "    = 1.3 * (fbm(cint * (1. + .02 * noise(intersection)), 0.5, 2.96)\n"
      "             + .4 * land - .3);\n"
      "\n"
      "#ifdef DISPLAY_CLOUDS_DETAIL\n"
      "  if (d < 200.) {\n"
      "    clouds += .3 * (fbm(cdetail, 0.5, 2.96) - .5)\n"
      "              * (1. - smoothstep(0., 200., d));\n"
      "  }\n"
      "#endif\n"
      "\n"
      "  shadow = clamp(1. - clouds, 0., 1.);\n"
      "\n"
      "  clouds = clamp(clouds, 0., 1.);\n"
      "  clouds *= clouds;\n"
      "  clouds *= smoothstep(0., 0.4, d);\n"
      "\n"
      "  vec3 clbasecolor = vec3(1.);\n"
      "  vec3 clcol       = .1 * clbasecolor * sunColor\n"
      "               * vec3(specular(n, SUN_DIRECTION, rd, 36.0));\n"
      "  clcol += .3 * clbasecolor * sunColor;\n"
      "  clcol\n"
      "    += clbasecolor * (diffuse(n, SUN_DIRECTION) * sunColor + upColor);\n"
      "\n"
      "  return vec4(clcol, clouds);\n"
      "}\n"
      "\n"
      "//-----------------------------------------------------\n"
      "// Planet (by me ;))\n"
      "//-----------------------------------------------------\n"
      "\n"
      "vec4 renderPlanet(const in vec3 ro, const in vec3 rd, const in vec3 "
      "up,\n"
      "                  inout float maxd)\n"
      "{\n"
      "  float d = iSphere(ro, rd, vec4(0., 0., 0., EARTH_RADIUS));\n"
      "\n"
      "  vec3 intersection = ro + rd * d;\n"
      "  vec3 n = nSphere(intersection, vec4(0., 0., 0., EARTH_RADIUS));\n"
      "  vec4 res;\n"
      "\n"
      "#ifndef HIDE_TERRAIN\n"
      "  bool renderTerrainDetail\n"
      "    = length(ro) < EARTH_RADIUS + EARTH_ATMOSPHERE\n"
      "      && dot(terrainUntransform(vec3(0., 1., 0.)), normalize(ro))\n"
      "           > .9996;\n"
      "#endif\n"
      "  bool renderSeaDetail\n"
      "    = d < 1.\n"
      "      && dot(seaUntransform(vec3(0., 1., 0.)), normalize(ro)) > .9999;\n"
      "  float mixDetailColor = 0.;\n"
      "\n"
      "  if (d < 0. || d > maxd) {\n"
      "#ifndef HIDE_TERRAIN\n"
      "    if (renderTerrainDetail) {\n"
      "      intersection = ro;\n"
      "      n            = normalize(ro);\n"
      "    }\n"
      "    else {\n"
      "      return vec4(0);\n"
      "    }\n"
      "#else\n"
      "    return vec4(0.);\n"
      "#endif\n"
      "  }\n"
      "  if (d > 0.) {\n"
      "    maxd = d;\n"
      "  }\n"
      "  float att = 0.;\n"
      "\n"
      "  if (dot(n, SUN_DIRECTION) < -0.1)\n"
      "    return vec4(0., 0., 0., 1.);\n"
      "\n"
      "  float dm = MAX, e = 0.;\n"
      "  vec3 col, detailCol, nDetail;\n"
      "\n"
      "// normal and intersection\n"
      "#ifndef HIDE_TERRAIN\n"
      "  if (renderTerrainDetail) {\n"
      "    res = renderTerrain(ro, rd, intersection, nDetail);\n"
      "    if (res.x < 0. && d < 0.) {\n"
      "      return vec4(0);\n"
      "    }\n"
      "    if (res.x >= 0.) {\n"
      "      maxd = pow(res.x / 4000., 4.) * 50.;\n"
      "      e    = -10.;\n"
      "    }\n"
      "    mixDetailColor\n"
      "      = 1. - smoothstep(.75, 1.,\n"
      "                        (length(ro) - EARTH_RADIUS) / "
      "EARTH_ATMOSPHERE);\n"
      "    n = normalize(mix(n, nDetail, mixDetailColor));\n"
      "  }\n"
      "  else\n"
      "#endif\n"
      "    if (renderSeaDetail) {\n"
      "    float attsea, mf = smoothstep(.5, 1., d);\n"
      "\n"
      "    renderSea(ro, rd, nDetail, attsea);\n"
      "\n"
      "    n   = normalize(mix(nDetail, n, mf));\n"
      "    att = mix(attsea, att, mf);\n"
      "  }\n"
      "  else {\n"
      "    e = fbm(.003 * intersection + vec3(1.), 0.4, 2.96)\n"
      "        + smoothstep(.85, .95, abs(intersection.z / EARTH_RADIUS));\n"
      "#ifndef HIDE_TERRAIN\n"
      "    if (d < 1500.) {\n"
      "      e += (-.03 + .06 * fbm(intersection * 0.1, 0.4, 2.96))\n"
      "           * (1. - d / 1500.);\n"
      "    }\n"
      "#endif\n"
      "  }\n"
      "\n"
      "  vec3 sunColor\n"
      "    = .25 * renderAtmosphericLow(intersection, SUN_DIRECTION).xyz;\n"
      "  vec3 upColor = 2. * renderAtmosphericLow(intersection, n).xyz;\n"
      "  vec3 reflColor\n"
      "    = renderAtmosphericLow(intersection, reflect(rd, n)).xyz;\n"
      "\n"
      "// color\n"
      "#ifndef HIDE_TERRAIN\n"
      "  if (renderTerrainDetail) {\n"
      "    detailCol = col = terrainGetColor(res.yzw, rd, res.x, sunColor,\n"
      "                                      upColor, reflColor);\n"
      "    d = 0.;\n"
      "  }\n"
      "#endif\n"
      "\n"
      "  if (mixDetailColor < 1.) {\n"
      "    if (e < .45) {\n"
      "      // sea\n"
      "      col = seaGetColor(n, rd, SUN_DIRECTION, att, sunColor, upColor,\n"
      "                        reflColor);\n"
      "    }\n"
      "    else {\n"
      "      // planet (land) far\n"
      "      float land1 = max(0.1, fbm(intersection * 0.0013, 0.4, 2.96));\n"
      "      float land2 = max(0.1, fbm(intersection * 0.0063, 0.4, 2.96));\n"
      "      float iceFactor\n"
      "        = abs(pow(intersection.z / EARTH_RADIUS, 13.0)) * e;\n"
      "\n"
      "      vec3 landColor1 = vec3(0.43, 0.65, 0.1) * land1;\n"
      "      vec3 landColor2 = RING_COLOR_1 * land2;\n"
      "      vec3 mixedLand  = (landColor1 + landColor2) * 0.5;\n"
      "      vec3 finalLand = mix(mixedLand, vec3(7.0, 7.0, 7.0) * land1 * "
      "1.5,\n"
      "                           max(iceFactor + .02 * land2 - .02, 0.));\n"
      "\n"
      "      col = (diffuse(n, SUN_DIRECTION) * sunColor + upColor) * "
      "finalLand\n"
      "            * .75;\n"
      "#ifdef HIGH_QUALITY\n"
      "      col *= (.5 + .5 * fbm(intersection * 0.23, 0.4, 2.96));\n"
      "#endif\n"
      "    }\n"
      "  }\n"
      "\n"
      "  if (mixDetailColor > 0.) {\n"
      "    col = mix(col, detailCol, mixDetailColor);\n"
      "  }\n"
      "\n"
      "#ifdef DISPLAY_LLAMEL\n"
      "  if (renderTerrainDetail) {\n"
      "    vec3 rom = terrainTransformRo(ro), rdm = terrainTransform(rd);\n"
      "    d = iSphere(rom, rdm, vec4(llamelPosition(), llamelScale * 3.));\n"
      "    if (d > 0.) {\n"
      "      vec4 llamel = renderLlamel(rom + rdm * d, rdm, sunColor, "
      "upColor,\n"
      "                                 reflColor);\n"
      "      col = mix(col, llamel.rgb, llamel.a);\n"
      "    }\n"
      "  }\n"
      "#endif\n"
      "\n"
      "  d = iSphere(ro, rd, vec4(0., 0., 0., EARTH_RADIUS + EARTH_CLOUDS));\n"
      "  if (d > 0.) {\n"
      "    float shadow;\n"
      "    vec4 clouds\n"
      "      = renderClouds(ro, rd, d, n, e, sunColor, upColor, shadow);\n"
      "    col *= shadow;\n"
      "    col = mix(col, clouds.rgb, clouds.w);\n"
      "  }\n"
      "\n"
      "  float m = MAX;\n"
      "  col *= (1. - renderRingFarShadow(ro + rd * d, SUN_DIRECTION));\n"
      "\n"
      "  return vec4(col, 1.);\n"
      "}\n"
      "\n"
      "//-----------------------------------------------------\n"
      "// Lens flare by musk\n"
      "//\n"
      "// https://www.shadertoy.com/view/4sX3Rs\n"
      "//-----------------------------------------------------\n"
      "\n"
      "vec3 lensFlare(const in vec2 uv, const in vec2 pos)\n"
      "{\n"
      "  vec2 main = uv - pos;\n"
      "  vec2 uvd  = uv * (length(uv));\n"
      "\n"
      "  float f0 = 1.5 / (length(uv - pos) * 16.0 + 1.0);\n"
      "\n"
      "  float f1 = max(0.01 - pow(length(uv + 1.2 * pos), 1.9), .0) * 7.0;\n"
      "\n"
      "  float f2\n"
      "    = max(1.0 / (1.0 + 32.0 * pow(length(uvd + 0.8 * pos), 2.0)), .0)\n"
      "      * 00.25;\n"
      "  float f22\n"
      "    = max(1.0 / (1.0 + 32.0 * pow(length(uvd + 0.85 * pos), 2.0)), .0)\n"
      "      * 00.23;\n"
      "  float f23\n"
      "    = max(1.0 / (1.0 + 32.0 * pow(length(uvd + 0.9 * pos), 2.0)), .0)\n"
      "      * 00.21;\n"
      "\n"
      "  vec2 uvx = mix(uv, uvd, -0.5);\n"
      "\n"
      "  float f4  = max(0.01 - pow(length(uvx + 0.4 * pos), 2.4), .0) * 6.0;\n"
      "  float f42 = max(0.01 - pow(length(uvx + 0.45 * pos), 2.4), .0) * "
      "5.0;\n"
      "  float f43 = max(0.01 - pow(length(uvx + 0.5 * pos), 2.4), .0) * 3.0;\n"
      "\n"
      "  vec3 c = vec3(.0);\n"
      "\n"
      "  c.r += f2 + f4;\n"
      "  c.g += f22 + f42;\n"
      "  c.b += f23 + f43;\n"
      "  c = c * .5 - vec3(length(uvd) * .05);\n"
      "  c += vec3(f0);\n"
      "\n"
      "  return c;\n"
      "}\n"
      "\n"
      "//-----------------------------------------------------\n"
      "// cameraPath\n"
      "//-----------------------------------------------------\n"
      "\n"
      "vec3 pro, pta, pup;\n"
      "float dro, dta, dup;\n"
      "\n"
      "void camint(inout vec3 ret, const in float t, const in float duration,\n"
      "            const in vec3 dest, inout vec3 prev, inout float prevt)\n"
      "{\n"
      "  if (t >= prevt && t <= prevt + duration) {\n"
      "    ret = mix(prev, dest, smoothstep(prevt, prevt + duration, t));\n"
      "  }\n"
      "  prev = dest;\n"
      "  prevt += duration;\n"
      "}\n"
      "\n"
      "void cameraPath(in float t, out vec3 ro, out vec3 ta, out vec3 up)\n"
      "{\n"
      "#ifndef HIDE_TERRAIN\n"
      "  time = t = mod(t, 92.);\n"
      "#else\n"
      "  time = t = mod(t, 66.);\n"
      "#endif\n"
      "  dro = dta = dup = 0.;\n"
      "\n"
      "  pro = ro = vec3(900., 7000., 1500.);\n"
      "  pta = ta = vec3(0., 0., 0.);\n"
      "  pup = up = vec3(0., 0.4, 1.);\n"
      "\n"
      "  camint(ro, t, 5., vec3(-4300., -1000., 500.), pro, dro);\n"
      "  camint(ta, t, 5., vec3(0., 0., 0.), pta, dta);\n"
      "  camint(up, t, 7., vec3(0., 0.1, 1.), pup, dup);\n"
      "\n"
      "  camint(ro, t, 3., vec3(-1355., 1795., 1.2), pro, dro);\n"
      "  camint(ta, t, 1., vec3(0., 300., -600.), pta, dta);\n"
      "  camint(up, t, 6., vec3(0., 0.1, 1.), pup, dup);\n"
      "\n"
      "  camint(ro, t, 10., vec3(-1355., 1795., 1.2), pro, dro);\n"
      "  camint(ta, t, 14., vec3(0., 100., 600.), pta, dta);\n"
      "  camint(up, t, 13., vec3(0., 0.3, 1.), pup, dup);\n"
      "\n"
      "  vec3 roe = seaUntransform(vec3(0., EARTH_RADIUS + 0.004, 0.));\n"
      "  vec3 upe = seaUntransform(vec3(0., 1., 0.));\n"
      "\n"
      "  camint(ro, t, 7., roe, pro, dro);\n"
      "  camint(ta, t, 7., vec3(EARTH_RADIUS + 0., EARTH_RADIUS - 500., "
      "500.),\n"
      "         pta, dta);\n"
      "  camint(up, t, 6., upe, pup, dup);\n"
      "\n"
      "  camint(ro, t, 17., roe, pro, dro);\n"
      "  camint(ta, t, 17.,\n"
      "         vec3(EARTH_RADIUS + 500., EARTH_RADIUS + 1300., -100.), pta,\n"
      "         dta);\n"
      "  camint(up, t, 18., vec3(.0, 1., 1.), pup, dup);\n"
      "\n"
      "  camint(ro, t, 11., vec3(3102., 0., 1450.), pro, dro);\n"
      "  camint(ta, t, 4., vec3(0., -100., 0.), pta, dta);\n"
      "  camint(up, t, 8., vec3(0., 0.15, 1.), pup, dup);\n"
      "#ifndef HIDE_TERRAIN\n"
      "  roe = terrainUntransform(vec3(0., EARTH_RADIUS + 0.004, 0.));\n"
      "  upe = terrainUntransform(vec3(0., 1., 0.));\n"
      "\n"
      "  camint(ro, t, 7., roe, pro, dro);\n"
      "  camint(ta, t, 12., vec3(-EARTH_RADIUS, EARTH_RADIUS + 200., 100.),\n"
      "         pta, dta);\n"
      "  camint(up, t, 2., upe, pup, dup);\n"
      "\n"
      "  roe = terrainUntransform(vec3(0., EARTH_RADIUS + 0.001, 0.));\n"
      "  camint(ro, t, 17., roe, pro, dro);\n"
      "  camint(ta, t, 18., roe + vec3(5000., EARTH_RADIUS - 100., -2000.),\n"
      "         pta, dta);\n"
      "  camint(up, t, 18., vec3(.0, 1., 1.), pup, dup);\n"
      "\n"
      "  roe = terrainUntransform(vec3(0., EARTH_RADIUS + 1.8, 0.));\n"
      "  camint(ro, t, 4., roe, pro, dro);\n"
      "  camint(ta, t, 4.5,\n"
      "         roe + vec3(EARTH_RADIUS, EARTH_RADIUS + 2000., -30.), pta,\n"
      "         dta);\n"
      "  camint(up, t, 4., vec3(.0, 1., 1.), pup, dup);\n"
      "#endif\n"
      "  camint(ro, t, 10., vec3(900., 7000., 1500.), pro, dro);\n"
      "  camint(ta, t, 2., vec3(0., 0., 0.), pta, dta);\n"
      "  camint(up, t, 10., vec3(0., 0.4, 1.), pup, dup);\n"
      "\n"
      "  up = normalize(up);\n"
      "}\n"
      "\n"
      "//-----------------------------------------------------\n"
      "// mainImage\n"
      "//-----------------------------------------------------\n"
      "\n"
      "void main(void)\n"
      "{\n"
      "  vec2 uv = vUV.xy;\n"
      "  vec2 p  = -1.0 + 2.0 * vUV.xy;\n"
      "  p.x *= resolution.x / resolution.y;\n"
      "\n"
      "  vec3 col;\n"
      "\n"
      "  // black bands\n"
      "  vec2 bandy = vec2(.1, .9);\n"
      "  if (uv.y < bandy.x || uv.y > bandy.y) {\n"
      "    col = vec3(0.);\n"
      "  }\n"
      "  else {\n"
      "    // camera\n"
      "    vec3 ro, ta, up;\n"
      "    cameraPath(iTime * .7, ro, ta, up);\n"
      "\n"
      "    vec3 ww = normalize(ta - ro);\n"
      "    vec3 uu = normalize(cross(ww, up));\n"
      "    vec3 vv = normalize(cross(uu, ww));\n"
      "    vec3 rd = normalize(-p.x * uu + p.y * vv + 2.2 * ww);\n"
      "\n"
      "    float maxd = MAX;\n"
      "    col        = renderStars(rd).xyz;\n"
      "\n"
      "    vec4 planet = renderPlanet(ro, rd, up, maxd);\n"
      "    if (planet.w > 0.)\n"
      "      col.xyz = planet.xyz;\n"
      "\n"
      "    float atmosphered = maxd;\n"
      "    vec4 atmosphere   = .85 * renderAtmospheric(ro, rd, atmosphered);\n"
      "    col               = col * (1. - atmosphere.w) + atmosphere.xyz;\n"
      "\n"
      "    vec4 ring = renderRing(ro, rd, maxd);\n"
      "    if (ring.w > 0. && atmosphered < maxd) {\n"
      "      ring.xyz = ring.xyz * (1. - atmosphere.w) + atmosphere.xyz;\n"
      "    }\n"
      "    col = col * (1. - ring.w) + ring.xyz;\n"
      "\n"
      "#ifdef DISPLAY_CLOUDS\n"
      "    float lro = length(ro);\n"
      "    if (lro < EARTH_RADIUS + EARTH_CLOUDS * 1.25) {\n"
      "      vec3 sunColor = 2. * renderAtmosphericLow(ro, SUN_DIRECTION);\n"
      "      vec3 upColor  = 4. * renderAtmosphericLow(\n"
      "                            ro, vec3(-SUN_DIRECTION.x, "
      "SUN_DIRECTION.y,\n"
      "                                     -SUN_DIRECTION.z));\n"
      "\n"
      "      if (lro < EARTH_RADIUS + EARTH_CLOUDS) {\n"
      "        // clouds\n"
      "        float d = iCSphereF(ro, rd, EARTH_RADIUS + EARTH_CLOUDS);\n"
      "        if (d < maxd) {\n"
      "          float shadow;\n"
      "          vec4 clouds = renderClouds(ro, rd, d, normalize(ro), 0.,\n"
      "                                     sunColor, upColor, shadow);\n"
      "          clouds.w *= 1. - smoothstep(0.8 * EARTH_CLOUDS, "
      "EARTH_CLOUDS,\n"
      "                                      lro - EARTH_RADIUS);\n"
      "          col = mix(col, clouds.rgb,\n"
      "                    clouds.w * (1. - smoothstep(10., 30., d)));\n"
      "        }\n"
      "      }\n"
      "      float offset = lro - EARTH_RADIUS - EARTH_CLOUDS;\n"
      "      col\n"
      "        = mix(col, .5 * sunColor,\n"
      "              .15 * abs(noise(offset * 100.))\n"
      "                * clamp(1. - 4. * abs(offset) / EARTH_CLOUDS, 0., "
      "1.));\n"
      "    }\n"
      "#endif\n"
      "\n"
      "    // post processing\n"
      "    col = pow(clamp(col, 0.0, 1.0), vec3(0.4545));\n"
      "    col *= vec3(1., 0.99, 0.95);\n"
      "    col = clamp(1.06 * col - 0.03, 0., 1.);\n"
      "\n"
      "    vec2 sunuv\n"
      "      = 2.7 * vec2(dot(SUN_DIRECTION, -uu), dot(SUN_DIRECTION, vv));\n"
      "    float flare = dot(SUN_DIRECTION, normalize(ta - ro));\n"
      "    col += vec3(1.4, 1.2, 1.0) * lensFlare(p, sunuv)\n"
      "           * clamp(flare + .3, 0., 1.);\n"
      "\n"
      "    uv.y = (uv.y - bandy.x) * (1. / (bandy.y - bandy.x));\n"
      "    col *= 0.5\n"
      "           + 0.5 * pow(16.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - "
      "uv.y),\n"
      "                       0.1);\n"
      "  }\n"
      "  gl_FragColor = vec4(col, 1.0);\n"
      "}\n";

public:
  ShaderMaterialPlanetShadertoyScene(ICanvas* iCanvas)
      : IRenderableScene(iCanvas), _time{0.f}, _shaderMaterial{nullptr}
  {
    // Vertex shader
    Effect::ShadersStore()["customVertexShader"] = customVertexShader;

    // Fragment shader
    Effect::ShadersStore()["customFragmentShader"] = customFragmentShader;
  }

  ~ShaderMaterialPlanetShadertoyScene() override = default;

  const char* getName() override
  {
    return "Shader Material Planet Shadertoy Scene";
  }

  void initializeScene(ICanvas* canvas, Scene* scene) override
  {
    // Create a FreeCamera, and set its position to (x:0, y:0, z:-10)
    auto camera = FreeCamera::New("camera1", Vector3(0.f, 0.f, -8.f), scene);

    // Target the camera to scene origin
    camera->setTarget(Vector3::Zero());

    // Attach the camera to the canvas
    camera->attachControl(canvas, true);

    // Create a basic light, aiming 0,1,0 - meaning, to the sky
    HemisphericLight::New("light1", Vector3(0.f, 1.f, 0.f), scene);

    // Create a built-in "box" shape
    const float ratio = static_cast<float>(getEngine()->getRenderWidth())
                        / static_cast<float>(getEngine()->getRenderHeight());
    BoxOptions options;
    options.size            = 5.f;
    options.sideOrientation = Mesh::DEFAULTSIDE;
    options.updatable       = false;
    options.width           = *options.size * ratio;
    auto skybox             = MeshBuilder::CreateBox("skybox", options, scene);

    // Create shader material
    IShaderMaterialOptions shaderMaterialOptions;
    shaderMaterialOptions.attributes = {"position", "uv"};
    shaderMaterialOptions.uniforms = {"iTime", "worldViewProjection", "aspectRatio", "resolution"};
    _shaderMaterial = ShaderMaterial::New("boxShader", scene, "custom", shaderMaterialOptions);

    // box + sky = skybox !
    skybox->material = _shaderMaterial;

    // Animation
    scene->onAfterCameraRenderObservable.add([this](Camera*, EventState&) {
      const Vector2 resolution{static_cast<float>(_engine->getRenderWidth()),
                               static_cast<float>(_engine->getRenderHeight())};
      const float aspectRatio = resolution.x / resolution.y;
      _shaderMaterial->setFloat("iTime", _time);
      _shaderMaterial->setFloat("aspectRatio", aspectRatio);
      _shaderMaterial->setVector2("resolution", resolution);
      _time += 0.01f * getScene()->getAnimationRatio();
    });
  }

private:
  float _time;
  ShaderMaterialPtr _shaderMaterial;

}; // end of class ShaderMaterialPlanetShadertoyScene

BABYLON_REGISTER_SAMPLE("Shader Materials", ShaderMaterialPlanetShadertoyScene)

} // end of namespace Samples
} // end of namespace BABYLON
